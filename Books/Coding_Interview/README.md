# Coding Interview

## Chapter 01. 면접과정

### 면접간 문제 풀이

- 문제를 풀어가는 사고과정을 최선을 다해 소리내어 표현해야 한다.
  - 소리 뿐 아니라 어떤 방법으로든 면접관에게 자신의 사고 과정을 전달 할 수 있어야 한다.

### 면접 평가의 지표

- 분석 능력
  - 문제를 푸는데 도움을 많이 받았는가?
  - 최적화를 얼마나 수행하는가?
  - 문제 풀이 시간이 얼마나 소요되었는가?
  - 디자인/설계시에 문제를 제대로 이해하였는가?
  - 다양한 방법에 대한 장단점을 고려하는가?
- 코딩 능력
  - 알고리즘을 적절한 코드로 표현할 수 있는가?
  - 코드는 깔끔하게 잘 구성되어 있는가?
  - 발생 가능한 에러에 대해 고려하였는가?
  - 코드 스타일은 어떤가?
- 기술적 지식 및 컴퓨터 과학 기본기
  - CS 및 관련 기술에 대한 관심과 기본기가 갖추어져 있는가?
- 경험
  - 과거에 기술적 결정을 해 본 적이 있는가?
  - 흥미롭고 도전적인 프로젝트를 경험한 적 있는가?
  - 진취성, 결단성 등 요소를 발휘한 적이 있는가?
- 컬쳐핏, 의사소통 능력
  - 성격과 가치관이 회사와 잘 맞는가?
  - 면접관과 의사소통이 원활한가?

### 면접 방식이 왜 이래야 하는가?

- 물론 현재 면접의 방식이 지원자를 완전하게 평가 할 수는 없다.
- 그러나, 위와 같은 문제에도 불구하고 이러한 방식의 면접은 필요하다.

#### 부정 오류과 긍정 오류

- 회사의 입장에서, 부정 오류보다는 긍정 오류가 더 심각하다.
- 즉, 정말 유능한 지원자를 몇 명 잃더라도, 무능한 지원자를 채용하는 것 보다는 낫다는 것이다.

#### 문제풀이는 꽤 가치 있는 능력이다

- 또한 본질적으로 어려운 문제를 풀어내는 사람이라면, 대체로 최적의 알고리즘을 개발하는 능력이 더 뛰어날 것이기 때문이다.

#### 기초적인 자료구조와 알고리즘 지식은 유용하다

- 트리, 그래프, 리스트, 정렬 등과 같은 지식은 주기적으로 이해해 둘 필요가 있다.
  - 이 요소의 존재를 알고있어야 필요한 곳에 사용할 수 있으며,
  - 존재를 알고있다면 대체로 기본적인 이해는 하고있다고 볼 수 있다.
- 또한 자료구조나 알고리즘을 안다는 것 자체가 지원자가 CS에 대해 기술적인 지식을 가지고 있던지, 스스로 공부해서 습득했다는 것을 증명하기 때문이다.

### 어떤 물제를 출제하는가

- 대다수의 회사는, '전사적 차원에서의 면접 질문' 을 가지고있지 않다.
- 대체로 면접관이 적절한 질문지를 선택한다.
- 다만, 넓은 의미에서의 '회사별 차이점'은 존재한다.
  - 어떤 회사는 알고리즘에 집중하고
  - 어떤 회사는 CS 지식에 기반한 질문을 한다.

## Chapter 02. 장막 너머

- 대체로 면접 대상자로 선별되면 아래의 절차를 밟는다
  1. 사전 면접(Screening interview)
  2. 세 번에서 여섯 번의 대면 면접
- 만약 면접 후 일주일 이상 답변이 없다면, 대체로 구인 담당자에게 연락을 해 보는 것이 좋다.

### 회사별 면접 중점

#### 각 회사별 특이사항 및 중점요소

- 마이크로소프트
  - "마이크로소프트에서 일하고 싶은 이유는?"
    - 이 질문을 통해 기술에 대한 열정 등을 알고자 한다.

- 아마존
  - 규모 확장성(Scalability) 관련 질문
  - 객체 지향 디자인(OOP)

- 구글
  - 규모 확장이 가능한 시스템(Scalable System)을 어떻게 설계하는가
  - 분석(알고리즘) 문제

- 애플
  - 면접을 진행하는 팀의 제품에 대한 적극적이고 구체적인 피드백

- 페이스북
  - 개발자의 기업가 정신
  - 빠른 시일 내에 결과를 확인 할 수 있도록 하는 자세

- 펠런티어
  - 핵심 자료구조와 알고리즘
  - 백엔드 시스템 디자인 요소

#### 회사별 중점요소를 통해 알 수 있는 것

- 면접에 다양한 전략이 있을 수 있다.
- 그러나 그중에서도 가장 기본이 되는 알고리즘과 문제 해결 능력이 다방면에서 도움이 될 수 있다.

## Chapter 03. 특별한 상황에서의 면접

### 경력자

- 경력자의 경우에도 알고리즘 문제를 물어 볼 가능성이 있음
  - 이는, 문제해결 능력은 모든 수준의 개발자에게 중요하기 때문임.
- 다만, 시스템 디자인/설계 및 이력서와 관련된 질문에 좀 더 포커스를 두게 됨.
  - 이러한 질문은 경력자의 경험에 대해 알아 볼 수 있는 질문이기에 좀 더 중요성이 부여됨.
- '가장 고치기 힘든 버그가 무엇이었나요?' 등의 질문에 인상적인 답변을 준비하자.

### 테스터 혹은 SDET(Software Design Engineer in Test)

- SDET: 실제 제품이 아닌, 테스트를 위한 코드를 작성하는 개발자.
- 준비사항
  - 테스트에 관한 질문에 대비하라: '전구를 어떻게 테스트 할 것인가?'
  - 코딩 관련 질문에 대비: 어디까지나 개발자인 이상, 코딩 능력은 필수적임.
  - 코딩 결과를 테스트하는 훈련을 해라: 테스트 코드를 작성하는 것은 코딩 능력을 향상시키는 좋은 방법임.
- 유의사항
  - 일반적으로 SDET에서 개발자로 전환하는 것은 어렵다. 그렇기에 개발자가 되는 루트 중 하나로 사용하는것은 좋지 않다.

### PM(Product Manager || Program Manager)

- 이름은 비슷하지만 회사마다 매우 다른 역할을 수행함.
- 준비사항
  - 모호성에 대한 대응: 모호한 경우에 결정하지 못하고 패닉에 빠지지 않아야 함. 어떻게든 결정하고 진행하는 모습을 보여야 함.
  - 고객에 초점을 맞추는가(태도): 고객의 입장에서 생각하고, 고객의 요구사항을 충족시키는 방법을 고민해야 함.
  - 고객에 초점을 맞추는가(기술적 능력): 고객이 사용할 제품에 대한 기술적인 이해가 있다면 더욱 좋음.
  - 다층적 의사소통: PM은 직업적 특성상 매우 많은 계층의 사람들과 협업해야 함. 따라서 유연한 의사소통 능력을 갖추어야 함.
  - 기술에 대한 열정: 자신의 일을 열정적으로 즐길 수 있는 사람이라면, 더욱 좋음.
  - 팀워크/리더십: PM은 팀을 이끌어야 하기에, 팀워크와 리더십 능력이 필수적임.

### 개발 책임자(Dev Lead)와 관리자(Dev Manager)

- 준비사항
  - 팀워크/리더십: 개발자이지만 관리직인 이상 팀을 이끌어야 하기에, 팀워크와 리더십 능력이 필수적임.
  - 우선순위: 빡빡한 데드라인 속에서 덜 중요한 부분을 어떻게 쳐낼지에 대한 기준을 갖추어야 함.
  - 소통: 윗사람, 아랫사람, 고객 등 넓은 범위의 사람들과 소통하는 능력이 필요함.
  - 책임감: 관리자로서 가장 중요한 부분은 맡은 일을 끝까지 해내는 것임. 또한, '프로젝트를 준비하는 것' 과 '프로젝트를 수행하는 것'의 균형을 잘 맞추어야 함.

### 스타트업

- 스타트업은 회사별로 지원 절차와 면접 과정이 매우 다름. 따라서 일반적인 고려 요소만 나열함

#### 지원 절차

- 구인공고 확인 이외에도, 추천이나 직접 연락을 취해보는 것도 좋음.
- 굳이 아는 사람이 아니더라도, 관심을 표하고 양해를 구하는 것 만으로도 이력서를 읽어 봐 줄 누군가를 찾을 수 있음.

#### 비자와 취업 승인

- 외국인으로서 비자가 필요하다면, 대부분의 스타트업은 취업 비자를 제공하기 어려움.
- 따라서 전문 리크루터를 찾거나, 규모가 큰 스타트업을 찾아보는 것이 나음.

### 실전성

- 스타트업의 특성상, 단순히 똑똑하고 코딩을 잘 하는 사람이 필요한 게 아니라, 여러 실제 상황에 대응 할 수 있는 사람이 필요함.
- 때로는 사업가적 자질이 요구되는 경우도 있음.
- 즉 스타트업에서 즉시 업무에 투입될 수 있는 사람을 선호함.

### 기업인수 및 인재영입

- 기업 인수나 인재영입 과정을 거쳐 채용되는 경우도 있음.
- 그러나 이 과정에서도 모두가 채용되는 경우 이외에, 면접을 거치는 경우가 있으며 이는 매우 중요함.
- 면접을 망치는 경우, 인수인계를 위해 6개월 가량의 단기 계약직으로 근무하는 경우도 있고, 바로 퇴사하는 경우도 있음.

### 면접관의 입장(에서 본 우리가 준비할 사항)

#### 여기에 있는 문제를 그대로 사용하지 말라

- 즉, 여기에 있는 문제가 그대로 나올리는 거의 없다. 비슷한 유형의 다른 문제를 많이 겪어보자.

#### 중간 이상의 어려운 문제를 출제하라

- 너무 쉬운 문제는 크게 도움되지 않는다. 중간 이상, 어려운 문제에 포커스를 하자.

#### 여러 가지 난관을 거쳐야 하는 문제를 찾으라

- 한번의 '아하'를 통해 풀리는 문제는 대체로 출제되지 않는다. 이는 지원자의 운에 의해 역량이 좌우될 가능성이 있기 때문이다.
- 여러 과정을 거쳐서 문제를 해결해야 하는 문제를 찾아보자.

#### 알기 어려운 지식이 아닌 풀기 어려운 문제를 출제하라

- 아무도 관심없고 알 수 없는 지식을 문제로 내는 경우는 없다.
- 즉, 마이너한 분야에 대한 지식을 기반으로 푸는 문제는 거의 없다.
- 따라서 잘 알려진 자료구조와 알고리즘을 위주로 공부하자.

#### 겁을 주는 문제를 피하라

- 겁을 주는 문제?
  - 수학, 확률 문제
  - 로우 레벨 지식(메모리 할당 등)
  - 시스템 디자인, 확장성
  - 영리 제품 등
- 이러한 문제가 나온다면, 대부분 수학이나 확률 등으로 푸는 문제가 아닐 가능성이 높다.
- 쫄지 말자.

#### 지원자를 긍정적으로 대하라

- 지원자도 마찬가지로, 면접관을 긍정적으로, 예의를 갖춰서 대하자.

#### 행동 질문을 철저히 하라

- 많은 지원자들이 '팀'으로서 활동해 왔기에 자신의 성취를 표현하는데에 어려움을 겪는다.
- 즉, 우리는 자신의 경험을 최대한 가감없이 구체적으로 표현해야 한다.

#### 지원자에게 조언하라

- 면접관에 대한 조언
  - 지원자가 적당한 예제를 사용하도록 조언하라.
  - 지원자가 해법을 찾기 전에 코딩을 시작하지 않고, 해법을 찾은 후에 코딩을 시작하도록 조언하라.
  - 지원자가 아무것도 하지 못한다면, 브루트 포스 등의 간단한 힌트나 해법을 제시하라.
- 지원자의 행동
  - 최대한 최적의 알고리즘을 먼저 설계한다.
  - 브루트 포스 등의 간단한 해법이 있는지 찾아본다.
  - 필요시 면접관에게 힌트를 요청해도 좋다.

#### 그들이 생각할 시간을 원한다면 생각할 시간을 주라

- 즉, 지원자가 생각할 시간이 필요하다면, 생각할 시간을 요청해라.

#### 방식을 정하라: 네 가지 면접 방식

- 새너티 테스트(Sanity check)
  - 쉬운 문제나 디자인 문제에 관한 것.
  - 최약의 지원자를 걸러내기 위한 문제.
- 수준 테스트(Quality check)
  - 좀 더 도전적인 문제.
  - 철저하게 설계되어 알고리즘, 문제풀이 능력을 테스트하는 문제.
  - 너무 쉽거나, 형편없는 문제를 출제하지 않아야 함.
- 전문가 문제(Specialist question)
  - 지원자의 전문 분야에 관한 문제.
  - 지원자의 전문 분야에 대한 지식을 테스트하는 문제.
- 프락시 지식(Proxy knowledge)
  - 지원자의 수준에서 알 법 한 문제.

## Chapter 04. 면접 전에

- 시작이 늦었더라도, 할수 있는만큼 따라잡기 위한 노력을 하자.

### 적절한 경험 쌓기

- 탄탄한 이력과 면접을 위한 기본은, 훌륭한 이력을 쌓는 것임.
- 예시
  - 큰 규모의 프로젝트 수업을 들어라.
  - 인턴 자리를 알아보자.
  - 해커톤이든 사이드든, 뭔가를 하라.
- 다른 직종에서 개발자로의 전직을 원한다면
  - 코딩을 많이 할 수 있는 업무를 하라
  - 저녁과 주말을 활용해, 개인적인 프로젝트를 진행하라
- 결론적으로, 회사는 **코딩을 할 수 있고 영리한 사람**을 뽑는다.

### 탄탄한 이력서 작성하기

- 적절한 이력서 길이: 미국에서는 경력 10년차 미만은 1페이지, 10년차 이상은 2페이지를 권장함.
  - 경우에 따라 긴 이력서는 바로 스킵당할 수 있음.
- 과거 직함을 전부 나열할 필요는 없고, 관련 이력만 나열하자.
- '무엇을', '어떻게', '결과는 어떠했나'를 중점으로 작성하자
  - 분산 캐시를 구현해서 오브젝트 렌더링 시간을 75% 줄였고, 결과적으로 로그인 시간을 10% 경감 할 수 있었다.
- 경험한 프로젝트
  - 강조할만한 프로젝트 2~4개만 기입하자.
    - 쓸모없는 프로젝트가 자리만 차지하지 않게 해라.
- 소프트웨어(툴)와 프로그래밍 언어
  - 소프트웨어는 가급적 언급하지 말자.
    - vscode를 쓸 줄 아는게 중요한가? 배우기 어려운가?
  - 프로그래밍 언어
    - 사용해본 언어를 전부 적는것은 위험하다.
    - 사용해본 언어를 적되, 언어에 대한 이해도를 적어두자.
      - JS/TS(중급), PHP(중급), Python(경험 있음)
- 오탈자를 꼭 확인하자.
- 특정 언어를 지나치게 강조하지 말자.

### 준비절차

![Alt text](images/image01.png)
![Alt text](images/image02.png)

## Chapter 05. 행동 문제

### 대비 요령

- 주로 주어지는 질문 목록 작성해보기. 3개정도의 프로젝트에 대해 아래의 질문에 답변 해 보자.
  - 가장 도전적이었던 것
  - 실수 혹은 경험담
  - 즐거웠던 것
  - 리더십
  - 팀원과의 갈등
  - 남들과 다르게 행동했던 것
- 본인의 '진짜' 단점을 언급하자.
  - 본인을 포장하기 위해 '너무 열심히 일하는 게 단점입니다.' 등의 답변은 오만해 보일 수 있다.
- 면접관에게 할 질문들
  - 순수한 질문
    - '테스터, 개발자, PM의 비율이 어떻게 되나요?'
    - '서로 어떻게 협조하나요?' 등
    - '면접관께서는 어떻게 이 회사에 오시게 되었나요?'
  - 통찰력을 보여줄 수 있는 질문
    - 'X라는 기술을 사용하고 계신데, Y 문제는 어떻게 해결하고 계신가요?'
    - '제품에 A 대신 B 기술을 사용하신 이유가 있나요? a, b, c 등의 장점이 있지만 d라는 이슈가 있어서 사용하지 않는 회사도 많다고 알고 있습니다.'
  - 열정을 보여 줄 수 있는 질문
    - '저는 규모 확장성에 흥미가 있는데, 이 회사에서 이를 배울 수 있을까요?'
    - 'X 기술을 잘은 모르지만 재미있는 해법이 될 것 같네요. 어떻게 동작하는지 설명 해 주실 수 있으실까요?'

### 기술적 프로젝트에 대한 이해

- 최소한 두세가지 이상의 프로젝트에 대해 집중적으로 깊이 알고있어야 함.
- 아래 기준이 부합하는 프로젝트라면 더욱 좋음.
  - 단순히 많이 배웠던 것을 넘어서 도전적인 요소가 있었던 프로젝트
  - 자신이 중심 역할을 수행했던 프로젝트
  - 기술적으로 깊이있는 이야기를 할 수 있는 프로젝트
- 그 외 알아두면 좋은 요소들
  - 도전적인 면
  - 일으켰던 실수
  - 기술적 결정
  - 기술의 선택과 그에 대한 실익
  - 남들과는 다르게 할 수 있었던 것
  - 이후 개선할 수 있었던 것
  - 장차 확장 방안 등

### 행동 질문에 대한 대처 요령

- 최대한 구체적으로 답하고, 오만하게 굴지 말자.
- 지나친 세부사항은 언급하지 말자.
  - 면접자는 세부사항을 정확히 모르고, 궁금하지 않을 수 있다.
  - 필요하다면 면접자가 스스로 파고 들 수 있도록, 핵심만 언급하자.
    - '가장 보편적인 사용자 행위 패턴을 검사하고 Rabin-Karp 알고리즘을 사용하여 90%정도 경우에 대해 검색시간을 O(n)에서 O(log n)으로 줄이는 알고리즘을 설계했습니다. 궁금하시다면 좀 더 자세히 말씀드리도록 하겠습니다.'
- 팀이 아닌, 자신의 성과에 대해 이야기하자.
  - '우리', '우리 팀'에 대해서만 이야기하면, 자신의 역할을 면접관에게 충분히 전달하지 못할 수 있다.
- 구조적인 답변을 내놓으라
  - 정보 우선(Nugget first)
    > '학부생들이 자기 과목을 직접 가르치도록 학교 당국을 설득했던 상황에 대해 이야기해 드리죠.  
    > 제가 다니던 학교는 처음에는...'
  - S.A.R(Situation, Action, Result)
    > 상황(S): 프로젝트에 인원 셋이 추가되었는데 한명만 유난히 성과가 적고 소극적이었다.

    > 행동(A): 그와 대화를 시도했고, 그는 자신이 코드를 작성할 자격이 없다고 생각한다는 점을 밝히고 문서작업을 희망한다고 하였다. 그런 그에게 걱정하지 말고 코드작업에 참여 할 수 있도록 직접 설계하며 겁낼 필요 없다는 점을 인지시켰다.

    > 결과(R): 그는 자신감을 되찾고 코드작업에 참여하였고, 프로젝트는 성공적으로 마무리 되었다.

- 위 접근법을 사용해, 자신의 이야기 목록을 만들어 두자.  
  | 구분 | 핵심(nugget) | 상황 | 행동 | 결과 | 말하고자 하는 것 |
  |---|---|---|---|---|---|
  | 이야기1 | 핵심 | 상황 | 1. ... <br> 2. ... <br> 3. ... | 결과 | 결론 |
  | 이야기2 | 핵심 | 상황 | 1. ... <br> 2. ... <br> 3. ... | 결과 | 결론 |

- 또한, 그 이야기를 분석해서 전달하고자 하는 부분이 제대로 전달되는지 확인하자.

### 그러니까, 당신에 대해 말해보세요

- 여러분의 이야기를 구성하는 방법
  - 기본은 시간순으로 구성하기
    - 현재 직업/상태(서두)
    - 학교
    - 졸업 후 지금까지
    - 현재 역할(자세히)
    - 업무 외에
    - 마무리
  - 취미 등은, 아래의 경우에 포함되지 않는다면 언급하지 않는 것이 좋다.
    - 굉장히 독특한 취미를 가진 경우
    - 기술적인 면이 포함된 경우
    - 긍정적인 성격적 특성을 보여주는 경우 등

## Chapter 06. big-O

### 비유하기

- 파일전송의 예제: A가 B에게 파일을 전송한다면?
  - 일반적으로는 인터넷으로 전송하는것이 가장 빠를 것임.: 100Mb/s -> 10테라 기준, 약 1.1~1.2일 정도 소요
  - 그러나 용량이 크다면(수십 테라), 데이터 저장장치를 직접 들고 비행기 등으로 운송하는 것이 더 빠를 수 있음.: 1일(용량에 상관없음. 고정)

### 시간복잡도

- 점근적 실행 시간(asymptotic running time): 입력의 크기가 무한대로 향할 때의 실행 시간
- 예시
  - 온라인 전송: O(s)
    - s: 전송할 데이터의 용량. 용량이 증가하면 시간은 선형적으로 증가함.
  - 비행기를 통한 이동: O(1)
    - 1: 비행기가 이동하는 시간. 용량이 커져도 이는 고정된 상수값임.
- 이외에도 O(log n), O(n log n), O(n^2), O(2^n) 등이 있음.
- big-Ω, big-O, big-Θ 등이 있음.
  - big-Ω: 최선의 경우
  - big-O: 최악의 경우
  - big-Θ: 평균의 경우
- 일반적으로 big-O를 사용함.
- 구체적인 예시
  - 퀵 정렬
    - 최선의 경우: O(n) -> 이미 정렬된 경우
    - 최악의 경우: O(n^2) -> 역순으로 정렬된 경우
    - 평균의 경우: O(n log n)

### 공간복잡도

- 크기가 n인 배열을 만들어야 한다면, O(n)의 공간이 필요하다.
- 크기가 n x n 크기의 2차원 배열을 만들어야 한다면, O(n^2)의 공간이 필요하다.
- 재귀 호출을 사용 시 스택 공간 또한 계산에 포함된다.
- 그러나 단순히 n번 호출했다고 해서 O(n)의 공간을 사용하는 것은 아니다.

### 상수항은 무시하라

- O(n + 1), O(2n) 등의 표기는 무의미하고, 더 정확하지도 않다.

### 지배적이지 않은 항은 무시하라

- O(n^2 + n) = O(n^2)
- big-O에서 가장 중요한 것은, '입력의 크기가 무한대로 향할 때의 실행 시간' 이다.
- 따라서 상수항이나 지배적이지 않은 항은 무시해야한다.
- 단 O(n^2 + m)과 같이, 서로 다른 입력의 크기를 가지는 경우는 무시할 수 없다.
  - m과 n의 관계를 모르는 이상 무시할 수 없다.
  
![Alt text](images/image03.png)

- n = 10일 때 각각의 값
  - n!: 3,628,800
  - 2^n: 1,024
  - n^2: 100
  - n log n: 33
  - n: 10
  - log n: 3

### 여러 부분으로 이루어진 알고리즘: 덧셈 vs 곱셈

- 덧셈: O(A + B)

  ```ts
  for (a of arrA) {
    print(a);
  }

  for (b of arrB) {
    print(b);
  }
  ```

- 곱셈: O(A * B)

  ```ts
  for (a of arrA) {
    for (b of arrB) {
      print(a + ',' + b);
    }
  }
  ```

### 상환 시간

- ArrayList(동적 가변크기 배열)는 일반적으로 O(1)의 시간복잡도를 가진다.
- 그러나, 배열의 크기가 커지면서 배열의 크기를 늘려야 하는 경우가 생긴다.
  - 이 경우, 2n 크기의 배열을 새로 만들고 원소 전체를 복사하는 데에 O(n)의 시간이 소요된다.
  - 하지만 이런 경우는 극히 드물다.
    - 1, 2, 4, 8, 16, 32, ... X 마다 발생하며, 이를 모두 더하면 대략 2X가 된다.
- 결과적으로 ArrayList의 삽입연산은 O(2X / X) -> O(1)의 시간복잡도를 가진다.

### log N 수행 시간

- 이진 탐색 트리의 탐색 시간은 O(log n)이다.
- 이진 탐색 트리의 높이는 log n이다.
- big-O에서는 로그의 밑을 명시하지 않는다. 이는 고려 할 필요가 없기 때문이다.

### 재귀적으로 수행 시간 구하기

```ts
function f(n: number): number {
  if (n <= 1) {
    return 1;
  }
  return f(n-1) + f(n-1);
}
```

- 이 경우는 O(2^n)이다.
- 이는 재귀 호출이 두 번 일어나기 때문에 이진 트리의 노드 수와 같다.

### 예제 및 연습문제

예제 1.
  
  ```ts
  function foo(arr: number[]) {
    let sum = 0;
    let product = 1;
    for (let i = 0; i < arr.length; i++) {
      sum += arr[i];
    }
    for (let i = 0; i < arr.length; i++) {
      product *= arr[i];
    }
    console.log(sum + ',' + product);
  }
  ```

- 답: O(n)

예제 2.

  ```ts
  function printPairs(arr: number[]) {
    for (let i = 0; i < arr.length; i++) {
      for (let j = 0; j < arr.length; j++) {
        console.log(arr[i] + ',' + arr[j]);
      }
    }
  }
  ```

- 답: O(n^2)

예제 3.

  ```ts
  function printUnorderedPairs(arr: number[]) {
    for (let i = 0; i < arr.length; i++) {
      for (let j = i + 1; j < arr.length; j++) {
        console.log(arr[i] + ',' + arr[j]);
      }
    }
  }
  ```

- 답: O(n^2) -> 2번보다 약 절반의 케이스만 다루지만, O(n^2 / 2) = O(n^2)이다.

예제 4.

  ```ts
  function printUnorderedPairs(arrA: number[], arrB: number[]) {
    for (let i = 0; i < arrA.length; i++) {
      for (let j = 0; j < arrB.length; j++) {
        if (arrA[i] < arrB[j]) {
          console.log(arrA[i] + ',' + arrB[j]);
        }
      }
    }
  }
  ```

- 답: O(ab) -> a, b의 관계를 알 수 없으므로, a, b를 모두 고려해야 한다.

예제 5.

  ```ts
  function printUnorderedPairs(arrA: number[], arrB: number[]) {
    for (let i = 0; i < arrA.length; i++) {
      for (let j = 0; j < arrB.length; j++) {
        for (let k = 0; k < 100000; k++) {
          console.log(arrA[i] + ',' + arrB[j]);
        }
      }
    }
  }
  ```

- 답: O(ab) -> 100000은 상수이므로 무시한다.

예제 6.

  ```ts
  function reverse(arr: number[]) {
    for (let i = 0; i < arr.length / 2; i++) {
      const other = arr.length - i - 1;
      const temp = arr[i];
      arr[i] = arr[other];
      arr[other] = temp;
    }
  }
  ```

- 답: O(n) -> 배열의 절반만큼만 반복하지만, O(n / 2) = O(n)이다.

예제 7. 다음 중 O(n)과 같은 것은 무엇인가?

- 보기
  1. O(n + p), p < n/2
  2. O(2n)
  3. O(n + log n)
  4. O(n + m)

- 답: 1, 2, 3 -> 4는 m과 n의 관계를 알 수 없으므로, 무시할 수 없다.

예제 8. 여러 개의 문자열로 구성된 배열이 주어졌을 때, 각각의 문자열을 정렬하고 전체 배열을 다시 정렬하는 알고리즘이 있다. 이 알고리즘의 시간복잡도는 무엇인가?

- 대표적인 오답
  - 각각의 문자열을 정렬하는데 O(n * n log n)이 소요된다.
  - 전체 배열을 다시 정렬하는데 O(n log n)이 소요된다.
  - 따라서 결과적으로 O(n^2 log n + n log n) = O(n^2 log n)이 소요된다.
- 오답인 이유
  - 두 가지 정렬은 서로 다른 입력을 가지므로, 두 가지 정렬을 합쳐서 계산할 수 없다.
  - 정렬에 필요한 비교에 소요되는 시간 복잡도를 고려하지 않았다.
- 답: O(a * s(log a + log s)) -> a: 배열의 크기, s: 문자열의 길이
  - 각각의 문자열을 정렬하는데 O(s log s)가 소요된다.
  - 전체 배열을 다시 정렬하는데 O(s * a log a)가 소요된다.
    - 각 배열의 문자열을 비교하는 시간 O(s) * 비교 횟수 O(a log a) = O(s * a log a)가 소요된다.

예제 9.

  ```ts
  function sum(node: Node) {
    if (node === null) {
      return 0;
    }
    return sum(node.left) + node.value + sum(node.right);
  }
  ```

- 답: O(n) -> 이진 트리의 노드 수와 같다.
  - 두 가지 해법
    - 코드가 무엇을 의미하는가?
      - 이 코드는 트리의 각 노드를 방문한 뒤, 각 노드에서 상수 시간이 소요되는 연산을 수행한다.
      - 즉, 트리의 노드 수와 같은 시간이 소요된다.
    - 재귀호출 패턴분석
      - 재귀함수의 수행시간은 일반적으로 O(분기 ^ 깊이)이다.
      - 그렇다면 이 함수의 경우는 O(2 ^ 깊이)가 될 것이다.
      - 그런데 이 트리는 균형 이진 트리이므로, 깊이는 대략 log n이다.
      - 따라서 O(2 ^ log n) = O(n)이 된다.

예제 10.

  ```ts
  function isPrime(n: number): boolean {
    for (let x = 2; x * x <= n; x++) {
      if (n % x === 0) {
        return false;
      }
    }
    return true;
  }
  ```

- 답: O(n ^ 1/2)

예제 11.

  ```ts
  function factorial(n: number): number {
    if (n < 0) {
      return -1;
    } else if (n === 0) {
      return 1;
    } else {
      return n * factorial(n - 1);
    }
  }
  ```

- 답: O(n) -> 단순히 n번 재귀호출을 수행하므로, O(n)이다.

예제 12.

  ```ts
  function permutations(str: string) {
    permutation(str, '');
  }
  
  function permutation(str: string, prefix: string) {
    if (str.length === 0) {
      console.log(prefix);
    } else {
      for (let i = 0; i < str.length; i++) {
        const rem = str.substring(0, i) + str.substring(i + 1);
        permutation(rem, prefix + str.charAt(i));
      }
    }
  }
  ```

- 답: O(n^2 * n!)
  - 순열이 완성되는 시점에 permutation 함수가 호출되는 횟수 = n!
  - 순열이 완성되기 전까지 permutation 함수가 호출되는 횟수 = n * n! 미만
    - 말단 노드의 수는 n!개, 트리의 높이는 n이므로, 말단 노드의 수는 n * n! 미만이다.
  - 각 함수 호출을 처리하는 데에 걸리는 시간 = O(n)
  - 총 수행시간 = O(n * n!) = O(n^2 * n!)

예제 13.

  ```ts
  function fib(n: number): number {
    return fib(n-1) + fib(n-2);
  }
  ```

- 답: O(2^n), O(1.6^n)
  - 재귀호출 패턴(O(분기 ^ 깊이))을 사용하면, O(2^n)이 된다.
  - 그러나 일부 말단이 단말 노드이므로 O(1.6^n)이 된다.

예제 14.

  ```ts
  function allFib(n: number) {
    for (let i = 0; i < n; i++) {
      console.log(i + ': ' + fib(i));
    }
  }

  function fib(n: number): number {
    if (n <= 0) return 0;
    else if (n === 1) return 1;
    return fib(n-1) + fib(n-2);
  }
  ```

- 오답: O(n * 2^n)
  - fib 함수의 호출 횟수는 O(2^n)이다.
  - 그러나 각 호출은 O(n)의 시간이 소요된다.
  - 따라서 총 수행시간은 O(n * 2^n)이 될 것이다.
    => n이 매 호출마다 변화되는 점을 무시한 결과
- 답: O(2^n)
  - fib(1) -> 2^1번 호출
  - fib(2) -> 2^2번 호출
  - fib(3) -> 2^3번 호출
  - ...
  - 합계는 2^1 + 2^2 + 2^3 + ... + 2^n = 2^(n+1)
  - 따라서 총 수행시간은 O(2^n)이 된다.

예제 15.

  ```ts
  function allFib(n: number) {
    const memo = new Array(n + 1).fill(-1);
    for (let i = 0; i < n; i++) {
      console.log(i + ': ' + fib(i, memo));
    }
  }

  function fib(n: number, memo: number[]): number {
    if (n <= 0) return 0;
    else if (n === 1) return 1;
    else if (memo[n] > 0) return memo[n];
    memo[n] = fib(n-1, memo) + fib(n-2, memo);
    return memo[n];
  }
  ```

- 답: O(n)
  - fib 함수의 호출 횟수는 O(n)이다.
  - 각 호출은 memo에서 값을 가져와 더하는, 상수 시간이 소요되는 연산을 수행한다.
  - 따라서 총 수행시간은 O(n)이 된다.

예제 16.

  ```ts
  function powersOf2(n: number): number {
    if (n < 1) {
      return 0;
    } else if (n === 1) {
      console.log(1);
      return 1;
    } else {
      const prev = powersOf2(Math.floor(n / 2));
      const curr = prev * 2;
      console.log(curr);
      return curr;
    }
  }
  ```

- 답: O(log n)
  - powersOf2 함수의 호출 횟수는 O(log n)이다.
  - 각 호출은 상수 시간이 소요되는 연산을 수행한다.
  - 따라서 총 수행시간은 O(log n)이 된다.

## Chapter 07. 기술적 문제

### 준비하기

1. 직접 풀도록 노력하라.
2. 코드를 종이에 적으라: 문법 강조, 자동완성이 없는 환경에 익숙해져야 한다.
3. 코드를 테스트하라: 종이 위에서도 코드를 테스트해야 한다.
4. 종이에 적은 코드를 그대로 컴퓨터로 옮긴 뒤 실제로 실행 해 보라.

### 알고 있어야 할 것들

- 핵심 자료구조, 알고리즘, 기본 개념
  - 자료구조
    - 연결 리스트
    - 트리, 트라이, 그래프
    - 스택, 큐
    - 힙
    - 벡터, 배열 리스트
    - 해시테이블
  - 알고리즘
    - 너비 우선 탐색(BFS)
    - 깊이 우선 탐색(DFS)
    - 이진 탐색
    - 병합 정렬
    - 퀵 정렬
  - 개념
    - 비트 조작
    - 메모리(스택 vs 힙)
    - 재귀
    - 동적 프로그래밍(Dynamic Programming)
    - Big-O 시간, 공간
- 위 개념들을 종이에 구현하고, 그것을 컴퓨터로 옮겨서 테스트 해 보는 것이 좋다.
- 2의 승수 표
  |X|2^X|근사치|메모리 요구량
  |---|---|---|---|
  |7|128|-|-|
  |8|256|-|-|
  |9|512|-|-|
  |10|1,024|1000|1KB|
  |16|65,536|-|64KB|
  |20|1,048,576|100만|1MB|
  |30|1,073,741,824|10억|1GB|
  |32|4,294,967,296|-|4GB|
  |40|1,099,511,627,776|1조|1TB|

### 실제 문제 살펴보기

- 원하는 것이 무엇인가?
  ![Alt text](images/image04.png)
  - 듣기: 문제와 관련된 모든 정보를 집중해서 잘 듣자.
    - 단순히 정확히 이해해라의 수준이 아닌, 정확히 이해했는지를 확인해야 한다.
    - 또한 불확실한 부분이 있다면, 질문을 통해 명확히 해야 한다. 
  - 예제: 주어진 예제 이외에도 직접 다른 예제를 찾아보고, 적용해라.
    - 명확한 예제를 쓰고
    - 충분히 큰 예제를 쓰고
    - 특별한 예제를 지양하자.
  - 무식하게 풀기: 문제를 풀기 위해 가장 단순한 방법을 사용해라. 가장 빠르고 단순하게 시도한 뒤 최적화를 시도하라. 아직 코딩하기엔 이르다.
    - 브루트 포스가 우아하지 않다고 해서 언급조차 하지 않는것은 옳지 않다. 당신의 사고과정을 면접관과 공유해라.
    - 시간, 공간 복잡도를 설명하며, 알고리즘을 개선해 나가면 더 좋다.
  - 최적화: BUD 최적화를 통해 풀이를 개선하거나 아래와 같은 방법을 시도해라.
    - 간과한 부분이 있는지 생각 해 본다.
    - 예제를 손으로 풀어 본 뒤, 사고 과정을 되짚어보라.
    - 잘못된 방법으로 풀어 본 뒤, 왜 틀렸는지 알아보라.
    - 시간과 공간의 비용-이익 관계를 고려하라: 해시테이블의 사용여부 등 고려
  - 검토하기: 최적의 해법을 찾은 것 같다면, 다시 한 번 천천히 재검토하라.
    - 코딩은 나중에 하자.
    - 정확히 무엇을 구해야 하는 지 모른 채 코딩을 시작하면 시간이 더 오래걸릴 뿐더러, 심각한 실수를 더 많이 할 수 있다.
  - 구현하기: 시작부터 코드를 모듈화 시키고, 아름답게 만들어라.
  - 테스트
    1. 개념적 테스트: 코드리뷰를 하듯, 자세하게 코드를 검토하라.
    2. 특이하거나 표준적이지 않은 코드를 주의하라.
    3. 산술연산, 혹은 null 등 과 같은 특수한 경우를 주의하라.
    4. 작은 크기의 테스트를 진행해라.
    5. 특이하거나 극단적인 입력을 테스트해라.

### 최적화 및 문제풀이 기술 #1: BUD를 찾으라

- BDU
  - Bottlenecks(병목): 시간과 공간의 병목을 찾아라.
  - Unnecessary work(불필요한 작업): 불필요한 작업을 제거하라.
  - Duplicated work(중복 작업): 같은 작업을 반복하지 말라.

### 최적화 및 문제풀이 기술 #2: 스스로 풀어보라 DIY(Do It Yourself)

- 알고리즘을 배우지 않았더라도 사람들은 대개 문제를 푸는 방법을 알고있다.
- 따라서 스스로, 손으로 문제를 풀어보아라.

### 최적화 및 문제풀이 기술 #3: 단순화, 일반화하라

1. 자료형과 같은 제약조건을 단순화하라.
2. 단순화된 버전의 문제를 풀고,
3. 이후 복잡한 버전으로 확장하라.

### 최적화 및 문제풀이 기술 #4: 초기 사례(base case)로부터 확장하기(build)

- 초기 사례(n=1)에 대한 문제를 풀고, 이를 바탕으로 n=2, n=3, ... 등으로 확장해 나가는 방법이다.
- 이러한 문제는 자연스럽게 재귀 알고리즘으로 구현되는 경우가 많다.

### 최적화 및 문제풀이 기술 #5: 자료구조 브레인스토밍

- 자료구조를 하나씩 훑어보며, 이것으로 문제를 풀 수 있는지 적용 해 본다.
  - 연결리스트?
  - 배열?
  - 이진 트리?
  - 힙?
  - ...

### 가능한 최선의 수행 시간(Best Conceivable Runtime(BCR))

- BCR: Best Conceivable Runtime
- 문제를 풀 수 있는 최선의 수행 시간을 구하고, 이를 목표로 하라.
- BCR과 최선의 수행 시간(Best Case Runtime)은 전혀 무관하다.
- BCR 사용법에 대한 예제
  - 문제: **정렬된 배열** 두 개가 주어졌을 때, 두 배열에 **공통으로 들어있는 원소의 개수**를 찾으라. **두 배열의 길이는 같**고, 하나의 배열 안에 **중복된 원소는 존재하지 않**는다.
  - 배열
    - A: 13, 27, **35**, **40**, 49, **55**, 59
    - B: 17, **35**, 39, **40**, **55**, 58, 60
  - 무식한 방법
    - 배열 A의 각 원소별로 배열 B 전체를 순회하며 비교한다.
    - 두 배열의 길이(n)가 같으므로 O(n^2)의 시간이 소요된다.
  - BCR: O(n), 최소한 하나의 배열의 모든 원소를 한번씩은 보아야 한다.
  - 최적화 가능한 시간 복잡도: O(n), O(n log n) 등
    - 다시 말 해, 첫번째 배열의 각 원소에 대한 탐색을 O(log n)이나 O(1)로 만들 수 있다면, 전체 시간복잡도는 O(n log n)이나 O(n)이 된다.
    - O(log n)으로 줄이는 방법: 이진 탐색 활용
    - O(1)로 줄이는 방법: 해시 테이블 사용
      - 차후 '정렬되어있다' 라는 조건을 사용하면, 해시 테이블 대신, 선형 검색을 통해서도 O(1)로 줄일 수 있다.
  - 결과적으로, 시간복잡도가 BCR인 O(n)에 도달하고, 공간복잡도가 O(1)이라면, 이 알고리즘은 더이상 최적화 할 수 없다고 말 할 수 있다.

### 오답에 대한 대처법

- 면접에서는 문제 풀이에 대해, '맞다', '틀리다'로만 판단하지 않는다.
- 판단의 기준
  - 최종 답안이 얼마나 근접했는지, 풀이의 방향이 정확한지
  - 힌트를 얼마나 필요로 했는지
  - 코드가 얼마나 깔끔하지

### 알고 있던 문제가 면접에 나왔을 때

- 이미 알고있는 문제가 나왔다면, 사실대로 말하는 것이 좋다.
  - 먼저 자신에 대한 평가가 올바르게 이루어지지 않을 것이고,
  - 아는 문제임을 밝히지 않은 것이 밝혀진다면, 면접관에게 신뢰를 잃을 수 있다.

### 면접용으로 '완벽한' 언어

- 면접에서는 자신이 편한 언어를 사용하라. 다만, 아래의 조건을 갖춘다면 더욱 좋다
  - 널리 사용되는 언어: 면접관도 읽을 수 있어야 한다.
  - 언어 가독성: 면접관이 정확히 이해 할 수 없더라도, 코드를 읽을 수 있어야 한다.
  - 언어에서 발생하는 잠재적인 문제점: C++등을 사용하면, 일반적인 버그 뿐 아닌 메모리 관리와 포인터 등 알고리즘 외적인 부분도 신경써야 한다.
  - 언어가 얼마나 장황한지: 코드가 길어지면, 제한된 시간 내에 개발자가 코드를 작성하는데에 부담이 커진다.
  - 사용하기 쉬운 언어: 언어 자체에 편리한 기능이 갖추어져 있다면 문제 풀이에 집중 할 수 있다.

### 어떤 코드가 좋아 보이나

- 회사는 '좋고 깔끔한' 코드를 작성하는 개발자를 좋아한다.
- '좋고 깔끔한' 코드란?
  - 정확도: 모든 입력에 대해 코드는 예측한 결과를 내놓아야 한다.
  - 효율성: 시간, 공간 두가지 측면에서 효율성이 좋아야 한다.
  - 간략화: 동일한 기능을 100줄에서 10줄로 줄일 수 있다면, 줄여야 한다.
  - 가독성: 다른 개발자들도 코드를 쉽게 읽을 수 있어야 한다.
  - 관리 가능성: 본인 뿐 아닌 다른 사람들도 코드를 쉽게 관리할 수 있어야 한다.
- 적절히 자료구조를 사용한 코드가 좋아 보인다.
  - 자료구조를 사용하면, 코드가 간결해지고, 가독성이 좋아진다.
  - 예시: Ax^a + Bx^b + ... 와 같은 다항식을 표현한다면
    - 나쁜 구현 형태
      - 하나의 배열을 사용한 형태

        ```ts
        // 2x^3
        const arr = [0, 0, 0, 2];
        // 2x^5 + 5x^2
        const arr = [0, 0, 5, 0, 0, 2];
        // x^1000
        const arr = [0, 0, 0, ..., 0, 1];
        ```

      - 자연수가 아닌 지수를 표현 할 수 없다.
      - 지수의 크기가 커지면 공간의 낭비가 심하다.

    - 그나마 나은 구현 형태
      - 두 개의 배열을 사용한 형태

        ```ts
        // 3x^3
        const arr = [3];
        const exp = [3];
        // 2x^5 + 5x^2
        const arr = [2, 5];
        const exp = [5, 2];
        // x^1000
        const arr = [1];
        const exp = [1000];
        ```

      - 지수를 표현할 수 있으나, 여전히 공간의 낭비가 심하다.
      - 두 개의 배열을 동시에 관리해야 하므로, 코드가 복잡해진다.

    - 좋은 구현 형태

      ```ts
      class ExprTerm {
        coefficient: number;
        exponent: number;
      }
      // 3x^3
      const arr = [new ExprTerm(3, 3)];
      // 2x^5 + 5x^2
      const arr = [new ExprTerm(2, 5), new ExprTerm(5, 2)];
      // x^1000
      const arr = [new ExprTerm(1, 1000)];
      ```

      - 지수를 표현할 수 있고, 공간의 낭비가 없다.

    - 적절한 코드의 재사용
      - 문자열로 전달된 이진수와 문자열로 전달된 16진수의 값이 같은지 검사하는 함수를 작성한다고 가정하자.

        ```ts
        function convertFromBase(number: string, base: number): number {
          if (base < 2 || (base > 10 && base !== 16)) return -1;
          let value = 0;
          for (let i = number.length - 1; i >= 0; i--) {
            const digit = digitToValue(number.charAt(i));
            if (digit < 0 || digit >= base) {
              return -1;
            }
            const exp = number.length - 1 - i;
            value += digit * Math.pow(base, exp);
          }
          return value;
        }

        function compareBinToHex(binary: string, hex: string): boolean {
          const n1 = convertFromBase(binary, 2);
          const n2 = convertFromBase(hex, 16);
          if (n1 < 0 || n2 < 0) {
            return false;
          }
          return n1 === n2;
        }
        ```

    - 모듈화
      - 모듈화 된 코드를 작성한다는 것은, 관계없는 코드들을 별도 메소드로 나눈다는 것임.
      - 유지보수, 가독성을 높일 수 있음.
      - 개선 전 코드

        ```ts
        function swapMinMax(array: number[]) {
          let minIdx = 0;
          for (let i = 1; i < array.length; i++) {
            if (array[i] < array[minIdx]) {
              minIdx = i;
            }
          }
          let maxIdx = 0;
          for (let i = 1; i < array.length; i++) {
            if (array[i] > array[maxIdx]) {
              maxIdx = i;
            }
          }

          const tmp = array[minIdx];
          array[minIdx] = array[maxIdx];
          array[maxIdx] = tmp;
        }
        ```

      - 개선 후 코드

        ```ts
        function swapMinMax(array: number[]) {
          const minIdx = getMinIdx(array);
          const maxIdx = getMaxIdx(array);
          swap(array, minIdx, maxIdx);
        }

        function getMinIdx(array: number[]): number { ... }
        function getMaxIdx(array: number[]): number { ... }
        function swap(array: number[], idx1: number, idx2: number) { ... }
        ```

    - 유연하고 튼튼한 코드
      - 가능한 한, 특정 값을 직접 대입하지 않고, 최대한 일반화된 코드를 작성하라.
      - 다만 너무 복잡해지거나, 당장 그럴 필요가 없어 보인다면, 일단은 단순한 코드를 작성하라.

    - 오류 검사
      - 간단한 if문 등으로 예외를 처리하라.
      - 당장 추가 할 수가 없다면, 공간을 남겨두고 이후에 추가하겠다는 의사를 꼭 밝혀라.

### 포기하지 말라

- 까다로운 문제라고 바로 포기하지 마라.
- 포기 할 수 있는 상황에 어떻게 대처하는지도 평가가 될 수 있다.

## Chapter 08. 합격한 뒤에

### 합격 또는 거절 통지에 대처하는 요령

- 입사 결정 기한과 연장
  - 다른 회사의 면접 결과도 기다려보고 싶다면, 기한 연장을 요청해보자.
- 입사 제안 거절
  - 거절의 이유를 공격적이지 않게, 명확하게 밝혀라
- 탈락 통보 대처
  - 대다수 회사들이 자신들의 면접 방식이 완벽하지 않다는 점을 알고있다.
  - 탈락의 이유를 물어보고, 그것을 개선해 나가자.
  - 또한 이를 재지원의 기회로 만드는 것도 좋다.

### 입사 제안 평가

- 재정 관련 사항
  - 단순 연봉에 연연하지 말고, 다른 요소들도 고려해보자.
    - 사이닝 보너스, 이직 보너스 등
    - 생활비용의 차이
    - 연간 보너스
    - 스톡옵션과 증여 등
    - 그 외 기타 성장가능성과 경력발전사항 등
- 경력 개발
  - 몇 가지 고려사항
    - 이 회사의 이름이 내 이력서를 얼마나 더 보기좋게 만들어 주는가?
    - 얼마나 많이 배우게 될 것인가? 다른 분야도 배울 수 있는가?
    - 승진 계획은 어떤가? 개발자로서의 성장을 어떻게 돕는 회사인가?
    - 관리직으로 옮기고자 할 경우 회사에서 현실적인 도움을 줄 수 있는가?
    - 회사나 팀의 규모가 확대되고 있는가?
    - 회사를 떠나고 싶을 경우, 비슷한 지역에 다른 회사가 있는가?
- 회사의 안정성
  - 회사는 일반적으로, 안정적인 경우 성장이 느리다.
  - 개인의 가치관에 따라 선택이 달라진다.
- 행복의 척도
  - 제품: 내가 어떤 제품을 만들게 될 것인가?
  - 관리자와 동료: 내가 어떤 사람들과 일하게 될 것인가? 그들과 일하는 것이 즐거울 것인가?
  - 회사 문화: 회사의 문화는 어떤가? 내가 원하는 문화인가?
  - 근무 시간: 일하는 시간은 어떤가? 일하는 시간이 길어질 경우, 그에 대한 보상은 어떤가?

### 연봉 협상

- 밑져야 본전이다. 그냥 해 보아라.
- 실질적인 대안을 갖추어라: 다른 회사의 제안을 받았다면, 그것을 이용해라.
- 구체적으로 요구해라: 막연히 더 많은 연봉을 요구하는 것보다, 구체적인 수치를 제시하는 것이 더 효과적이다.
- 많이 불러라: 협상은 주고받는 과정이다. 조정이 필요하다면, 그것을 요구해라.
- 연봉 이외의 것도 고려해라: 연봉 이외에도, 다른 요소들을 고려해보자.
  - 사이닝 보너스
  - 이직 보너스
  - 연간 보너스
  - 스톡옵션과 증여 등
- 가장 좋은 협상 매체를 고르라
  - 전화통화가 어렵다면, 이메일을 통해도 좋다.

### 입사 후

- 일정 수립
  - 단기가 아닌, 장기간에 걸친 커리어의 발전을 고려하라: 5년, 10년 뒤에는 어떤 일을 하겠는가?
- 튼튼한 관계 수립
  - 다른 직원이 퇴사해도, 그 직원들과의 관계를 계속 유지하라.
- 원하는 것을 요구하라
  - 자신이 원하는 것을 관리자에게 솔직히 표현하라.
- 꾸준히 면접을 보라
  - 적극적인 이직 의사가 없더라고 적어도 일년에 한 번은 면접을 보는 것이 좋다.
  - 이를 통해 자신의 가치를 알 수 있고, 최신 면접 동햐을 알 수 있다.

## Chapter 09. 면접 문제

- 자료구조
  1. 배열과 문자열
  2. 연결 리스트
  3. 스택과 큐
  4. 트리와 그래프

### 1. 배열과 문자열

#### 해시 테이블

- 해시 테이블에 키와 값을 저장하는 과정
  1. 해시 코드 계산
  2. 해시 코드를 인덱스로 변환
  3. 해당 인덱스에 존재하는 연결 리스트에 키와 값을 저장
      - 여기서는 충돌을 해결하기 위해 연결 리스트를 사용한다.
      - 이 경우 최악의 시나리오에서 수행 시간은 O(n)이 된다. 하지만 해시가 잘 구현되어있다면, O(1)이 된다.
      - 혹은 이진 트리를 사용할 수도 있다.

#### ArrayList와 가변 크기 배열

- ArrayList는 내부적으로 배열을 사용한다.
- ArrayList의 크기를 늘리는 방법
  1. 새로운 배열을 생성한다.
  2. 기존의 배열을 새로운 배열로 복사한다.
  3. 새로운 배열에 새로운 항목을 추가한다.
- 이러한 ArrayList는 최악의 경우 O(n)의 시간이 소요된다.
  - 하지만 이런 경우는 드물기에, 상환시간을 고려했을 때 O(1)이라고 할 수 있다.

#### StringBuilder

- 길이가 x인 n개의 문자열이 주어진다고 했을 때, 이를 모두 하나로 연결하려면 수행시간은 O(xn^2)이 된다.
- 그러나 StringBuilder를 사용하면, O(xn)의 수행시간으로 해결할 수 있다.
  - StringBuilder는 내부적으로 가변 크기 배열을 사용한다.

#### 면접 문제

1.1 중복이 없는가

- 나의 풀이

  ```ts
  function hasUniqueChar(str: string): boolean {
    const set = new Set();
    for (let i = 0; i < str.length; i++) {
      if (set.has(str[i])) {
        return false;
      } else {
        set.add(str[i]);
      }
    }
    return true;
  }
  ```

- 도서의 풀이 1

  ```ts
  function isUniqueChar(str: string): boolean {
    if (str.length > 128) return false;
    const set = new Set();
    for (let i = 0; i < str.length; i++) {
      const val = str[i];
      if (set.has(val)) {
        return false;
      }
      set.add(val);
    }
    return true;
  }
  ```

- 도서의 풀이 2

  ```ts
  function isUniqueChar(str: string): boolean {
    let checker = 0;
    for (let i = 0; i < str.length; i++) {
      const val = str[i];
      const bit = val.charCodeAt(0) - 'a'.charCodeAt(0); // 0 ~ 25
      if ((checker & (1 << bit)) > 0) {
        return false;
      }
      checker |= 1 << bit; // 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, ...
    }
    return true;
  }
  ```

1.2 순열 확인

- 내 풀이

  ```ts
  function isPermutation(str1: string, str2: string): boolean {
    if (str1.length !== str2.length) return false;
    const map = new Map();
    for (let i = 0; i < str1.length; i++) {
      const char = str1[i];
      if (map.has(char)) {
        map.set(char, map.get(char) + 1);
      } else {
        map.set(char, 1);
      }
    }
    for (let i = 0; i < str2.length; i++) {
      const char = str2[i];
      if (map.has(char)) {
        map.set(char, map.get(char) - 1);
        if (map.get(char) < 0) {
          return false;
        }
      } else {
        return false;
      }
    }
  }
  ```

- 도서의 풀이 1. 정렬

  ```ts
  function sort(str: string): string {
    const arr = str.split('');
    arr.sort();
    return arr.join('');
  }

  function permutation(s: string, t: string): boolean {
    if (s.length !== t.length) return false;
    return sort(s) === sort(t);
  }
  ```

- 도서의 풀이 2. 출현횟수 확인

  ```ts
  function permutation(s: string, t: string): boolean {
    if (s.length !== t.length) return false;

    const letters = new Array(128).fill(0); // ASCII로 가정

    for (let i = 0; i < s.length; i++) {
      letters[s.charCodeAt(i)]++;
    }
    for (let i = 0; i < t.length; i++) {
      letters[t.charCodeAt(i)]--;
      if (letters[t.charCodeAt(i)] < 0) {
        return false;
      }
    }
    return true;
  }
  ```

1.3 URL화

- 내 풀이

  ```ts
  function urlize(str: string): string {
    return str.replace(/\s/g, '%20');
  }
  ```

  ```ts
  function urlize(str: string): string {
    const arr = str.split('');
    for (let i = 0; i < arr.length; i++) {
      if (arr[i] === ' ') {
        arr[i] = '%20';
      }
    }
    return arr.join('');
  }
  ```

- 도서의 풀이

  ```ts
  function replaceSpaces(str: string, trueLength: number): string {
    const arr = str.split('');

    // 최종 문자열의 길이를 계산한다.
    let spaceCount = 0;
    for (let i = 0; i < trueLength; i++) {
      if (arr[i] === ' ') {
        spaceCount++;
      }
    }
    let index = trueLength + spaceCount * 2;
    if (trueLength < str.length) {
      arr[trueLength] = '\0'; // 배열의 끝
    }

    // 문자열을 뒤에서부터 확인하며, 공백이면 %20으로 대체한다.
    for (let i = trueLength - 1; i >= 0; i--) {
      if (arr[i] === ' ') {
        arr[index - 1] = '0';
        arr[index - 2] = '2';
        arr[index - 3] = '%';
        index -= 3;
      } else {
        arr[index - 1] = arr[i];
        index--;
      }
    }
    return arr.join('');
  }
  ```

1.4 회문 순열

- 내 풀이

  ```ts
  function isPalindrome(str: string): boolean {
    const s = str.replace(/\s/g, '');
    const half = Math.floor(s.length / 2);
    for (let i = 0; i < half; i++) {
      if (s[i] !== s[s.length - 1 - i]) {
        return false;
      }
    }
    return true;
  }
  ```

- 도서의 풀이 1

  ```ts
  function isPermutationOfPalindrome(phrase: string): boolean {
    const table = buildCharFrequencyTable(phrase);
    return checkMaxOneOdd(table);
  }

  function checkMaxOneOdd(table: number[]): boolean {
    let foundOdd = false;
    for (let count of table) {
      if (count % 2 === 1) {
        if (foundOdd) {
          return false;
        }
        foundOdd = true;
      }
    }
    return true;
  }

  function buildCharFrequencyTable(phrase: string): number[] {
    const table = new Array<number>(getCharNumber('z') - getCharNumber('a') + 1).fill(0);
    for (let c of phrase) {
      const x = getCharNumber(c);
      if (x !== -1) {
        table[x]++;
      }
    }
    return table;
  }

  function getCharNumber(c: string): number {
    const a = 'a'.charCodeAt(0);
    const z = 'z'.charCodeAt(0);
    const val = c.charCodeAt(0);
    if (a <= val && val <= z) {
      return val - a;
    }
    return -1;
  }
  ```

- 도서의 풀이 2

  ```ts
  function isPermutationOfPalindrome(phrase: string): boolean {
    let countOdd = 0;
    const table = new Array<number>(getCharNumber('z') - getCharNumber('a') + 1).fill(0);
    for (const c of phrase) {
      const x = getCharNumber(c);
      if (x !== -1) {
        table[x]++;
        if (table[x] % 2 === 1) {
          countOdd++;
        } else {
          countOdd--;
        }
      }
    }
    return countOdd <= 1;
  }

  function getCharNumber(c: string): number {
    const a = 'a'.charCodeAt(0);
    const z = 'z'.charCodeAt(0);
    const val = c.charCodeAt(0);
    if (a <= val && val <= z) {
      return val - a;
    }
    return -1;
  }
  ```

  - 도서의 풀이 1과 2의 차이점
    - 도서의 풀이 1은 문자열을 두 번 순회한다.
    - 도서의 풀이 2는 문자열을 한 번 순회한다.
    - 그러나 도서의 풀이 2가 더 최적화 된 형태라고 하기는 어렵다.

- 도서의 풀이 3

  ```ts
  function isPermutationOfPalindrome(phrase: string): boolean {
    const bitVector = createBitVector(phrase);
    return bitVector === 0 || checkExactlyOneBitSet(bitVector);
  }

  function createBitVector(phrase: string): number {
    let bitVector = 0;
    const arr = phrase.split('');
    for (const c of arr) {
      const x = getCharNumber(c);
      bitVector = toggle(bitVector, x);
    }
    return bitVector;
  }

  function toggle(bitVector: number, index: number): number {
    if (index < 0) return bitVector;
    const mask = 1 << index;
    if ((bitVector & mask) === 0) { // 해당 비트가 0이면
      bitVector |= mask; // 비트를 1로 바꾼다.
    } else { // 해당 비트가 1이면
      bitVector &= ~mask; // 비트를 0으로 바꾼다.
    }
    return bitVector;
  }

  function getCharNumber(c: string): number {
    const a = 'a'.charCodeAt(0);
    const z = 'z'.charCodeAt(0);
    const val = c.charCodeAt(0);
    if (a <= val && val <= z) {
      return val - a;
    }
    return -1;
  }

  function checkExactlyOneBitSet(bitVector: number): boolean {
    return (bitVector & (bitVector - 1)) === 0; // 1을 뺀 값과 AND 연산을 했을 때 0이면 1이 하나만 있다는 뜻이다.
  }
  ```

1.5 하나 빼기

- 내 풀이

  ```ts
  function isOneEdit(str1: string, str2: string): boolean {
    if (Math.abs(str1.length - str2.length) > 1) return false;

    if (str1.length === str2.length) {
      let diff = 0;
      for (let i = 0; i < str1.length; i++) {
        if (str1[i] !== str2[i]) diff++;
        if (diff > 1) return false;
      }
      return true;
    }

    const long = str1.length > str2.length ? str1 : str2;
    const short = str1.length > str2.length ? str2 : str1;

    let diff = 0;
    for (let i = 0; i < short.length; i++) {
      if (long[i + diff] !== short[i]) {
        diff++;
        i--;
      }
      if (diff > 1) return false;
    }
    return true;
  }
  ```

- 도서의 풀이

  ```ts
  function oneEditAway(first: string, second: string): boolean {
    if (first.length === second.length){
      return oneEditReplace(first, second);
    } else if (first.length + 1 === second.length){
      return oneEditInsert(first, second);
    } else if (first.length - 1 === second.length){
      return oneEditInsert(second, first);
    }
    return false;
  }

  function oneEditReplace(s1: string, s2: string): boolean {
    let foundDifference = false;
    for (let i = 0; i < s1.length; i++) {
      if (s1.charAt(i) !== s2.charAt(i)) {
        if (foundDifference) {
          return false;
        }
        foundDifference = true;
      }
    }
    return true;
  }

  function oneEditInsert(short: string, long: string): boolean {
    let shortIdx = 0;
    let longIdx = 0;
    while (longIdx < long.length && shortIdx < short.length) {
      if (short.charAt(shortIdx) !== long.charAt(longIdx)) { // 두 철자가 다른 경우
        if (shortIdx !== longIdx) { // 철자가 다른 경우가 두 번째 이상인 경우
          return false;
        }
        longIdx++; // 철자가 다른 경우가 처음인 경우
      } else { // 두 철자가 같은 경우
        shortIdx++;
        longIdx++;
      }
    } 
    return true;
  }
  ```

- 도서의 풀이(간략화)

  ```ts
  function oneEditAway(first: string, second: string): boolean {
    if (Math.abs(first.length - second.length) > 1) {
      return false;
    }

    const longer = first.length > second.length ? first : second;
    const shorter = first.length > second.length ? second : first;

    let longerIndex = 0;
    let shorterIndex = 0;

    let foundDifference = false;
    while (shorterIndex < shorter.length && longerIndex < longer.length) {
      if (shorter[shorterIndex] !== longer[longerIndex]) { // 두 문자가 다를 때
        if (foundDifference) return false; // 이미 다른 문자가 있었다면 false
        foundDifference = true; // 첫번째 다른 문자를 찾았다고 표시
        if (shorter.length === longer.length) { // 문자열 길이가 같을 때
          shorterIndex++; // 다음 문자로 넘어감
        }
      } else { // 두 문자가 같을 때
        shorterIndex++; // 다음 문자로 넘어감
      }
      longerIndex++; // 다음 문자로 넘어감
    }
    return true;
  }
  ```

  - 위의 코드에서 oneEditReplace와 oneEditInsert를 합쳐서 작성한 코드이다.
  - 내 생각에는, 합쳐진 코드보다는 일부 코드가 중복되더라도 분리된 코드가 더 가독성이 좋다고 생각함.

1.6 문자열 압축

- 내 풀이

  ```ts
  function compress(str: string): string {
    let result = '';
    let count = 0;
    for (let i = 0; i < str.length; i++) {
      count++;
      if (str[i] !== str[i + 1]) {
        result += str[i] + count;
        count = 0;
      }
    }
    return result.length < str.length ? result : str;
  }
  ```

- 도서의 풀이 1

  ```ts
  function compressBad(str: string): string {
    let compressedString = '';
    let countConsecutive = 0;
    for (let i = 0; i < str.length; i++) {
      countConsecutive++;
      if (i + 1 >= str.length || str.charAt(i) !== str.charAt(i + 1)) {
        compressedString += str.charAt(i) + countConsecutive;
        countConsecutive = 0;
      }
    }
    return compressedString.length < str.length ? compressedString : str;
  }
  ```

- 도서의 풀이 2

  ```ts
  function compress(str: string): string {
    const finalLength = countCompression(str);
    if (finalLength >= str.length) return str;

    let compressed = '';
    let countConsecutive = 0;
    for (let i = 0; i < str.length; i++) {
      countConsecutive++;
      if (i + 1 >= str.length || str.charAt(i) !== str.charAt(i + 1)) {
        compressed += str.charAt(i) + countConsecutive;
        countConsecutive = 0;
      }
    }
    return compressed;
  }

  function countCompression(str: string): number {
    let compressedLength = 0;
    let countConsecutive = 0;
    for (let i = 0; i < str.length; i++) {
      countConsecutive++;
      if (i + 1 >= str.length || str.charAt(i) !== str.charAt(i + 1)) {
        compressedLength += 1 + countConsecutive.toString().length;
        countConsecutive = 0;
      }
    }
    return compressedLength;
  }
  ```

1.7 행렬 회전

- 내 풀이

  ```ts
  function rotate90(matrix: number[][]): number[][] {
    const n = matrix.length;
    const result = new Array(n).fill(0).map(() => new Array(n).fill(0));

    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        result[j][n - 1 - i] = matrix[i][j];
      }
    }

    return result;
  }
  ```

- 도서의 풀이

  ```ts
  function rotate(matrix: number[][]): number[][] {
    if (matrix.length === 0 || matrix.length !== matrix[0].length) return matrix;
    const n = matrix.length;
    for (let layer = 0; layer < n / 2; layer++) {
      const first = layer;
      const last = n - 1 - layer;
      for (let i = first; i < last; i++) {
        const offset = i - first;
        const top = matrix[first][i];
        // left -> top
        matrix[first][i] = matrix[last - offset][first];
        // bottom -> left
        matrix[last - offset][first] = matrix[last][last - offset];
        // right -> bottom
        matrix[last][last - offset] = matrix[i][last];
        // top -> right
        matrix[i][last] = top;
      }
    }
    return matrix;
  }
  ```

  - 도서의 풀이는, 행렬을 4개의 부분 행렬로 나누어서, 각 부분 행렬의 원소들을 서로 바꾸는 방식으로 행렬을 회전시킨다.
  - 시간 복잡도는 두 풀이 모두 O(n^2)이다. 그러나 n^2개의 원소를 모두 변경해야 하므로 최선의 결과이다.
  - 공간 복잡도는 내 풀이의 경우 O(n^2)이고, 도서의 풀이의 경우 O(1)이다.

1.8 0 행렬

- 내 풀이

  ```ts
  function makeZeroColRow(matrix: number[][]): number[][] {
    const m = matrix.length;
    const n = matrix[0].length;

    const zeroLocs: number[][] = [];
    for (let i = 0; i < matrix.length; i++) {
      const row = matrix[i];
      for (let j = 0; j < row.length; j++) {
        const col = row[j];
        if (col === 0) {
          zeroLocs.push([i, j]);
        }
      }
    }
    for (let i = 0; i < zeroLocs.length; i++) {
      const [row, col] = zeroLocs[i];
      for (let j = 0; j < m; j++) {
        matrix[j][col] = 0;
      }
      for (let j = 0; j < n; j++) {
        matrix[row][j] = 0;
      }
    }
    return matrix;
  }
  ```

- 도서의 풀이 1

  ```ts
  function setZeros(matrix: number[][]): number[][] {
    let row: boolean[] = new Array(matrix.length).fill(false);
    let col: boolean[] = new Array(matrix[0].length).fill(false);

    for (let i = 0; i < matrix.length; i++) {
      for (let j = 0; j < matrix[0].length; j++){
        if (matrix[i][j] === 0) {
          row[i] = true;
          col[j] = true;
        }
      }
    }

    for (let i = 0; i < row.length; i++) {
      if (row[i]) {
        nullifyRow(matrix, i);
      }
    }

    for (let j = 0; j < col.length; j++) {
      if (col[j]) {
        nullifyCol(matrix, j);
      }
    }

    return matrix;
  }

  function nullifyRow(matrix: number[][], row: number) {
    for (let j = 0; j < matrix[0].length; j++) {
      matrix[row][j] = 0;
    }
  }

  function nullifyCol(matrix: number[][], col: number) {
    for (let i = 0; i < matrix.length; i++) {
      matrix[i][col] = 0;
    }
  }
  ```

- 도서의 풀이 2

  ```ts
  function setZeros(matrix: number[][]): number[][] {
    let rowHasZero = false;
    let colHasZero = false;

    // 첫번째 행에 0이 있는지 확인
    for (let j = 0; j < matrix[0].length; j++) {
      if (matrix[0][j] === 0) {
        rowHasZero = true;
        break;
      }
    }

    // 첫번째 열에 0이 있는지 확인
    for (let i = 0; i < matrix.length; i++) {
      if (matrix[i][0] === 0) {
        colHasZero = true;
        break;
      }
    }

    // 나머지 행렬에 0이 있는지 확인
    for (let i = 1; i < matrix.length; i++) {
      for (let j = 1; j < matrix[0].length; j++) {
        if (matrix[i][j] === 0) {
          matrix[i][0] = 0; // 첫번째 열에 0을 표시
          matrix[0][j] = 0; // 첫번째 행에 0을 표시
        }
      }
    }

    // 첫번째 행을 기준으로 행을 0으로 바꿈
    for (let i = 1; i < matrix.length; i++) {
      if (matrix[i][0] === 0) {
        nullifyRow(matrix, i);
      }
    }

    // 첫번째 열을 기준으로 열을 0으로 바꿈
    for (let j = 1; j < matrix[0].length; j++) {
      if (matrix[0][j] === 0) {
        nullifyCol(matrix, j);
      }
    }

    // 첫번째 행을 0으로 바꿈
    if (rowHasZero) {
      nullifyRow(matrix, 0);
    }

    // 첫번째 열을 0으로 바꿈
    if (colHasZero) {
      nullifyCol(matrix, 0);
    }

    return matrix;
  }

  function nullifyRow(matrix: number[][], row: number) {
    for (let j = 0; j < matrix[0].length; j++) {
      matrix[row][j] = 0;
    }
  }

  function nullifyCol(matrix: number[][], col: number) {
    for (let i = 0; i < matrix.length; i++) {
      matrix[i][col] = 0;
    }
  }
  ```

1.9 문자열 회전

- 내 풀이

  ```ts
  function isSubstring(str: string, subStr: string): boolean {
    return str.includes(subStr);
  }

  function isRotated(str1: string, str2: string): boolean {
    return isSubstring(str1 + str1, str2);
  }
  ```

- 도서의 풀이

  ```ts
  function isRotation(s1: string, s2: string): boolean {
    const len = s1.length;
    if (len === s2.length && len > 0) {
      const s1s1 = s1 + s1;
      return isSubstring(s1s1, s2);
    }
    return false;
  }

  function isSubstring(s1: string, s2: string): boolean {
    return s1.includes(s2);
  }
  ```

### 2. 연결리스트

![Alt text](images/image05.png)

- 배열과 달리 연결 리스트에서는 특정 인덱스를 상수 시간에 접근 할 수 없다.
- 다만 중간에 노드를 삽입하거나 삭제하는 것은 상수시간에 가능하다.

#### 연결리스트 만들기

```ts
class Node {
  data: number;
  next: Node | null;

  constructor(data: number) {
    this.data = data;
    this.next = null;
  }

  appendToTail(data: number) {
    const end = new Node(data);
    let n: Node | null = this;
    while (n.next !== null) {
      n = n.next;
    }
    n.next = end;
  }
}
```

- 위의 코드에서는 head가 고정되어있음. 따라서 head가 변경되는 경우 문제가 발생 할 수 있음
- 개선된 코드: LinkedList 클래스 추가

  ```ts
  class Node {
    data: number;
    next: Node | null = null;

    constructor(data: number) {
      this.data = data;
    }
  }

  class LinkedList {
    head: Node | null = null;

    appendToTail(data: number) {
      const end = new Node(data);
      if (this.head === null) {
        this.head = end;
      } else {
        let n: Node | null = this.head;
        while (n.next !== null) {
          n = n.next;
        }
        n.next = end;
      }
    }
  }
  ```

#### 단방향 연결리스트에서 노드 삭제

- 삭제할 노드의 앞 노드를 찾아, 삭제할 노드의 다음 노드를 앞 노드의 다음 노드로 바꾸면 된다.
  - prev.next = n.next;
- 만약 삭제할 노드가 head라면, head를 다음 노드로 바꾸면 된다.
  - head = head.next;
- 양방향 리스트라면 뒤 노드의 이전 노드를 앞 노드의 이전 노드로 바꿔주어야 한다.
  - n.next.prev = n.prev;
- 이 때, 널 포인터 예외를 처리해주어야 하고,
- 필요시 메모리 해제를 해주어야 한다.
- 코드

  ```ts
  function deleteNode(head: Node, d: number): Node {
    let n: Node | null = head;

    if (n.data === d) { // 삭제할 노드가 head라면
      return head.next; // head를 다음 노드로 바꿈
    }

    while (n.next !== null) {
      if (n.next.data === d) {
        n.next = n.next.next; // 삭제할 노드의 다음 노드를 앞 노드의 다음 노드로 바꿈
        return head; // head는 그대로
      }
      n = n.next;
    }
    return head;
  }
  ```

#### Runner 기법

- 연결리스트 문제를 풀 때, 두 개의 포인터를 동시에 사용하는 기법

#### 재귀 문제

- 연결 리스트 관련 문제의 상당수는 재귀 호출에 의존함.
- 유의할 점은, 재귀 호출의 깊이만큼 시간복잡도가 증가한다는 점이다.

#### 면접 문제

2.1 중복 없애기

- 내 풀이

  ```ts
  class MyNode {
    data: number;
    next: MyNode | null = null;

    constructor(data: number) {
      this.data = data;
    }
  }

  function dropDuplicates(node: MyNode): MyNode {
    if (node === null || node.next === null) return node;

    let buffer = new Set<number>();
    let current = node;
    buffer.add(current.data);

    while (current.next !== null) {
      if (buffer.has(current.next.data)) {
        current.next = current.next.next;
      } else {
        buffer.add(current.next.data);
        current = current.next;
      }
    }
    return node;
  }
  ```

- 도서의 풀이 1

  ```ts
  function deleteDups(n: LinkedListNode | null) {
    let set = new Set();
    let previous: LinkedListNode | null = null;
    while (n !== null) {
      if (set.has(n.data)) {
        previous!.next = n.next;
      } else {
        set.add(n.data);
        previous = n;
      }
      n = n.next;
    }
  }
  ```

- 도서의 풀이 2

  ```ts
  function deleteDups(head: LinkedListNode | null) {
    let current = head;
    while (current !== null) {
      let runner = current;
      while (runner.next !== null) {
        if (runner.next.data === current.data) {
          runner.next = runner.next.next;
        } else {
          runner = runner.next;
        }
      }
      current = current.next;
    }
  }
  ```

  - 이 코드는 1번 코드와 달리 buffer를 사용하지 않지만, 시간 복잡도는 O(n^2)이다.

2.2 뒤에서 k번째 원소 구하기

- 내 풀이

  ```ts
  class MyNode {
    data: number;
    next: MyNode | null = null;

    constructor(data: number) {
      this.data = data;
    }
  }

  function kThFromBehind(node: MyNode | null, k: number): number {
    if (k < 0) return -1;
    let count = 0;
    let current = node;
    
    while (current !== null) {
      count++;
      current = current.next;
    }

    if (k > count) return -1;

    let target = count + 1 - k;
    current = node;
    while (target > 1) {
      current = current!.next;
      target--;
    }
    return current!.data;
  }
  ```

- 도서의 풀이 1

  ```ts
  function printKthToLast(head: LinkedListNode | null, k: number): number {
    if (head === null) {
      return 0;
    }

    const index = printKthToLast(head.next, k) + 1;
    if (index === k) {
      console.log(head.data);
    }
    return index;
  }
  ```

  - 단순히 뒤에서 k번째 값을 콘솔에 출력하는 방법임.

- 도서의 풀이 2(생략)

- 도서의 풀이 3

  ```ts
  class LinkedListNode {
    data: number;
    next: LinkedListNode | null = null;
    constructor(data: number) {
      this.data = data;
    }
  }

  class Index {
    value = 0;
  }

  function kthToLast(head: LinkedListNode | null, k: number): number {
    const idx = new Index();
    const node = kthToLastHelper(head, k, idx);
    if (node !== null) {
      return node.data;
    }
    return -1;
  }

  function kthToLastHelper(head: LinkedListNode | null, k: number, idx: Index): LinkedListNode | null {
    if (head === null) {
      return null;
    }
    const node = kthToLastHelper(head.next, k, idx);
    idx.value = idx.value + 1;
    if (idx.value === k) {
      return head;
    }
    return node;
  }
  ```

- runner를 사용한 풀이

  ```ts
  class LinkedListNode {
    data: number;
    next: LinkedListNode | null = null;
    constructor(data: number) {
      this.data = data;
    }
  }

  function kthToLast(head: LinkedListNode | null, k: number): number {
    let p1: LinkedListNode | null = head;
    let p2: LinkedListNode | null = head;

    while (k > 0) {
      if (p1 === null) return -1;
      p1 = p1.next;
      k--;
    }

    while (p1 !== null) {
      p1 = p1.next;
      p2 = p2!.next;
    }

    return p2!.data;
  }
  ```

2.3 중간 노드 삭제

- 내 풀이

  ```ts
  function deleteNode(node: MyNode | null) {
    if (node === null || node.next === null) return false;
    node.data = node.next.data;
    node.next = node.next.next;
  }
  ```

- 도서의 풀이

  ```ts
  function deleteNode(n: MyNode | null): boolean {
    if (n === null || n.next === null) return false;
    const next = n.next;
    n.data = next.data;
    n.next = next.next;
    return true;
  }
  ```

2.4 분할

- 내 풀이

  ```ts
  function split(head: MyNode | null, x: number) {
    let beforeHead = new MyNode(0);
    let before = beforeHead;
    let afterHead = new MyNode(0);
    let after = afterHead;
    while (head) {
      if (head.data < x) {
        before.next = head;
        before = before.next;
      } else {
        after.next = head;
        after = after.next;
      }
      head = head.next;
    }
    after.next = null;
    before.next = afterHead.next;
    return beforeHead.next;
  }
  ```

- 도서의 풀이 1

  ```ts
  function partition(node: MyNode | null, x: number): MyNode | null {
    let beforeStart: MyNode | null = null;
    let beforeEnd: MyNode | null = null;
    let afterStart: MyNode | null = null;
    let afterEnd: MyNode | null = null;

    while (node != null) {
      let next = node.next;
      node.next = null;
      if (node.data < x) {
        if (beforeStart === null) {
          beforeStart = node;
          beforeEnd = beforeStart;
        } else {
          beforeEnd!.next = node; // beforeEnd는 무조건 이전 조건에서 세팅됨
          beforeEnd = node;
        }
      } else {
        if (afterStart === null) {
          afterStart = node;
          afterEnd = afterStart;
        } else {
          afterEnd!.next = node; // afterEnd는 무조건 이전 조건에서 세팅됨
          afterEnd = node;
        }
      }
      node = next;
    }

    if (beforeStart === null) { // beforeStart가 null이면 head로 쓸 수 없으므로 afterStart를 리턴
      return afterStart;
    }
    beforeEnd!.next = afterStart; // beforeEnd는 무조건 이전 조건에서 세팅되며, afterStart는 null이어도 상관 없음
    return beforeStart;
  }
  ```

- 도서의 풀이 2

  ```ts
  function partition(node: MyNode | null, x: number): MyNode | null {
    if (!node) return null;
    let head: MyNode | null = node;
    let tail: MyNode | null = node;

    while (node !== null) {
      let next: MyNode | null = node.next;
      if (node.data < x) {
        node.next = head;
        head = node;
      } else {
        tail!.next = node;
        tail = node;
      }
      node = next;
    }
    tail.next = null;
    return head;
  }
  ```

2.5 리스트의 합

- 내 풀이

  ```ts
  function sumReverse(head1: MyNode, head2: MyNode): MyNode {
    let first = parseLinkedList(head1);
    let second = parseLinkedList(head2);
    let sum = first + second;
    return numToLinkedList(sum);
  }

  function parseLinkedList(head: MyNode): number {
    let sum = 0;
    let multiplier = 1;
    let current: MyNode | null = head;
    while (current) {
      sum += current.data * multiplier;
      multiplier *= 10;
      current = current.next;
    }
    return sum;
  }

  function numToLinkedList(num: number): MyNode {
    let head: MyNode | null = null;
    let current: MyNode | null = null;
    while (num > 0) {
      let digit = num % 10;
      num = Math.floor(num / 10);
      if (!head) {
        head = new MyNode(digit);
        current = head;
      } else {
        current!.next = new MyNode(digit);
        current = current!.next;
      }
    }
    return head!;
  }
  ```

- 도서의 풀이

  ```ts
  function addLists(l1: MyNode | null, l2: MyNode | null, carry: number): MyNode | null {
    if (l1 === null && l2 === null && carry === 0) return null;

    let result: MyNode | null = new MyNode(0);
    let value = carry;
    if (l1 !== null) {
      value += l1.data;
    }
    if (l2 !== null) {
      value += l2.data;
    }
    result.data = value % 10;

    if (l1 !== null || l2 !== null) {
      let more = addLists(
        l1 === null ? null : l1.next,
        l2 === null ? null : l2.next,
        value >= 10 ? 1 : 0);
      result.next = more;
    }
    return result;
  }
  ```

- 도서의 풀이(연관문제)

  ```ts
  class PartialSum {
    sum: MyNode | null = null;
    carry = 0;
  }

  function addLists(l1: MyNode | null, l2: MyNode | null, carry: number): MyNode | null {
    let len1 = getLength(l1);
    let len2 = getLength(l2);

    if (len1 < len2) {
      l1 = padList(l1, len2 - len1);
    } else {
      l2 = padList(l2, len1 - len2);
    }

    const sum = addListsHelper(l1, l2);

    if (sum.carry === 0) {
      return sum.sum;
    } else {
      const result = insertBefore(sum.sum, sum.carry);
      return result;
    }
  }

  function getLength(l: MyNode | null): number {
    if (!l) return 0;
    return 1 + getLength(l.next);
  }

  function padList(l: MyNode | null, padding: number): MyNode | null {
    let head = l;
    for (let i = 0; i < padding; i++) {
      head = insertBefore(head, 0);
    }
    return head;
  }

  function insertBefore(head: MyNode | null, data: number): MyNode {
    const node = new MyNode(data);
    if (head) {
      node.next = head;
    }
    return node;
  }

  function addListsHelper(l1: MyNode | null, l2: MyNode | null): PartialSum {
    if (!l1 && !l2) {
      return new PartialSum();
    }

    // main 함수임 addLists에서 addListsHelper를 호출하기 전에 l1과 l2를 padding 해주었으니 null assertion 처리
    const sum = addListsHelper(l1!.next, l2!.next);
    const val = sum.carry + l1!.data + l2!.data;
    const fullResult = insertBefore(sum.sum, val % 10);

    sum.sum = fullResult;
    sum.carry = Math.floor(val / 10);
    return sum;
  }
  ```

  - PartialSum 클래스를 만들어서, sum과 carry를 저장하도록 함.
  - addLists 함수에서는 두 리스트의 길이를 비교하여 짧은 리스트를 padding 해주고, addListsHelper를 호출함.
  - 이를 바탕으로 addListsHelper 함수는 l1과 l2의 길이가 같다고 가정하고, 두 리스트의 합을 구함.

2.6 회문

- 내 풀이

  ```ts
  function isPalindrome(head: MyNode): boolean {
    const stack: number[] = [];
    let slow = head;
    let fast = head;
    while (fast && fast.next) {
      stack.push(slow.data);
      slow = slow.next!;
      fast = fast.next.next!;
    }
    if (fast) slow = slow.next!;
    while (slow) {
      if (slow.data !== stack.pop()) return false;
      slow = slow.next!;
    }
    return true;
  }
  ```

- 도서의 풀이 1

  ```ts
  function isPalindrome(head: MyNode | null): boolean {
    const reversed = reverseAndClone(head);
    return isEqual(head, reversed);
  }

  function reverseAndClone(node: MyNode | null): MyNode | null {
    let head: MyNode | null = null;
    while (node !== null) {
      let n = new MyNode(node.data);
      n.next = head;
      head = n;
      node = node.next;
    }
    return head;
  }

  function isEqual(one: MyNode | null, two: MyNode | null): boolean {
    while (one !== null && two !== null) {
      if (one.data !== two.data) return false;
      one = one.next;
      two = two.next;
    }
    return one === null && two === null;
  }
  ```

- 도서의 풀이 2

  ```ts
  function isPalindrome(head: MyNode | null): boolean {
    let fast = head;
    let slow = head;

    const stack: number[] = [];

    while (fast !== null && fast.next !== null) {
      stack.push(slow!.data);
      slow = slow!.next!;
      fast = fast.next.next!;
    }

    // fast가 끝에 도달하지 않은 경우, 즉 전체 개수가 홀수인 경우
    if (fast !== null) {
      slow = slow!.next!;
    }

    while (slow !== null) {
      const top = stack.pop();
      if (top !== slow.data) return false;
      slow = slow.next!;
    }
    return true;
  }
  ```

- 도서의 풀이 3

  ```ts
  class Result {
    node: MyNode | null;
    result: boolean;

    constructor(node: MyNode | null, result: boolean) {
      this.node = node;
      this.result = result;
    }
  }

  function isPalindrome(head: MyNode | null): boolean {
    const length = lengthOfList(head);
    const result = isPalindromeRecurse(head, length);
    return result.result;
  }

  function lengthOfList(n: MyNode | null): number {
    let size = 0;
    while (n !== null) {
      size++;
      n = n.next;
    }
    return size;
  }

  function isPalindromeRecurse(head: MyNode | null, length: number): Result {
    if (head === null || length <= 0) {
      return new Result(head, true);
    } else if (length === 1) {
      return new Result(head.next, true);
    }

    const res = isPalindromeRecurse(head.next, length - 2);

    if (!res.result || res.node === null) {
      return res;
    }
    
    res.result = (head.data === res.node.data);

    res.node = res.node.next;

    return res;
  }
  ```

2.7 교집합

- 내 풀이

  ```ts
  function findIntersection(head1: MyNode, head2: MyNode) {
    const set = new Set();
    let current1: MyNode | null = head1;
    let current2: MyNode | null = head2;
    while (current1 !== null && current2 !== null) {
      if (current1.data === current2.data) {
        set.add(current1.data);
      }
      current1 = current1.next;
      current2 = current2.next;
    }
    return set;
  }
  ```

  - 문제를 완전히 잘못 이해했다.
  - 노드의 주소가 완전히 같은 경우를 찾아야 함.

- 도서의 풀이

  ```ts
  function findIntersection(list1: MyNode | null, list2: MyNode | null) {
    if (list1 === null || list2 === null) return null;

    const result1 = getTailAndSize(list1);
    const result2 = getTailAndSize(list2);

    if (result1.tail !== result2.tail) return null;

    let shorter: MyNode | null = result1.size < result2.size ? list1 : list2;
    let longer: MyNode | null = result1.size < result2.size ? list2 : list1;

    longer = getKthNode(longer, Math.abs(result1.size - result2.size));

    while (shorter !== longer) {
      shorter = shorter!.next;
      longer = longer!.next;
    }

    return longer;
  }

  function getTailAndSize(list: MyNode): Result {
    let size = 1;
    let current = list;
    while (current.next) {
      size++;
      current = current.next;
    }

    return new Result(current, size);
  }

  function getKthNode(head: MyNode, k: number): MyNode {
    let current = head;
    while (k > 0 && current !== null && current.next !== null) {
      current = current.next;
      k--;
    }
    return current;
  }
  ```

2.8 루프 발견

- 내 풀이

  ```ts
  function findLoop(head: MyNode): MyNode | undefined {
    const set = new Set();
    let node: MyNode | null = head;
    while (node) {
      if (set.has(node)) return node;
      set.add(node);
      node = node.next;
    }
    return;
  }
  ```

- 도서의 풀이

  ```ts
  function findBeginning(head: MyNode | null): MyNode | null {
    let slow = head;
    let fast = head;

    while (fast !== null && fast.next !== null) {
      slow = slow!.next;
      fast = fast.next.next;
      if (slow === fast) break;
    }
    if (fast === null || fast.next === null) return null;

    slow = head;
    while (slow != fast) {
      slow = slow!.next;
      fast = fast!.next;
    }

    return fast;
  }
  ```

### 3. 스택과 큐

#### 스택 구현하기

- 스택의 기본 연산
  - pop(): 스택에서 가장 위에 있는 항목을 제거한다.
  - push(item): item 하나를 스택의 가장 윗 부분에 추가한다.
  - peek(): 스택의 가장 위에 있는 항목을 반환한다.
  - isEmpty(): 스택이 비어 있을 때에 true를 반환한다.

- 스택의 구현(연결 리스트 활용)

  ```ts
  class MyNode {
    data: number;
    next: MyNode | null = null;

    constructor(data: number) {
      this.data = data;
    }
  }

  class MyStack {
    top: MyNode | null = null;

    pop(): number | null {
      if (this.top === null) throw new Error('Empty stack');
      const item = this.top.data;
      this.top = this.top.next;
      return item;
    }

    push(item: number): void {
      const t = new MyNode(item);
      t.next = this.top;
      this.top = t;
    }

    peek(): number | null {
      if (this.top === null) throw new Error('Empty stack');
      return this.top.data;
    }

    isEmpty(): boolean {
      return this.top === null;
    }
  }
  ```

#### 큐 구현하기

- 큐의 기본 연산
  - add(item): item을 큐의 끝 부분에 추가한다.
  - remove(): 큐의 첫 번째 항목을 제거한다.
  - peek(): 큐의 첫 번째 항목을 반환한다.
  - isEmpty(): 큐가 비어 있을 때에 true를 반환한다.

- 큐의 구현(연결 리스트 활용)

  ```ts
  class MyNode {
    data: number;
    next: MyNode | null = null;

    constructor(data: number) {
      this.data = data;
    }
  }

  class MyQueue {
    first: MyNode | null;
    last: MyNode | null;

    add(data: number): void {
      const t = new MyNode(data);
      if (this.last !== null) {
        this.last.next = t;
      }
      this.last = t;
      if (this.first === null) {
        this.first = this.last;
      }
    }

    remove(): number | null {
      if (this.first === null) throw new Error('Empty queue');

      const data = this.first.data;
      this.first = this.first.next;
      if (this.first === null) {
        this.last = null;
      }
      return data;
    }

    peek(): number | null {
      if (this.first === null) throw new Error('Empty queue');
      return this.first.data;
    }

    isEmpty(): boolean {
      return this.first === null;
    }
  }
  ```

#### 면접문제

3.1 한 개로 세 개

- 도서의 풀이(고정길이)

  ```ts
  class FixedMultiStack {
    numberOfStacks = 3;
    stackCapacity: number;
    values: number[];
    sizes: number[];

    constructor(stackSize: number) {
      this.stackCapacity = stackSize;
      this.values = new Array(stackSize * this.numberOfStacks).fill(0);
      this.sizes = new Array(this.numberOfStacks).fill(0);
    }

    push(stackNum: number, value: number) {
      if (this.isFull(stackNum)) throw new Error('Stack is full');

      this.sizes[stackNum]++;
      this.values[this.indexOfTop(stackNum)] = value;
    }

    pop(stackNum: number): number {
      if (this.isEmpty(stackNum)) throw new Error('Stack is empty');

      const topIndex = this.indexOfTop(stackNum);
      const value = this.values[topIndex];
      this.values[topIndex] = 0;
      this.sizes[stackNum]--;
      return value;
    }

    peek(stackNum: number): number {
      if (this.isEmpty(stackNum)) throw new Error('Stack is empty');

      return this.values[this.indexOfTop(stackNum)];
    }

    isEmpty(stackNum: number): boolean {
      return this.sizes[stackNum] === 0;
    }

    isFull(stackNum: number): boolean {
      return this.sizes[stackNum] === this.stackCapacity;
    }

    indexOfTop(stackNum: number): number {
      const offset = stackNum * this.stackCapacity;
      const size = this.sizes[stackNum];
      return offset + size - 1;
    }
  }
  ```

3.2 스택 Min

- 도서의 풀이 1

  ```ts
  class NodeWithMin {
    value: number;
    min: number;

    constructor(v: number, min: number) {
      this.value = v;
      this.min = min;
    }
  }

  class StackWithMin {
    stack: NodeWithMin[];

    constructor() {
      this.stack = [];
    }

    push(v: number): void {
      const newMin = Math.min(v, this.min());
      this.stack.push(new NodeWithMin(v, newMin));
    }

    pop(): number {
      if (this.isEmpty()) throw new Error('Stack is empty');
      return this.stack.pop()!.value;
    }

    min(): number {
      if (this.isEmpty()) {
        return Number.MAX_VALUE;
      } else {
        return this.peek().min;
      }
    }

    peek(): NodeWithMin {
      return this.stack[this.stack.length - 1];
    }

    isEmpty(): boolean {
      return this.stack.length === 0;
    }
  }
  ```

- 도서의 풀이 2

  ```ts
  class StackWithMin2 {
    s2: number[] = [];
    s1: number[] = [];
    
    push(value: number) {
      if (value <= this.min()) {
        this.s2.push(value);
      }
      this.s1.push(value);
    }

    pop() {
      if (this.isEmpty()) throw new Error('Stack is empty');
      if (this.s1.pop() === this.min()) {
        this.s2.pop();
      }
    }

    peek() {
      if (this.isEmpty()) throw new Error('Stack is empty');
      return this.s1[this.s1.length - 1];
    }

    isEmpty() {
      return this.s1.length === 0;
    }

    min() {
      if (this.isEmpty()) return Number.MAX_VALUE;
      return this.s2[this.s2.length - 1];
    }
  }
  ```

3.3 접시 무더기

- 도서의 풀이

  ```ts
  class SetOfStacks {
    stacks: number[][] = [[]];
    capacity = 3;

    getLastStack() {
      return this.stacks[this.stacks.length - 1];
    }

    push(value: number) {
      if (this.getLastStack().length === this.capacity) {
        this.stacks.push([]);
        this.getLastStack().push(value);
      } else {
        this.getLastStack().push(value);
      }
    }

    pop() {
      if (this.isEmpty()) throw new Error("Stack is empty");
      if (this.getLastStack().length === 0) {
        this.stacks.pop();
      }
      this.getLastStack().pop();
    }

    peek() {
      return this.getLastStack()[this.getLastStack().length - 1];
    }

    isEmpty() {
      return this.stacks.length === 1 && this.getLastStack().length === 0;
    }
  }
  ```

3.4 스택으로 큐

- 도서의 풀이

  ```ts
  class MyStack {
    stack: number[] = [];

    size(): number {
      return this.stack.length;
    }

    isEmpty(): boolean {
      return this.stack.length === 0;
    }

    push(value: number) {
      this.stack.push(value);
    }

    pop(): number {
      if (this.isEmpty()) throw new Error('Stack is empty');
      return this.stack.pop()!;
    }

    peek(): number {
      return this.stack[this.stack.length - 1];
    }
  }

  class MyQueue {
    stackNewest: MyStack = new MyStack();
    stackOldest: MyStack = new MyStack();

    size(): number {
      return this.stackNewest.size() + this.stackOldest.size();
    }

    add(value: number) {
      this.stackNewest.push(value);
    }

    private shiftStacks() {
      if (this.stackOldest.isEmpty()) {
        while (!this.stackNewest.isEmpty()) {
          this.stackOldest.push(this.stackNewest.pop());
        }
      }
    }

    peek(): number {
      this.shiftStacks();
      return this.stackOldest.peek();
    }

    remove(): number {
      this.shiftStacks();
      return this.stackOldest.pop();
    }
  }
  ```

3.5 스택 정렬

- 도서의 풀이

  ```ts
  function sort(s: MyStack) {
    const r = new MyStack()

    while (!s.isEmpty()) {
      const tmp = s.pop();
      while (!r.isEmpty() && r.peek() > tmp) {
        s.push(r.pop());
      }
      r.push(tmp);
    }

    while (!r.isEmpty()) {
      s.push(r.pop())
    }
  }
  ```

3.6 동물 보호소

- 도서의 풀이

  ```ts
  class LinkedListNode<T> {
    data: T;
    next: LinkedListNode<T> | null = null;

    constructor(data: T) {
      this.data = data;
    }
  }

  class LinkedList<T> {
    head: LinkedListNode<T> | null;

    constructor() {
      this.head = null;
    }

    addLast(data: T) {
      if (this.head === null) {
        this.head = new LinkedListNode(data);
      } else {
        let node = this.head;
        while (node.next !== null) {
          node = node.next;
        }
        node.next = new LinkedListNode(data);
      }
    }

    poll() {
      if (this.head === null) {
        return null;
      }
      let node = this.head;
      this.head = this.head.next;
      return node.data;
    }

    peek() {
      if (this.head === null) {
        return null;
      }
      return this.head.data;
    }

    isEmpty() {
      return this.head === null;
    }

    size() {
      let node = this.head;
      let count = 0;
      while (node !== null) {
        count++;
        node = node.next;
      }
      return count;
    }
  }

  abstract class Animal {
    private order: number | null = null;
    protected name: string;
    
    constructor(name: string) {
      this.name = name;
    }

    setOrder(ord: number) {
      this.order = ord;
    }

    getOrder() {
      if (this.order === null) throw new Error('order is null');
      return this.order;
    }

    isOlderThan(a: Animal) {
      if (this.order === null) throw new Error('order is null');
      return this.order < a.getOrder();
    }
  }

  class Dog extends Animal {
    constructor(name: string) {
      super(name);
    }
  }

  class Cat extends Animal {
    constructor(name: string) {
      super(name);
    }
  }

  class AnimalQueue {
    dogs = new LinkedList<Animal>();
    cats = new LinkedList<Animal>();

    private order = 0;

    enqueue(a: Animal) {
      a.setOrder(this.order);
      this.order++;

      if (a instanceof Dog) {
        this.dogs.addLast(a);
      } else {
        this.cats.addLast(a);
      }
    }

    dequeueAny() {
      if (this.dogs.size() === 0) {
        return this.dequeueCats();
      } else if (this.cats.size() === 0) {
        return this.dequeueDogs();
      } else {
        const dog = this.dogs.peek()!;
        const cat = this.cats.peek()!;
        if (dog.isOlderThan(cat)) {
          return this.dequeueDogs();
        } else {
          return this.dequeueCats();
        }
      }
    }

    dequeueDogs() {
      return this.dogs.poll();
    }

    dequeueCats() {
      return this.cats.poll();
    }
  }
  ```

### 4. 트리와 그래프

#### 트리의 종류

- 트리의 특징
  - 트리는 그래프의 한 종류이다.
  - 트리는 하나의 루트 노드를 갖는다.
  - 루트 노드는 0개 이상의 자식 노드를 갖는다.
  - 그 자식 또한 0개 이상의 자식 노드를 가지고, 이는 반복적으로 정의된다.
  - 트리에는 사이클이 존재 할 수 없다.
  - 트리에는 두 개 이상의 노드가 동일한 부모를 가질 수 없다.
- 트리의 종류
  - 이진 트리: 각 노드가 최대 두 개의 자식을 갖는 트리
  - 이진 탐색 트리
    - 이진 트리이면서, 각 노드의 왼쪽 자식은 해당 노드보다 작은 값을 갖고, 오른쪽 자식은 해당 노드보다 큰 값을 갖는 트리
    - '모든 왼쪽 자식들 <= n <= 모든 오른쪽 자식들'을 모든 노드 n에 대해 만족하는 이진 트리
  - 완전 이진 트리
    - 마지막 레벨을 제외하고 모든 노드가 채워져 있는 이진 트리
    - 마지막 레벨에서는 노드가 왼쪽부터 채워져 있어야 한다.
  - 전 이진 트리: 모든 노드가 0개 또는 2개의 자식 노드를 갖는 이진 트리
  - 포화 이진 트리
    - 모든 노드가 두 개의 자식 노드를 갖는 완전 이진 트리
    - 마지막 수준의 모든 노드가 채워져 있다.
    - 전체 노드의 개수가 2^k - 1개이다. (k는 트리의 높이)

#### 이진 트리 순회

- 전위 순회(pre-order traversal): 부모 노드를 먼저 방문한다.

  ```ts
  function preOrderTraversal(node: TreeNode) {
    if (node !== null) {
      visit(node);
      preOrderTraversal(node.left);
      preOrderTraversal(node.right);
    }
  }
  ```

- 중위 순회(in-order traversal): 왼쪽 자식을 방문한 다음 부모 노드를 방문한다.

  ```ts
  function inOrderTraversal(node: TreeNode) {
    if (node !== null) {
      inOrderTraversal(node.left);
      visit(node);
      inOrderTraversal(node.right);
    }
  }
  ```

- 후위 순회(post-order traversal): 자식 노드를 먼저 방문한 다음 부모 노드를 방문한다.

  ```ts
  function postOrderTraversal(node: TreeNode) {
    if (node !== null) {
      postOrderTraversal(node.left);
      postOrderTraversal(node.right);
      visit(node);
    }
  }
  ```

#### 이진 힙(최소힙과 최대힙)

- 이진 힙은 완전 이진 트리이다.
- 최소 힙은 부모 노드가 항상 자식 노드보다 작거나 같은 값을 갖는다.
- 최대 힙은 부모 노드가 항상 자식 노드보다 크거나 같은 값을 갖는다.
- insert, extract_min 두 가지의 메서드가 존재한다.
  - insert
    - 새로운 노드를 힙의 마지막 노드에 추가한다.
    - 새로운 노드를 부모 노드와 비교하여 새로운 노드가 더 작은 경우, 두 노드의 위치를 바꾼다.
    - 이 과정을 루트 노드까지 반복한다.
  - extract_min
    - 루트 노드를 제거한다.
    - 마지막 노드를 루트 노드로 이동한다.
    - 루트 노드를 자식 노드와 비교하여 자식 노드가 더 작은 경우, 두 노드의 위치를 바꾼다.
    - 이 과정을 리프 노드까지 반복한다.

#### 트라이(접두사 트리)

- 트라이는 문자열을 저장하고 효율적으로 탐색하기 위한 트리 자료구조이다.
- 트라이는 문자열의 길이가 M일 때, O(M)의 시간 복잡도로 탐색이 가능하다.
  - 해시 테이블의 경우도 사실 O(M)의 시간 복잡도를 가진다.
- 문자열의 종료를 나타내는 두 가지 방법이 존재한다.
  - 종료 문자를 사용하는 방법
    - 종료 문자를 사용하면 문자열의 중간에 종료 문자가 들어갈 수 없다.
    - 종료 문자를 사용하지 않는 방법보다 메모리를 더 사용한다.
  - 마지막 노드에 종료 플래그를 사용하는 방법
    - 마지막 노드에 종료 플래그를 사용하면 문자열의 중간에 종료 문자가 들어갈 수 있다.
    - 종료 플래그를 사용하지 않는 방법보다 메모리를 덜 사용한다.

#### 그래프

- 노드(Node)와 그 노드를 연결하는 간선(Edge)을 하나로 모아 놓은 자료구조이다.
- 그래프의 종류
  - 무방향 그래프: 간선에 방향이 없는 그래프
  - 방향 그래프: 간선에 방향이 있는 그래프
  - 가중치 그래프: 간선에 비용이나 가중치가 할당된 그래프
  - 연결 그래프: 무방향 그래프에 있는 모든 노드에 대해 항상 경로가 존재하는 그래프
  - 비연결 그래프: 무방향 그래프에서 특정 노드에 대해 경로가 존재하지 않는 그래프
  - 사이클: 단순 경로의 시작 노드와 종료 노드가 동일한 경우
  - 비순환 그래프: 사이클이 없는 그래프
  - 완전 그래프: 그래프의 모든 노드가 서로 연결되어 있는 그래프
  - 트리: 사이클이 없는 연결 그래프

- 인접 리스트(Adjacency List)
  - 그래프의 각 노드에 연결된 노드들을 리스트로 연결하여 저장하는 방식
  - 무방향 그래프의 경우, 각 노드에 연결된 노드들을 저장하는 리스트를 두 개 저장한다.
  - 방향 그래프의 경우, 각 노드에 연결된 노드들을 저장하는 리스트를 하나 저장한다.
  - 가중치 그래프의 경우, 각 노드에 연결된 노드들을 저장하는 리스트에 가중치를 저장한다.
  - 인접 리스트의 경우, 노드의 개수가 N일 때, O(N)의 메모리를 사용한다.

  ```ts
  class Graph {
    nodes: Node[];

    constructor(nodes: Node[]) {
      this.nodes = nodes;
    }
  }

  class Node {
    name: string;
    children: Node[];

    constructor(name: string, children: Node[]) {
      this.name = name;
      this.children = children;
    }
  }
  ```

- 인접 행렬(Ajacency Matrix)
  - 그래프의 각 노드에 연결된 노드들을 행렬로 연결하여 저장하는 방식
  - 무방향 그래프의 경우, 각 노드에 연결된 노드들을 저장하는 행렬을 대칭 행렬로 저장한다.
  - 방향 그래프의 경우, 각 노드에 연결된 노드들을 저장하는 행렬을 비대칭 행렬로 저장한다.
  - 인접 행렬은 인접 리스트에 비해 효율성이 떨어진다.
    - 인접 리스트에서는 특정 노드의 연결된 노드들을 쉽게 찾을 수 있지만, 인접 행렬에서는 모든 노드를 순회해야 한다.

- 그래프 탐색
  - DFS(Depth First Search)
    - 주로 모든 노드를 방문해야 하는 경우에 사용
    - 구현이 조금 더 간단한 편임.
      - 재귀를 통해 구현 가능
      - 그래프를 순회할 때, 방문여부를 반드시 확인해야 함.
        - 무한루프에 빠질 수 있음.

    ```ts
    function search(node: Node) {
      if (node === null) return;
      visit(node);
      node.visited = true;
      for (let child of node.children) {
        if (!child.visited) {
          search(child);
        }
      }
    }
    ```

  - BFS(Breadth First Search)
    - 최단경로 및 임의의 경로를 찾기위해 활용
    - 구현이 조금 더 복잡한 편임.
      - 재귀가 아닌 큐를 통해 구현 가능.

    ```ts
    function search(node: Node) {
      const queue: Node[] = [];
      node.marked = true;
      queue.push(node);

      while (queue.length > 0) {
        const r = queue.shift()!;
        visit(r);
        for (let child of r.children) {
          if (!child.marked) {
            child.marked = true;
            queue.push(child);
          }
        }
      }
    }
    ```

- 양방향 탐색

  ![Alt text](images/image06.png)

  - 양방향 탐색은 시작 노드와 목표 노드가 주어졌을 때, 두 노드에서 동시에 탐색을 시작하여 만나는 노드를 찾는 방법이다.
  - 일반적인 BFS보다 효율적임
    - BFS(K^d) vs 양방향 탐색(K^(d/2))
    - K: 노드의 자식 노드의 개수
    - d: 노드의 깊이(거리)

#### 면접문제

4.1 노드 사이의 경로

- 내 풀이

  ```ts
  class Vertex {
    value: string;
    constructor(value: string) {
      this.value = value;
    }
  }

  class DirectedGraph {
    vertices: Vertex[];
    edges: any;
    constructor() {
      this.vertices = [];
      this.edges = {};
    }

    addVertex(value: string) {
      const vertex = new Vertex(value);
      this.vertices.push(vertex);
      this.edges[vertex.value] = [];
    }

    addEdge(value1: string, value2: string) {
      this.edges[value1].push(value2);
    }

    removeEdge(value1: string, value2: any) {
      this.edges[value1] = this.edges[value1].filter(
        (vertex: any) => vertex !== value2
      );
    }

    removeVertex(value: string) {
      this.vertices = this.vertices.filter((vertex) => vertex.value !== value);
      delete this.edges[value];
      Object.keys(this.edges).forEach((key) => {
        this.edges[key] = this.edges[key].filter(
          (vertex: string) => vertex !== value
        );
      });
    }
  }

  function isPath(
    graph: any,
    source: string,
    destination: string,
    visited: any = {}
  ) {
    if (source === destination) return true;
    if (visited[source]) return false;
    visited[source] = true;
    return graph.edges[source].some((vertex: string) =>
      isPath(graph, vertex, destination, visited)
    );
  }
  ```

- 도서의 풀이

  ```ts

  ```

4.2 최소 트리

- 내 풀이

  ```ts
  class BinaryNode {
    value: number;
    left: BinaryNode | null = null;
    right: BinaryNode | null = null;

    constructor(value: number) {
      this.value = value;
    }
  }

    depth(): number {
      const leftDepth = this.left ? this.left.depth() : 0;
      const rightDepth = this.right ? this.right.depth() : 0;
      return Math.max(leftDepth, rightDepth) + 1;
    }
  }

  function arrayToBinaryTree(arr: number[]) {
    const mid = Math.floor(arr.length / 2);
    const root = new BinaryNode(arr[mid]);
    const left = arr.slice(0, mid);
    const right = arr.slice(mid + 1);
    if (left.length) root.left = arrayToBinaryTree(left);
    if (right.length) root.right = arrayToBinaryTree(right);
    return root;
  }
  ```

- 도서의 풀이

  ```ts

  ```

4.3 깊이의 리스트

- 내 풀이

  ```ts
  class BinaryNode {
    value: number;
    left: BinaryNode | null = null;
    right: BinaryNode | null = null;

    constructor(value: number) {
      this.value = value;
    }
  }

  function getDepthList(root: BinaryNode): Array<string | number>[] {
    const depthList: Array<string | number>[] = [];

    function traverse(node: BinaryNode | null, depth: number) {
      if (node === null) return;

      if (depthList[depth] === undefined) depthList[depth] = [];

      depthList[depth].push(node.value);

      traverse(node.left, depth + 1);
      traverse(node.right, depth + 1); 
    }

    traverse(root, 0);
    return depthList;
  }
  ```

- 도서의 풀이

  ```ts

  ```

4.4 균형 확인

- 내 풀이

  ```ts
  class BinaryNode {
    value: number;
    left: BinaryNode | null = null;
    right: BinaryNode | null = null;

    constructor(value: number) {
      this.value = value;
    }
  }

  function isBalancedTree(root: BinaryNode | null): boolean {
    if (!root) return true;

    const leftHeight = getHeight(root.left);
    const rightHeight = getHeight(root.right);

    if (Math.abs(leftHeight - rightHeight) > 1) {
      return false;
    }

    return isBalancedTree(root.left) && isBalancedTree(root.right);
  }

  function getHeight(root: BinaryNode | null): number {
    if (!root) return 0;

    return Math.max(getHeight(root.left), getHeight(root.right)) + 1;
  }
  ```

- 도서의 풀이

  ```ts

  ```

4.5 BST 검증

- 내 풀이

  ```ts
  class BinaryNode {
    value: number;
    left: BinaryNode | null = null;
    right: BinaryNode | null = null;

    constructor(value: number) {
      this.value = value;
    }
  }

  function isBst(
    root: BinaryNode | null,
    left = -Infinity,
    right = Infinity
  ): boolean {
    if (!root) return true;

    if (root.value < left || root.value >= right) return false;

    return (
      isBst(root.left, left, root.value) && isBst(root.right, root.value, right)
    );
  }
  ```

- 도서의 풀이

  ```ts

  ```

4.6 후속자

- 내 풀이

  ```ts
  class BinaryNode {
    value: number;
    left: BinaryNode | null = null;
    right: BinaryNode | null = null;
    root: BinaryNode | null = null;

    constructor(value: number) {
      this.value = value;
    }
  }

  function findInOrderSuccessor(root: BinaryNode | null, target: number): number {
    if (!root) return -1;

    let successor = -1;
    let current: BinaryNode | null = root;

    while (current) {
      if (current.value > target) {
        successor = current.value;
        current = current.left;
      } else {
        current = current.right;
      }
    }
    return successor;
  }
  ```

- 도서의 풀이

  ```ts

  ```
