# 가상 면접 사례로 배우는 대규모 시스템 설계 기초2

<img src="./cover.jpg" width="400"/>

## 1장 근접성 서비스

- 근접성 서비스(proximity service)는 네이버, 카카오, 구글 지도 등의 사용자의 위치를 기반으로 주변 정보를 제공하는 서비스를 말한다.

### 1단계: 문제 이해 및 설계 범위 확정

#### 기능 요구사항 vs 비기능 요구사항

- 특정 프로덕션 앱의 모든 기능을 주어진 시간 내에 설계하지 못하는 것은 당연하다.

- 어느 수준까지, 어느 부분을 중점적으로 설계할지에 대한 범위를 좁혀나가야 한다.
  - 이 과정이 오히려 면접자로 하여금 걱정을 덜어주고, 힌트를 얻을 수 있는 기회라고 생각한다.
  - 오히려 면접 과정에서, 실무에서보다 더 많은 정보를 제공받을 수 있다고 생각한다.

- 결과적으로 아래의 두 가지 산물이 나와야 한다.
  - 기능 요구사항
  - 비기능 요구사항

- 기능 요구사항은 면접관이 `명백하게 필요로`하는 기능을 말한다.
  - 여기서는 아래의 세 가지를 예시로 들었다.
    - 사용자의 위경도와 검색 반경에 매치외는 주변 정보를 제공한다.
    - 사업 소유주가 사업장의 정보를 등록/수정할 수 있으며, 실시간으로 반영될 필요는 없다.
    - 고객은 사업장의 상세 정보를 조회 할 수 있어야 한다.

- 비기능 요구사항은 면접관이 `명시하지는 않았지만, 달성이 필요한`기능을 말한다.
  - 여기서는 아래의 세 가지를 추정할 수 있다.
    - 낮은 지연시간
    - 개인정보보호
    - 고가용성

#### 개략적 규모 추정

- 사용자 수(DAU): 1억(100,000,000)명
- 사업장 수: 2억(200,000,000)개
- 개략적 QPS 추산
  - **앞으로 1일(86400s)는 100,000s로 가정한다.**
  - 1일 1명의 사용자가 5회의 조회를 한다고 가정한다.
  - 결과적으로 QPS는 5,000(5억 / 100,000)이 된다.

### 2단계: 개략적 설계안 제시 및 동의 구하기

- 이 과정에서는 큰 틀에서의 설계안을 제시하고, 면접관의 동의를 구한다.

- 주요 주제는 아래와 같다.
  - API 설계
  - 개략적 설계
  - 주변 사업장 검색 알고리즘
  - 데이터 모델링

#### API 설계

##### 위치 기반 검색 API

> GET /v1/search/nearby

##### 사업장 관련 API

> GET /v1/businesses/:id  
> POST /v1/businesses  
> PUT /v1/businesses/:id  
> DELETE /v1/businesses/:id  

#### 개략적 설계

- 위치 기반 서비스(LBS)와 사업장 서비스로 구분한다.
- 이는 읽기 위주의 서비스와 쓰기/수정/삭제가 필요한 서비스로 구분하기 위함이다.

#### 주변 사업장 검색 알고리즘

> Q? 사실 엄밀히 말하면 이 방법들 모두 공통적으로 '반경'을 기준으로 검색하는 것이 아닌 것으로 보인다.

##### 방안 1: 2차원 검색

```SQL
SELECT business_id, latitude, longitude
FROM businesses
WHERE (latitude BETWEEN {:my_lat} - radius AND {:my_lat} + radius)
  AND (longitude BETWEEN {:my_lon} - radius AND {:my_lon} + radius)
```

- 이 방법은 크게 두 가지 단점이 있다.
  - 위도, 경도별 데이터를 구한 뒤 이를 교집합 하는 과정에서 성능이 떨어질 수 있다.
  - 인덱스를 사용할 수 없다.

##### 방안 2: 균등 격자

- 위도, 경도를 균등한 격자로 나누어서, 해당 격자에 속하는 사업장을 찾는 방법이다.
- 하지만 하나의 격자 안에 존재하는 사업장이 균일하지 않다.

##### 방안 3: 지오해시

- 지오해시는 위도, 경도를 문자열로 변환하는 방법이다.
  - 최대 12단계 정밀도를 가지며, 12단계는 3cm 정도의 정밀도를 가진다.
  - 필요한 반경에 따라 적당한 정밀도를 선택할 수 있다.

- 하지만 이 방법에도 단점이 있다.
  - 인접한 격자를 찾는 방법이 복잡하다.
    - 일반적인 경우 지오해시는 공통 접두어로 인접지역을 찾을 수 있다.
    - 하지만 특정 지점에서는 이 방법이 적용되지 않기 때문이다.
  - 공통 접두어를 갖지만 다른 지역에 속하는 경우가 있다.
    - 이로인해 주변 격자의 데이터도 함께 가져와야 한다.

##### 방안 4: 쿼드트리

- 쿼드트리는 2차원 공간을 재귀적으로 4개의 사분면으로 나누는 방법이다.
- 내부 노드와 말단 노드의 구분과, 식별자를 사용하는 방법이 중요하다.
  - 처리하는 시간과 저장을 위한 공간이 생각보다 크지 않다는 것만 확인 하면 된다.

> Q? 좌상/우하단 좌표를 32바이트로 저장할거라면, 지오해시처럼 비트로 구분하는게 낫지 않을까?
> 좌표를 기준으로 분할한다면, 공간도 공간이지만 탐색도 어렵고 부동소수점 오차도 생길텐데?

- 사업장이 업데이트되고, 트리를 리밸런싱하는 방법이 골치아플 것 같다.


##### 방안 5: 구글 S2

- 힐베르트 곡선을 사용한 방법이다.
- 이를통해 2차원 공간을 1차원으로 색인 할 수 있다.
  - 특징으로는, 2차원으로 인접한 지역이 1차원으로도 인접하다. 또한 역도 성립한다.
- 지오펜스(geofence)와 같은 기능을 구현할 때 유용하다.
  - 이를 통해 보다 풍부한 기능을 제공 할 수 있다.

##### +@ 지오해시 vs 쿼드트리

- 둘 다 사용해보지는 않았지만, 지오해시가 더 간단하고 편리한 솔루션이 아닌가 싶다.
- 쿼드트리는 유지보수 소요가 매우 커 보인다. 그렇다고 몹시 뛰어난 기능을 제공하는 것은 아닌것 같다.

> Q? 쿼드트리가 뛰어난 점이 뭐가 있나? 특정 구간에 밀집도가 매우 큰 경우?
> 하지만 cm단위까지 정밀도를 요구하는 서비스가 아니라면, 지오해시가 더 효율적이지 않을까?

### 3단계: 상세 설계

- 주요 관심사
  - 데이터베이스 규모 확장
  - 지리정보 색인의 규모 확장
  - 캐시
  - 지역 및 가용성 구현
  - 시간대, 사업장 유형에 따른 검색
  - 최종 아키텍처 다이어그램

#### 데이터베이스 규모 확장

- 위치 기반 서비스를 이전 단계에서 LBS 서비스와 사업장 서비스, 두 개로 나누었다.
  - LBS 서비스
  - 사업장 서비스

- 즉, 각 위치정보(지오해시)에 속한 사업장 ID를 관리할 방법을 마련해야 한다.
  - 방안 1: 각 지오해시에 모든 사업장 ID를 JSON 형태로 저장한다.
    - 관리가 어렵고, 확장도 어렵다.
  - 방안 2: 지오해시와 사업장 ID 각각을 묶어 하나의 row로 저장한다.

#### 지리정보 색인의 규모 확장

- 앞서 2억건의 지리정보라고 할지라도, 하나의 서버에 저장할 수 있는 수준임을 확인했다.
  - 따라서 샤딩 등의 분할 저장은 필수적이지 않다.
  - 또한 지오해시는 샤딩 로직을 어플리케이션에서 직접 구현해야 하기 때문에, 까다롭다.

> Q? 지오해시의 샤딩 로직은 왜 까다롭다고 하는것일까?  
>  
> A. 앞서 다루었듯, 연속적이지 않은 구간이 있다는 면에서도 까다롭고, 각 구획별로 데이터의 양이 균일하지 않기에 핫스팟 문제가 발생할 수 있다.

- 결과적으로 데이터베이스를 다중화 하는것으로 충분하다.

#### 캐시

- 캐싱에서 가장 중요한 질문은 '정말 필요한가?'이다.
  - 캐싱은 복잡도를 높이고, 유지보수를 매우 어렵게 만든다.

- 캐싱을 사용함에 있어서 중요한 또다른 요건은 명확한 캐싱키를 정의하는 것이다.
  - 사용자의 위/경도가 가장 먼저 떠오르지만, 아래와 같은 문제가 있다.
    - 사용자의 위치는 정확하지 않다: 위경도는 소수점 6자리 이하까지도 표기되며, 움직이지 않아도 수시로 변화한다.
  - 지오해시나 쿼드트리의 결과를 캐싱키로 사용하는 것이 더 나을 수 있다.

> Q? 또 다른 캐싱키는 어떤게 있을까?  
>   
> A. 위경도를 특정 단위로 반올림하여 사용하는 것도 좋을 것 같다.  
> 명확한 비즈니스 목표가 있는것이 아니라면, 지오해시나 쿼드트리의 결과 자체를 캐싱키로 사용하는 것이 가장 효과적일 것으로 보인다.

- 캐시할 데이터의 유형은 다음과 같다.
  - 지오해시(혹은 다른 캐싱키)에 속한 사업장 ID
  - 사업장 ID에 대한 상세 정보

#### 지역 및 가용성 구현

- 지역 및 가용성을 고려할 때 기대할 수 있는 이점은 다음과 같다.
  - 실사용자와 시스템 사이의 물리적 거리를 줄일 수 있다.
    - 이는 지연시간을 줄이고, 사용자 경험을 향상시킨다.
  - 트래픽을 주변 인구에 따라 분산시킬 수 있다.
    - 이를 통해 보다 융통성 있는 서비스를 제공할 수 있다.
  - 지역별로 다른 규제와 법률을 준수할 수 있다.

> ❗ 지역별로 다른 규제와 법률을 준수하기 위한 분리라는 관점은 생각해보지 못했던 부분이다.

#### 시간대, 사업장 유형에 따른 검색

- 한 번 지역별로 쿼리된 결과는 상당히 소규모이다.
- 따라서 시간대, 혹은 사업장 유형별 검색 등의 기능은 쿼리 후 필터링하는 것으로 충분하다.

#### 최종 아키텍처 다이어그램

- 생략

### 4단계: 마무리

- 이번 장에서 다룬 주요한 개념들은 아래와 같다.
  - 지오해시, 쿼드트리, 구글 S2 등의 지리정보 색인 방법
  - 데이터베이스 규모 확장
  - 지역 및 가용성 구현

## 2장 주변 친구

- 어떻게 보면 1장의 근접성 서비스와 굉장히 유사해 보일 수 있음.
  - 그러나 큰 차이가 하나 있는데, 사업장의 위치 정보는 정적이지만 친구의 위치 정보는 동적이라는 것이다.

### 1단계: 문제 이해 및 설계 범위 확정

- '주변'의 정의 - 얼마나 가까워야 '주변'인가?: 5mile
- 예상되는 사용자의 수: 1억명
- 사용자의 이동 이력을 저장할 수 있어야 함. 저장 기간은 미정
- 특정 시간이상 비활성 상태이면 주변 친구 목록에서 사라져야 함.
- 복잡도 조정을 위해 사생활 및 데이터보호 등 고려사항은 생략한다.

#### 기능 요구사항

- 사용자는 모바일 앱에서 주변 친구를 확인 할 수 있어야 한다.
  - 친구와의 거리, 마지막으로 업데이트된 시간이 표기되어야 한다.
- 이 친구 목록은 실시간성으로, 일정 주기마다 업데이트 되어야 한다.

#### 비기능 요구사항

- 낮은 지연시간
- 안정성: 전반적으로 안정적이어야 한다. 다만 몇개의 데이터 손실은 허용된다.
- 결과적 일관성(eventual consistency)
  - 사용자의 위치 정보는 실시간으로 업데이트 되지 않아도 된다. 
  - 복제본 간의 동기화는 일정 시간 이후에 이루어져도 된다.

> Q? 일관성의 종류에도 여러가지가 있는 것으로 기억한다. 어떤게 있나?
>
> A. 일관성의 종류는 크게 세가지로 나뉜다.
> - 강한 일관성(Strong Consistency): 모든 복제본이 동일한 시점의 데이터를 가지는 것
> - 약한 일관성(Weak Consistency): 모든 복제본이 동일한 시점의 데이터를 가지지 않아도 되는 것
> - 결과적 일관성(Eventual Consistency): 시스템에 더 이상의 업데이트가 없을 때, 결과적으로 모든 복제본이 최종적으로 동일한 데이터를 가지게 되는 것을 보장하는 일관성 모델

#### 개략적 규모 추정

- 시스템의 규모 결정과, 주요 과제를 결정하기 위해 제약사항과 가정을 설정한다.
  - 주변친구의 범위는 5마일로, 약 8km이다.
  - 친구 정보는 30초마다 갱신되어야 한다.
    - 사람들은 걸어다닌다고 가정한다.
    - 걷는 속도로는 30초 미만에서는 의미있는 이동이 없기 때문이다.
- 평균적으로 이 기능을 활용하는 유저는 매일 1억명으로 가정한다. (DAU 1억명)
- 동시 접속 사용자는 이 10%인 1천만명으로 가정한다.
- 한명의 사용자는 평균적으로 400명의 친구를 가지고 있다고 가정한다.
  - 편의상 친구로 등록된 모든 사용자는 주변 친구 서비스를 사용한다고 가정한다.
- 이에 따르면 QPS는 약 10,000,000 / 30s = 333,333(약 33만)이다.

> ⚠️ 이 `QPS`는 오직 주변친구를 조회하는 요청만을 의미한다.

### 2단계: 개략적 설계안 제시 및 동의 구하기

- 주변친구 기능에서는 실시간성이 중요하므로 데이터 구조보다는 이 통신방법을 먼저 결정하는 것이 중요하다.
  - 이는 일반적인 서비스와는 다르게 단순한 HTTP 프로토콜을 사용할 수 없을 수 있기 때문이다.

> ❗ 이 책에서는 일종의 '판단 템플릿'을 제시하지만 위 사례와 같이, 때로는 기능의 특성에 따른 융통성있는 판단이 필요함을 보여준다.

### 개략적 설계안

- P2P 통신을 사용: 이론상으로 가능하기야 하겠지만, 일반적인 서비스 구현에는 어려움이 많다.

- 공통 백엔드 서버 사용
  - 이는 일반적인 서비스 구현에 가장 적합한 방법이다.
  - 하지만 1천만명이 각각 4백명에게 정보를 30초마다 갱신 요청한다면 이는 일반적으로 처리하기 어렵다.

- Pub/Sub 시스템과 웹소켓을 활용한 설계
  - Pub/Sub 시스템을 통해 위치 정보 업데이트를 효율적으로 처리
    - 사용자의 위치 변경을 이벤트로 발행
    - 친구들이 해당 이벤트를 구독하여 실시간 업데이트 수신
  - 웹소켓 서버를 통해 클라이언트와의 실시간 통신 구현
  - RESTful API 서버는 친구 관리 등 기타 기능을 제공
  - TTL을 사용한 위치정보 캐시로, 일정시간 이상 비활성인 사용자를 제거
  - 위치 이동 이력은 별도의 DB에 저장
