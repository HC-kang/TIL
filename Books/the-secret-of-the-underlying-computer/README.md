# 컴퓨터 밑바닥의 비밀

## Chapter 01. 프로그래밍 언어부터 프로그램 실행까지, 이렇게 진행된다

- 프로그래밍 언어는 컴퓨터 과학의 작은 일부분일뿐이다.

### 1.1 여러분이 프로그래밍 언어를 발명한다면?

- CPU는 결국 수많은 스위치의 집합체이다.
  - 스위치는 0과 1의 두 가지 상태를 가진다.

#### 1.1.1 창세기: CPU는 똑똑한 바보

- CPU는 단순 작업에 매우 효과적이고 빠르다.
- 그러나 초기 프로그래밍에서는 별도의 언어가 없어서 CPU의 명령어를 직접 작성해야 했다.
  - 천공카드, 천공테이프, 천공테이프 리더기 등의 기계를 사용했다.
- 예시

    ```binary
    00101001 00000000 00000000 00001000
    00101001 00000000 00000000 00001000
    ```

#### 1.1.2 어셈블리어 등장

- 이후 CPU가 수행하는 것은 결국 단순한 몇 개의 명령어라는 것을 알게 되었다.
  - 가산, 점프, 저장 등의 명령어 등
- 이 명령어를 사람이 이해할 수 있는 언어로 변환한 것이 어셈블리어이다.
- 예시

    ```assembly
    sub $8, %rsp
    mov $.LC0, %edi
    call puts
    mov $0, %eax
    ```

- 이러한 어셈블리어를 사용하면 CPU의 명령어를 직접 작성하는 것보다는 훨씬 편리하다.
- 그러나 이러한 어셈블리어를 바이너리로 변환하는 과정이 필요하다.

#### 1.1.3 저수준 계층의 세부 사항 대 고수준 계층의 추상화

- 어셈블리어는 사람이 인식할 수 있지만 여전히 저수준 언어이다.
  - 결국 작성자가 모든 세부 사항을 신경써야 한다.
- 이러한 어셈블리어를 추상화한 것이 고급 프로그래밍 언어이다.

#### 1.1.4 가득한 규칙: 고급 프로그래밍 언어의 시작

- 어셈블리어로 작성하는 코드에서 특정한 패턴이 발견되었고, 이를 추상화하여 고급 프로그래밍 언어를 만들었다.
  - 조건문, 반복문 및 함수 호출 등의 패턴이 추상화되었다.

#### 1.1.5 <인셉션>과 재귀: 코드 본질

- 조건문, 반복문 등으로 구성된 코드는 여러 번 중첩 될 수 있으며, 이는 결국 재귀로 표현 할 수 있다.
- 이렇게 재귀로 표현되는 최소 단위의 표현을 구문(syntax)이라고 한다.

#### 1.1.6 컴퓨터가 재귀를 이해하도록 만들기

- 위에서 말한 것 처럼 재귀적으로 표현되는 구문을 컴퓨터가 이해할 수 있도록 만들어야 한다.
- 이를 위해 구문을 트리 구조로 변환한다.

#### 1.1.7 우수한 번역가: 컴파일러

- 위에서 말한 여러 과정을 처리하는 프로그램을 컴파일러라고 한다.
  - 컴파일러는 작성된 코드를 파싱하여 트리 구조로 변환하고, 이를 기계어로 변환한다.

#### 1.1.8 해석형 언어의 탄생

- 다양한 CPU의 구조를 고려하여 매번 컴파일하는 것은 매우 번거롭다.
- 이를 해결하기 위해 해석형 언어가 등장했다.
  - 해석형 언어는 표준 명령어라는 중간 단계를 거쳐 CPU에 맞게 변환된다.

#### 정리 및 과제

> 본인이 사용하는 언어가 코드 -> 표준 명령어 -> 인터프리터 -> CPU 과정을 어떤 식으로 수행하는지 알아보자.

- Javascript의 경우
  - 렉싱 -> 파싱 -> AST -> 바이트코드 -> 인터프리터(Ignition, 빠른 실행) -> 인터프리터(TurboFan, 최적화) -> CPU

### 1.2 컴파일러는 어떻게 작동하는 것일까?

- 컴파일러의 사용은 매우 간단하다. 그러나 이 이면에는 많은 과정이 숨어 있다.

#### 1.2.1 컴파일러는 그저 일반적인 프로그램일 뿐, 대단하지 않다.

- 컴파일러
  - 고수준 언어를 저수준 언어로 번역하는 프로그램.
  - 복잡도가 높은 프로그램이지만, 결국 일반적인 프로그램일 뿐이다.

#### 1.2.2 각각의 토큰 추출하기

- 컴파일러가 가장 먼저 하는 일은 소스 코드를 토큰으로 분리하는 것이다.
- 이 과정을 어휘 분석(lexical analysis; lexing)이라고 한다.
  - 예시
    - 원본 코드
     
      ```c
      int a = 1;
      int b = 2;

      while (a < b) {
        b = b - 1;
      }
      ```
    
    - 토큰화된 코드

      ```
      T_Keyword    int
      T_Identifier a
      T_Assign     =
      T_Int        1
      T_Semicolon  ;
      T_Keyword    int
      ...
      ```

#### 1.2.3 토큰이 표현하고자 하는 의미

- 렉싱을 거친 토큰을 이용하여 해석(parsing)을 진행한다.
- 이 과정에서 문법적 오류를 확인하고, 구문 트리(syntax tree)를 생성한다.

#### 1.2.4 생성된 구문 트리에 이상은 없을까?

- 컴파일(해석) 과정에서 문법적 오류를 확인하기에 구문 트리에는 문법적 오류가 없다.
- 그러나 아직 의미적 오류는 확인하지 않았고, 이에 대한 검사가 필요하다.
- 이 과정을 의미 분석(semantic analysis)이라고 한다.
  - 정수에 문자열을 더하거나, 비교의 좌우에 다른 타입의 변수를 사용하는 등의 오류를 확인한다.

#### 1.2.5 구문 트리를 기반으로 중간 코드 생성하기

- 의미 분석을 통과한 구문 트리를 기반으로 중간 코드를 생성한다.
  - 중간 코드(Intermediate Representation; IR)는 CPU에 종속되지 않는 코드이다.
  - 이 과정에서 최적화가 진행되기도 한다.

#### 1.2.6 코드 생성

- 중간 코드를 기반으로 CPU에 맞는 어셈블리어로 변환하고, 다시 이를 기계어로 변환한다.
- 하지만 지금까지의 과정은 하나의 파일에 대한 컴파일이었고, 여러 파일을 컴파일 할 때는 링크(link)라는 과정이 필요하다.
