# Nodejs 디자인 패턴 바이블 독서 정리

## Chapter 01. Node.js 플랫폼

- 주요개념
  - Node.js의 철학 "Node way"
  - Reactor 패턴 - Node.js의 비동기 이벤트 주도 아키텍처의 핵심 매커니즘
  - 브라우저와 다르게, 서버에서 동작하는 Javascript의 의미

### 1-1 Node.js 철학

  1-1-1 경량 코어

- 최소한의 기능세트를 제공하고, 이외의 공간에 유저랜드(유저스페이스)를 제공하여 사용자들이 스스로 생태계를 만들 수 있게 한다.
- 엄격하고 느린 진화 대신, 기민하고 창의적인 진화를 통해 생태계를 발전시킨다.

  1-1-2 경량 모듈  

- 작은 모듈의 장점
  - 이해하기 쉽고, 사용하기 쉽다.
  - 테스트 및 유지보수가 쉽다.
  - 사이즈가 작아 브라우저에서 사용하기 좋다.

  1-1-3 작은 외부 인터페이스

- 최소한의 기능 노출
- 확장보다는, 사용을 위한 모듈: 복잡도를 늘리지 않고, 기능을 추가할 수 있게 한다.
- 클래스보다는 함수 노출을 선호한다.

  1-1-4 간결함과 실용주의
- KISS(Keep It Simple, Stupid)
- 완벽하게 기능하지만 엄청난 노력을 들이는 것 보다, 타협 가능한 복잡성을 가진 빠른 작업이 더 좋다.

### 1-2 Node.js는 어떻게 작동하는가

- 리액터 패턴
- 단일 스레드
- 논 블로킹 I/O

  1-2-1 I/O는 느리다

  1-2-2 블로킹 I/O

  1-2-3 논블로킹 I/O

  1-2-4 이벤트 디멀티플렉싱

- 신호가 원래의 구성요소로 다시 분할되는 작업
- 이를 통해 단일 스레드가 여러 작업을 동시에 처리할 수 있게 된다.
- 여러 스레드에 분산되는 대신 단일 스레드에서 시간에 따라 분산된다.
- 전체 유휴시간 감소에 따른 성능 향상 이점이 있다.
- 레이스 컨디션, 다중 스레드 동기화 문제를 피할 수 있다.

  1-2-5 리액터 패턴

1. 이벤트 디멀티플렉서에 요청하여 IO작업 생성
2. IO작업 완료시 이벤트 작업을 큐에 추가
3. 이벤틀 루프가 큐를 순회
4. 각 이벤트의 핸들러가 호출됨
5. 완료시 이벤트 루프에 제어권 반환 / 혹은 비동기 작업 요청
6. 이벤트 루프가 종료될 때까지 반복

  1-2-6 Libuv, Node.js의 I/O엔진

- Libuv: 다수 운영체제의 디멀티플렉싱을 위해 추상화된 C 라이브러리

  1-2-7 Node.js를 위한 구성
- Libuv 외에도 바인딩 세트, V8, 코어 API등이 있음.

### 1-3 Node.js에서의 Javascript

  1-3-1 최신 Javascript를 실행시켜라

- 브라우저와 다르게 제약없이 최신 JS를 실행할 수 있음

  1-3-2 모듈 시스템
  - CommonJS vs ES 모듈

  1-3-3 운영체제 기능에 대한 모든 접근
- fs, crypto, process 등 다양한 모듈을 통해 운영체제의 기능에 접근 할 수 있음

  1-3-4 네이티브 코드 실행
- 이외에도 C/C++등의 레거시를 작은 노력으로도 도입 할 수 있음.

### Chapter 01 요약

- Node.js의 철학은 최소한의 코어로 더 작고 간단한 필요 기능만을 노출하는 실용주의에 기반한다.

## Chapter 02. 모듈 시스템

- 주요개념
  - 모듈이 왜 필요한가?
  - Node.js에서 다른 모듈시스템이 가능한 이유?
  - ES모듈
  - CommonJS 모듈
  - ES 모듈과 CommonJS 모듈의 차이점 및 상호 이용

### 2-1 모듈의 필요성

1. 코드베이스를 여러 파일로 분할하여, 독립적인 기능을 분리하여 개발 및 테스트하는데에 도움을 줌.
2. 다른 프로젝트에 코드를 재사용 할 수 있음.
3. 은닉성을 제공하여, 꼭 필요한 인터페이스만을 노출하도록 선택 할 수 있음.
4. 상호간의 종속성을 쉽게 관리 할 수 있음.

### 2-2 Javascript와 Node.js에서의 모듈 시스템

- 브라우저 입장에서는 모듈화 된 작은 코드는 import 해서 사용하기에 좋음
- Node.js는 브라우저와 달리, 로컬 파일시스템에만 의존함. 이로인해 CommonJS가 구현되었음.

### 2-3 모듈 시스템과 패턴

2-3-1 노출식 모듈 패턴

- JS에는 네임스페이스가 없기 때문에, 전역 네임스페이스를 오염시킬 위험이 크고, 이는 굉장히 위험한 일임.
- 이를 해결하기 위해, exports를 활용한 노출식 모듈 패턴을 사용함.

### 2-4 CommonJS 모듈

- CommonJS의 주요 개념
  1. require는 로컬 파일시스템으로부터 모듈을 임포트한다.
  2. exports와 module.exports는 현재 모듈에서 노출할 기능을 내보낸다.

2-4-1 직접 만드는 모듈 로더

- 동기 방식으로 모듈을 로드하는 로더: import 순서를 지키기 위해서.

```javascript
function loadModule(filename, module, require) {
  const wrappedSrc = 
    `(function (module, exports, require) {
        $(fs.readFileSync(filename, 'utf8')}
      })(module, module.exports, require);`;
    eval(wrappedSrc)
  }
```

1. 모듈의 전체 경로를 resolve
2. 이미 캐시된 모듈이 있는지 확인
3. 빈 객체 리터럴을 생성하여 exports 할 준비
4. 최초 로드 후 객체를 캐시
5. module, require를 모듈에 전달하고, 모듈은 module.exports를 통해 기능을 노출한다.
6. module.exports를 통해 노출된 기능을 반환한다.

2-4-2 모듈 정의

- module.exports 변수에 할당된 객체만 공개됨.

2-4-3 module.exports 대 exports

- exports는 module.exports의 참조

2-4-4 require 함수는 동기적이다

- 만약, 비동기적으로 로드한다면, 모듈을 로드한 직후 사용할 수 있다는 보장이 없음.

2-4-5 resolving 알고리즘

- 파일 모듈
  1. 절대경로: /로 시작하는 경로
  2. 상대경로: ./로 시작하는 경로. 현재 모듈의 위치를 기준으로 함.
- 코어 모듈: / 또는 ./로 시작하지 않는 경우 코어 Node.js 모듈 내에서 검색
- 패키지 모듈: 코어 모듈이 없는 경우, node_modules 디렉토리에서 검색

2-4-6 모듈 캐시

- 모듈 캐시의 기능
  1. 모듈 종속성 내에서 순환 종속성을 허용한다.
  2. 특정 패키지에서 동일한 모듈을 필요로 할 때, 얼마간 동일한 인스턴스를 반환토록 보장한다.
2-4-7 순환 종속성
- 모듈 A가 모듈 B를 필요로 하고, 모듈 B가 모듈 A를 필요로 할 때, 순환 종속성이 발생한다.
- require 되는 순서에 따라 순환 종속성이 문제가 될 수 있음
- ES 모듈은 이러한 순환 종속성을 효과적으로 해결함.

### 2-5 모듈 정의 패턴

2-5-1 exports 지정하기 (Named exports)

- 가장 기본적인 방법으로, exports 객체에 프로퍼티를 추가하는 방법.

2-5-2 함수 내보내기

- module.exports에 함수를 할당하는 방법
- 명확하게 단일한 진입점을 제공할 수 있음.
- 서브스택(substack) 패턴: 모듈을 함수로 정의하고, 함수를 호출하여 모듈을 반환하는 패턴
- SRP(Single Responsibility Principle)를 준수할 수 있음.

2-5-3 클래스 내보내기

- 함수로 내보내는 것 보다 내부를 더 많이 노출하게 됨.
- 그만큼 기능 확장에 유연함.

2-5-4 인스턴스 내보내기

- 모듈이 캐시되므로, 동일한 인스턴스를 반환함.
- 싱글턴과 유사하나, 인스턴스의 고유성을 보장하지는 않음.
  - 모듈이 종속성 트리 내에서 여러 번 사용되는 경우
- 필요시 새로운 인스턴스를 생성 할 수 있음 -> 안하는 게 좋음

2-5-5 다른 모듈 또는 전역 범위(global scope) 수정

- 몽키 패치
- 예측 할 수 없는 결과를 초래할 수 있으므로, 사용하지 않는 것이 좋음.
- 그러나 테스트를 위해 사용하는 경우도 있음.

### 2-6 ESM: ECMAScript 모듈

- CommonJS와 ESM의 가장 큰 차이점은, ESM은 Static하다는 것.
- 모듈 이름의 동적 생성이 불가능하며 상수 문자열만 허용됨.

2-6-1 Node.js에서 ESM 사용

- 확장자를 .mjs로 지정
- package.json에 type: module을 추가

2-6-2 exports와 imports 지정하기 (named exports and imports)

- ESM에서는 기본적으로 모두 private
- export된 개체들만 외부에서 접근 가능
- 모듈 import시 확장자를 생략할 수 없음.

2-6-3 export와 import 기본값 설정하기 (Default exports and imports)

- default export
- 단일 기능을 명확하게 내보낼 때 사용
- 자동 완성이 불가능하고, 서로 다른 파일에서 이름이 달라질 수 있어, 복잡도가 커질 수 있음.
- Tree shaking이 어려움.

2-6-4 혼합된 export (mixed exports)

- 생략

2-6-5 모듈 식별자

- 상대적 식별자(Relative)
- 절대 식별자(Absolute)
- 노출 식별자(Bare)
- 심층 임포트 식별자(Deep import)

2-6-6 비동기 임포트

- import 구문은 정적이며, 이로인해 두 가지 제약이 있음.
  - 모듈 식별자는 실행중에 생성될 수 없음
  - 제어구문 내에 포함될 수 없음
- 이를 위해 비동기 임포트 기능을 제공함.
- import() 함수를 통해 비동기적으로 모듈을 로드할 수 있음.
