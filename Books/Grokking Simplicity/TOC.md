# 쏙쏙 들어오는 함수형 코딩

## 심플한 코드로 복잡한 소프트웨어 길들이기

### CHAPTER 1 쏙쏙 들어오는 함수형 코딩에 오신 것을 환영합니다 1

- 함수형 프로그래밍은 무엇인가요? 2
- 실용적인 측면에서 함수형 프로그래밍 정의의 문제점 3
- 함수형 프로그래밍 정의가 혼란스러운 관리자 4
- 함수형 프로그래밍을 학문적 지식이 아닌 기술과 개념으로 보기 5
- 액션과 계산, 데이터 구분하기 6
- 함수형 프로그래머는 부를 때 조심해야 하는 코드를 구분합니다 7
- 함수형 프로그래머는 실행하는 코드와 그렇지 않은 코드를 구분합니다 8
- 함수형 프로그래머는 액션과 계산, 데이터를 구분합니다 9
- 함수형 프로그래밍에서는 코드를 세 가지로 분류합니다 10
- 액션, 계산, 데이터를 구분하면 어떤 장점이 있나요? 11
- 다른 함수형 프로그래밍 책과 다른 점 12
- 함수형 사고가 무엇인가요? 13
- 이 책을 읽는 기본 규칙 14
- 결론 16

### CHAPTER 2 현실에서의 함수형 사고 17

- 토니 피자에 오신 것을 환영합니다 18
- 파트 I: 액션과 계산, 데이터 19
- 변경 가능성에 따라 코드 나누기 20
- 파트 II: 일급 추상 21
- 분산 시스템을 타임라인으로 시각화하기 22
- 각각의 타임라인은 다른 순서로 실행됩니다 23
- 어려운 경험을 통해 분산 시스템에 대해 배운 것 24
- 타임라인 커팅: 로봇이 서로를 기다릴 수 있게 하기 25
- 좋은 경험을 통해 타임라인에 대해 배운 것 26
- 결론 27

- PART I 액션과 계산, 데이터

### CHAPTER 3 액션과 계산, 데이터의 차이를 알기 31

- 액션과 계산, 데이터 32
- 액션과 계산, 데이터는 어디에나 적용할 수 있습니다 33
- 장보기 과정에서 배운 것 36
- 새로 만드는 코드에 함수형 사고 적용하기 39
- 쿠폰 보내는 과정을 그려보기 42
- 쿠폰 보내는 과정 구현하기 47
- 이미 있는 코드에 함수형 사고 적용하기 54
- 액션은 코드 전체로 퍼집니다 56
- 액션은 다양한 형태로 나타납니다 57
- 결론 59

### CHAPTER 4 액션에서 계산 빼내기 61

- MegaMart.com에 오신 것을 환영합니다 62
- 무료 배송비 계산하기 63
- 세금 계산하기 64
- 테스트하기 쉽게 만들기 65
- 재사용하기 쉽게 만들기 66
- 액션과 계산, 데이터를 구분하기 67
- 함수에는 입력과 출력이 있습니다 68
- 테스트와 재사용성은 입출력과 관련 있습니다 69
- 액션에서 계산 빼내기 70
- 액션에서 또 다른 계산 빼내기 73
- 전체 코드를 봅시다 85
- 결론 86

### CHAPTER 5 더 좋은 액션 만들기 87

- 비즈니스 요구 사항과 설계를 맞추기 88
- 비즈니스 요구 사항과 함수를 맞추기 89
- 원칙: 암묵적 입력과 출력은 적을수록 좋습니다 91
- 암묵적 입력과 출력 줄이기 92
- 코드 다시 살펴보기 95
- 계산 분류하기 97
- 원칙: 설계는 엉켜있는 코드를 푸는 것이다 98
- add_item()을 분리해 더 좋은 설계 만들기 99
- 카피-온-라이트 패턴을 빼내기 100
- add_item() 사용하기 101
- 계산을 분류하기 102
- 작은 함수와 많은 계산 106
- 결론 107

### CHAPTER 6 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기 109

- 모든 동작을 불변형으로 만들 수 있나요? 110
- 동작을 읽기, 쓰기 또는 둘 다로 분류하기 111
- 카피-온-라이트 원칙 세 단계 112
- 카피-온-라이트로 쓰기를 읽기로 바꾸기 113
- 원래 버전과 카피-온-라이트 버전의 차이 보기 117
- 앞에서 만든 카피-온-라이트 동작은 일반적입니다 118
- 자바스크립트 배열 훑어보기 119
- 쓰기를 하면서 읽기도 하는 동작은 어떻게 해야 할까요? 122
- 쓰면서 읽기도 하는 함수를 분리하기 123
- 값을 두 개 리턴하는 함수로 만들기 124
- 불변 데이터 구조를 읽는 것은 계산입니다 131
- 애플리케이션에는 시간에 따라 변하는 상태가 있습니다 132
- 불변 데이터 구조는 충분히 빠릅니다 133
- 객체에 대한 카피-온-라이트 134
- 자바스크립트 객체 훑어보기 135
- 중첩된 쓰기를 읽기로 바꾸기 140
- 어떤 복사본이 생겼을까요? 141
- 얕은 복사와 구조적 공유를 그림으로 알아보기 142
- 결론 145

### CHAPTER 7 신뢰할 수 없는 코드를 쓰면서 불변성 지키기 147

- 레거시 코드와 불변성 148
- 우리가 만든 카피-온-라이트 코드는 신뢰할 수 없는 코드와 상호작용해야 합니다 149
- 방어적 복사는 원본이 바뀌는 것을 막아 줍니다 150
- 방어적 복사 구현하기 151
- 방어적 복사 규칙 152
- 신뢰할 수 없는 코드 감싸기 153
- 방어적 복사가 익숙할 수도 있습니다 156
- 카피-온-라이트와 방어적 복사를 비교해 봅시다 158
- 깊은 복사는 얕은 복사보다 비쌉니다 159
- 자바스크립트에서 깊은 복사를 구현하는 것은 어렵습니다 160
- 카피-온-라이트와 방어적 복사의 대화 162
- 결론 165

### CHAPTER 8 계층형 설계 I 167

- 소프트웨어 설계란 무엇입니까? 168
- 계층형 설계란 무엇인가요? 169
- 설계 감각을 키우기 170
- 계층형 설계 패턴 171
- 패턴 1: 직접 구현 172
- 3단계 줌 레벨 186
- 반복문 빼내기 189
- 직접 구현 패턴 리뷰 198
- 결론 199

### CHAPTER 9 계층형 설계 II 201

- 계층형 설계 패턴 202
- 패턴 2: 추상화 벽 203
- 추상화 벽으로 구현을 감춥니다 204
- 세부적인 것을 감추는 것은 대칭적입니다 205
- 장바구니 데이터 구조 바꾸기 206
- 장바구니를 객체로 다시 만들기 208
- 추상화 벽이 있으면 구체적인 것을 신경 쓰지 않아도 됩니다 209
- 추상화 벽은 언제 사용하면 좋을까요? 210
- 패턴 2 리뷰: 추상화 벽 211
- 앞에서 고친 코드는 직접 구현에 더 가깝습니다 212
- 패턴 3: 작은 인터페이스 213
- 패턴 3 리뷰: 작은 인터페이스 219
- 패턴 4: 편리한 계층 220
- 계층형 설계 패턴 221
- 그래프로 알 수 있는 코드에 대한 정보는 무엇이 있을까요? 222
- 그래프의 가장 위에 있는 코드가 고치기 가장 쉽습니다 223
- 아래에 있는 코드는 테스트가 중요합니다 225
- 아래에 있는 코드가 재사용하기 더 좋습니다 228
- 요약: 그래프가 코드에 대해 알려주는 것 229
- 결론 230

- PART II 일급 추상

### CHAPTER 10 일급 함수 I 233

- 마케팅팀은 여전히 개발팀과 협의해야 합니다 235
- 코드의 냄새: 함수 이름에 있는 암묵적 인자 236
- 리팩터링: 암묵적 인자를 드러내기 238
- 일급인 것과 일급이 아닌 것을 구별하기 240
- 필드명을 문자열로 사용하면 버그가 생기지 않을까요? 241
- 일급 필드를 사용하면 API를 바꾸기 더 어렵나요? 242
- 객체와 배열을 너무 많이 쓰게 됩니다 247
- 어떤 문법이든 일급 함수로 바꿀 수 있습니다 250
- 반복문 예제: 먹고 치우기 253
- 리팩터링: 함수 본문을 콜백으로 바꾸기 259
- 이것은 무슨 문법인가요? 262
- 왜 본문을 함수로 감싸서 넘기나요? 263
- 결론 265

### CHAPTER 11 일급 함수 II 267

- 코드 냄새 하나와 리팩터링 두 개 268
- 카피-온-라이트 리팩터링하기 269
- 배열에 대한 카피-온-라이트 리팩터링 270
- 함수를 리턴하는 함수 279
- 결론 288

### CHAPTER 12 함수형 반복 289

- 코드 냄새 하나와 리팩터링 두 개 290
- MegaMart에서 커뮤니케이션팀을 만들기로 했습니다 291
- 예제를 통해 map() 함수를 도출하기 294
- 함수형 도구: map() 295
- 함수를 전달하는 세 가지 방법 297
- 예제: 모든 고객의 이메일 주소 298
- 예제를 통해 filter() 함수 도출하기 301
- 함수형 도구: filter() 302
- 예제: 아무것도 구입하지 않은 고객 303
- 예제를 통해 reduce() 도출하기 306
- 함수형 도구: reduce() 307
- 예제: 문자열 합치기 308
- reduce()로 할 수 있는 것들 313
- 세 가지 함수형 도구를 비교하기 315
- 결론 316

### CHAPTER 13 함수형 도구 체이닝 317

- 고객 커뮤니케이션팀은 계속 일하고 있습니다 318
- 체인을 명확하게 만들기 1: 단계에 이름 붙이기 324
- 체인을 명확하게 만들기 2: 콜백에 이름 붙이기 325
- 체인을 명확하게 만들기 3: 두 방법을 비교 326
- 예제: 한 번만 구매한 고객의 이메일 목록 327
- 반복문을 함수형 도구로 리팩터링하기 332
- 팁 1: 데이터 만들기 333
- 팁 2: 한 번에 전체 배열을 조작하기 334
- 팁 3: 작은 단계로 나누기 335
- 절차적 코드와 함수형 코드 비교 337
- 체이닝 팁 요약 338
- 체이닝 디버깅을 위한 팁 340
- 다양한 함수형 도구 341
- 값을 만들기 위한 reduce() 345
- 데이터를 사용해 창의적으로 만들기 347
- 메서드 연산자로 정렬하기 353
- 결론 354

### CHAPTER 14 중첩된 데이터에 함수형 도구 사용하기 355

- 객체를 다루기 위한 고차 함수 356
- 필드명을 명시적으로 만들기 357
- update() 도출하기 358
- 값을 바꾸기 위해 update() 사용하기 359
- 리팩터링: 조회하고 변경하고 설정하는 것을 update()로 교체하기 361
- 함수형 도구: update() 362
- 객체에 있는 값을 시각화하기 363
- 중첩된 update 시각화하기 368
- 중첩된 데이터에 update() 사용하기 369
- updateOption() 도출하기 370
- update2() 도출하기 371
- 중첩된 객체에 쓸 수 있는 update2() 시각화하기 372
- incrementSizeByName()을 만드는 네 가지 방법 374
- update3() 도출하기 375
- nestedUpdate() 도출하기 377
- 안전한 재귀 사용법 382
- nestedUpdate() 시각화하기 383
- 재귀 함수가 적합한 이유 384
- 깊이 중첩된 구조를 설계할 때 생각할 점 386
- 깊이 중첩된 데이터에 추상화 벽 사용하기 387
- 앞에서 배운 고차 함수들 388
- 결론 389

### CHAPTER 15 타임라인 격리하기 391

- 버그가 있습니다! 392
- 두 번 빠르게 클릭해 봅시다 393
- 타임라인 다이어그램은 시간에 따라 어떤 일이 일어나는지 보여줍니다 395
- 두 가지 타임라인 다이어그램 기본 규칙 396
- 자세히 보면 놓칠 수 있는 액션 순서에 관한 두 가지 사실 400
- add-to-cart 타임라인 그리기: 단계 1 401
- 비동기 호출은 새로운 타임라인으로 그립니다 402
- 서로 다른 언어, 서로 다른 스레드 모델 403
- 한 단계씩 타임라인 만들기 404
- add-to-cart 타임라인 그리기: 단계 2 406
- 타임라인 다이어그램으로 순서대로 실행되는 코드에도 두 가지 종류가 있다는 것을 알 수 있습니다 407
- 타임라인 다이어그램으로 동시에 실행되는 코드는 순서를 예측할 수 없다는 것을 알 수 있습니다 408
- 좋은 타임라인의 원칙 409
- 자바스크립트의 단일 스레드 410
- 자바스크립트의 비동기 큐 411
- AJAX와 이벤트 큐 412
- 완전한 비동기 예제 413
- 타임라인 단순화하기 414
- 완성된 타임라인 읽기 420
- add-to-cart 타임라인 단순화하기: 단계 3 422
- 리뷰: 타임라인 그리기(단계1~3) 424
- 요약: 타임라인 다이어그램 그리기 426
- 타임라인을 나란히 보면 문제가 보입니다 427
- 두 번 천천히 클릭하면 문제가 없습니다 428
- 빠르게 두 번 클릭하면 잘못된 결과가 나옵니다 429
- 자원을 공유하는 타임라인은 문제가 생길 수 있습니다 430
- 전역변수를 지역변수로 바꾸기 431
- 전역변수를 인자로 바꾸기 432
- 재사용하기 더 좋은 코드로 만들기 435
- 원칙: 비동기 호출에서 명시적인 출력을 위해 리턴값 대신 콜백을 사용할 수 있습니다 436
- 결론 440

### CHAPTER 16 타임라인 사이에 자원 공유하기 441

- 좋은 타임라인의 원칙 442
- 장바구니에 아직 버그가 있습니다 443
- DOM이 업데이트되는 순서를 보장해야 합니다 445
- 자바스크립트에서 큐 만들기 447
- 원칙: 공유하는 방법을 현실에서 착안하기 455
- 큐를 재사용할 수 있도록 만들기 456
- 지금까지 만든 타임라인 분석하기 461
- 원칙: 문제가 있을 것 같으면 타임라인 다이어그램을 살펴보세요 464
- 큐를 건너뛰도록 만들기 465
- 결론 469

### CHAPTER 17 타임라인 조율하기 471

- 좋은 타임라인의 원칙 472
- 버그가 있습니다! 473
- 코드가 어떻게 바뀌었나요 475
- 액션을 확인하기: 단계 1 476
- 모든 액션을 그리기: 단계 2 477
- 다이어그램 단순화하기: 단계 3 481
- 실행 가능한 순서 분석하기 483
- 왜 지금 타임라인이 더 빠를까요? 484
- 모든 병렬 콜백 기다리기 486
- 타임라인을 나누기 위한 동시성 기본형 487
- 코드에 Cut() 적용하기 489
- 불확실한 순서 분석하기 491
- 병렬 실행 분석 492
- 여러 번 클릭하는 경우 분석 493
- 딱 한 번만 호출하는 기본형 500
- 암묵적 시간 모델 vs 명시적 시간 모델 502
- 요약: 타임라인 사용하기 507
- 결론 508

### CHAPTER 18 반응형 아키텍처와 어니언 아키텍처 509

- 두 아키텍처 패턴은 독립적입니다 510
- 변경에 대한 원인과 효과가 강력하게 결합 511
- 반응형 아키텍처는 무엇인가요? 512
- 반응형 아키텍처의 절충점 513
- 셀은 일급 상태입니다 514
- ValueCell을 반응형으로 만들 수 있습니다 515
- 셀이 바뀔 때 배송 아이콘을 갱신할 수 있습니다 516
- FormulaCell은 파생된 값을 계산합니다 517
- 함수형 프로그래밍과 변경 가능한 상태 518
- 반응형 아키텍처가 시스템을 어떻게 바꿨나요 519
- 원인과 효과가 결합한 것을 분리합니다 520
- 결합의 분리는 원인과 효과의 중심을 관리합니다 521
- 여러 단계를 파이프라인으로 처리합니다 522
- 타임라인이 유연해집니다 523
- 또 다른 아키텍처 패턴 526
- 어니언 아키텍처는 무엇인가요? 527
- 다시 보기: 액션과 계산, 데이터 528
- 다시 보기: 계층형 설계 529
- 전통적인 계층형 아키텍처 530
- 함수형 아키텍처 531
- 변경과 재사용이 쉬워야 합니다 532
- 도메인 규칙은 도메인 용어를 사용합니다 535
- 가독성을 따져 봐야 합니다 536
- 결론 539

### CHAPTER 19 함수형 프로그래밍 여행에 앞서 541

- 마지막 장의 계획 542
- 전문가의 기술을 배웠습니다 543
- 꼭 기억해야 할 것 544
- 시간에 따른 기술과 열정의 변화 545
- 투 트랙으로 마스터가 되기 546
- 샌드박스: 사이드 프로젝트를 시작하세요 547
- 샌드박스: 연습 문제로 훈련하기 548
- 제품: 오늘 당장 버그를 없애 보세요 549
- 제품: 설계를 하나씩 개선하세요 549
- 인기 있는 함수형 프로그래밍 언어 550
- 일자리가 가장 많은 함수형 언어 552
- 사용할 수 있는 플랫폼별 함수형 언어 552
- 배울 수 있는 것에 따라 나눈 함수형 언어 553
- 수학적 지식을 얻기 554
- 더 읽을거리 555
- 결론 556
