# Five Lines of Code

## 01장 리팩터링하기

- 높은 품질의 코드가 가지는 장점
  - 유지관리 비용을 절감한다.
  - 오류를 줄인다.
  - 개발자의 만족도를 향상시킨다.
- 높은 품질의 코드를 만드는 방법: 리팩터링
- 그럼에도 사람들은 리팩토링을 잘 하지 않는다.
  - 코드 스멜을 찾아내거나, 단위 테스트를 가지고 리팩터링을 하는 것은 **어렵다**.
- 리팩터링을 위한 일반적인 요건
  - 스킬
    - 어떤 코드가 문제가 될 수 있고, 이를 개선 할 수 있는지 알아야 한다. (코드 스멜)
      - 이는 습득하기 어려운 스킬이다.
  - 문화
    - 리팩터링에 들이는 시간을 용인하고, 권장하는 문화가 필요하다.
    - 일반적으로 레드-그린-리팩터링 사이클을 따른다.
      - 하지만 이 케이스는 레거시 시스템에 대한 리팩터링에 적합하지 않다.
  - 도구
    - 우리의 작업이 안전하다는것을 보장할 무언가가 필요하다.
    - 일반적으로 **자동화된 테스트**를 사용한다.

### 1.1 리팩터링이란 무엇인가?

- 리팩터링의 가장 간단한 정의
  - 기능을 변경하지 않고 코드를 변경하는 것
- 리팩터링의 목적
  - 좋은 코드를 만들기 위함.
    - 좋은 코드란?
      - 의도한 대로 동작하고
      - 사람이 읽기 쉬우며
      - 유지보수가 용이한 코드

- 예제

  ```ts
  // before
  return pow(base, exp / 2) * pow(base, exp / 2);

  // after
  let result = pow(base, exp / 2);
  return result * result;
  ```

### 1.2 스킬: 무엇을 리팩터링할 것인가?

- 앞서 다루었듯, 코드스멜을 찾아내는것은 어렵다.
- 따라서 이 책에서는 정형화된, 쉽게 인식하고 적용 할 수 있는 규칙을 제시하고자 함.

#### 1.2.1 코드 스멜의 예

> 함수는 한 가지 작업을 수행해야 한다.

- 굉장히 유명한 지침이지만, 판단이 어렵다.
- 아래의 예시는 과연 하나의 작업을 수행하는가?

```ts
let result = pow(base, exp / 2);
return result * result;
```

  - 이 코드는 나누고, 제곱한 뒤, 곱하는 세 가지 작업을 수행하는 것인가?
  - 아니면 결과적으로 하나의 값을 얻고, 상태를 변화시키지 않으므로 한가지 작업인가?

#### 1.2.2 규칙의 예

> 다섯 줄 제한

- 이 규칙은, 자전거의 보조바퀴와 같다. 도움을 줄 수 있지만 필수는 아니고, 방해가 될 수도 있다.
  - 항상 지켜야 하는것은 아니다.
  - 그러나 적용한다면, 코드의 품질을 높이는 데에 도움이 될 수 있다.
  - 하지만 반대로 이 규칙을 지키지 않는다고 해서 나쁜 코드를 작성하는 것은 아니다.

### 1.3 문화: 리팩터링은 언제 할까?

> 리팩터링은 샤워 하는 것과 같습니다. - 켄트 벡

- 리팩터링은 일상적인 활동이어야 한다.
- 따라서 일반적인 '레드-그린-리팩터' 사이클을 좀 더 개선한 방법을 권장한다.
- 레거시 환경에서의 리팩터링을 위한 6단계 절차
  1. 탐색(Explore): 일반적으로 어떤 기능이 정말로 오래 활용될지 알 수 없다. 따라서 우선은 신속하게 구현하고 니즈를 파악하는 것이 우선이다.
  2. 명세화(Specify): 필요한 기능을 알게되면 이를 구체적으로 명세한다. 최적의 경우는 이것이 테스트 케이스가 된다.
  3. 구현(Implement): 명세화된 기능을 구현한다.
  4. 테스트(Test): 코드가 2단계에서 명세화된대로 동작하는지 확인한다.
  5. 리팩터링(Refactor): 코드를 다른 사람(미래의 자신을 포함)에게 전달하기 전에, 작업이 용이한 코드로 변경한다.
  6. 전달(Deliver): PR, Push 등을 통해 코드를 전달한다.

- 위 절차에서 5. 리팩터링 단계를 확대하면 아래와 같다.
  - ![alt text](images/refactoring_procedure.png)

#### 1.3.1 레거시 시스템에서의 리팩터링

> 우선 변경하기 쉽게 만든 후 변경하라. - 켄트 벡

- 마치 요리를 하기 전, 식재료를 준비하는 것과 같다.

#### 1.3.2 언제 리팩터링을 하지 말아야 할까?

- 리팩터링은 굉장히 비싼 작업이다.
- 따라서, 리팩터링이 불필요한 세 가지 경우가 있다.
  1. 일회성 코드(스파이크)
  2. 폐기되기 직전, 유지보수 모드인 코드
  3. 임베디드 시스템이나 물리엔진 등 '엄격한 성능 요구사항'이 있는 코드

### 1.4 도구: (안전한) 리팩터링 방법

- 안전한 리팩터링을 위해 의존하는 도구들
  - (이 책에서 다루는)레시피처럼 상세하고 단계별로 구조화된 리팩토링 패턴
  - 버전관리(Git)
  - 컴파일러
  - (+) IDE

### 1.5 시작하는 데 필요한 도구

#### 1.5.1 프로그래밍 언어: 타입스크립트

- TS 로 선택한 이유는, 완전한 비 객체지향 설계부터 객체지향 설계까지 다양한 패러다임을 지원하기 때문임.
- 또한 다른 언어를 사용하는 대부분의 개발자들이 쉽게 읽고 이해 할 수 있음.

#### 1.5.2 편집기: 비주얼 스튜디오 코드

#### 1.5.3 버전 관리: Git

### 1.6 핵심 예제: 2D 퍼즐 게임

- `git clone https://github.com/wikibook/five-lines`

#### 1.6.1 연습만이 살 길이다: 두 번째 코드베이스

- `git clone https://github.com/wikibook/bomb-guy`

### 1.7 실제 환경에서 소프트웨어에 대한 주의사항 요약

## 02장 리팩터링 깊게 들여다보기

### 2.1 가독성 및 유지보수성 향상

- 리팩터링의 목적
  - 코드가 하는 일을 변경하지 않는다.
  - 더 나은 코드를 만든다.

#### 2.1.1 코드 개선

##### 가독성

- 코드가 하는 일을 파악하기 쉽다.
- 아래와 같은 다양한 방법으로 얻을 수 있다.
  - 코딩 컨벤션 사용
  - 주석 작성
  - 변수명, 메서드명, 클래스 및 파일명
  - 공백, 줄바꿈 사용 등
- 예시

  ```ts
  // before - 읽기 힘든 코드의 예
  function checkValue(str: boolean) { //   <-- 불명확한 메서드명
    // 값 체크  <-- 동어 반복적인 주석

    if (str !== false) //   <-- 이중부정
      // 반환   <-- 동어 반복적인 주석
      return true;
    
    else; // 그렇지 않으면    <-- 놓치기 쉬운 세미콜론(;), 불필요한 주석
      return str; //    <-- 오해의 소지가 있는 들여쓰기
  }

  // after - 가독성을 개선한 동일한 코드
  function isTrue(bool: boolean) {
    if (bool) {
      return true;
    } else {
      return false;
    }
  }
  ```

##### 유지보수성

- 버그수정이나 기능추가시에는 일부 기능변경이 불가피하다.
- 이때, 기능변경을 위한 새 코드를 어디에 추가할지 '후보 위치'를 찾는 과정이 필요하다.
- 유지보수성은 이러한 후보 위치가 얼마나 많은지에 따라 결정된다.
  - 명확한 코드일수록 후보 위치가 적고, 그만큼 더 적은 코드를 확인해야 한다.

- 일부 취약한 시스템은 약간의 변동에도 전체 시스템에 문제가 생길 수 있다.
- 일반적으로 이러한 취약성(fragile)은 전역 상태에서 기인한다.
  - 특히 명시적으로 확인하지는 않으나 당연하게 여겨지는 '불변속성'에서 문제가 발생하는 경우가 많다.
  - 이러한 불변속성과 이로인해 영향받는 코드는 서로 가까이 위치해야 한다.

#### 2.1.2 코드가 하는 일을 바꾸지 않고 유지보수하기

### 2.2 속도, 유연성 및 안정성 확보

#### 2.2.1 상속보다는 컴포지션 사용

#### 2.2.2 수정이 아니라 추가로 코드를 변경

### 2.3 리팩터링과 일상 업무

#### 2.3.1 학습 방법으로서의 리팩터링

### 2.4 소프트웨어 분야에서 '도메인'정의하기

### 요약

## 03장 긴 코드 조각내기

## 04장 타입 코드 처리하기

## 05장 유사한 코드 융합하기

## 06장 데이터 보호

## 07장 컴파일러와의 협업

## 08장 주석 자제하기

## 09장 코드 삭제의 미학

## 10장 코드 추가에 대한 두려움 떨쳐내기

## 11장 코드 구조 따르기

## 12장 최적화 및 일반화 회피

## 13장 나쁜 코드를 식별 가능하게 만들기

## 14장 마무리

## 부록A 실습을 위한 도구 설치
