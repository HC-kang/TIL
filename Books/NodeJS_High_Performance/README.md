# NodeJS 하이 퍼포먼스

## 1장 소개 및 컴포지션

- 애플리케이션 컴포지션
  - 애플리케이션의 유지, 보수, 개발, 이해가 용이하도록 애플리케이션을 작은 단위로 나누는 것
  - 이를 통해 성능을 향상시키고, 테스트와 유지보수를 쉽게 할 수 있다.

- 코드 나누기
  - 재사용하지 못하더라도 코드를 나누는 것이 좋다.
  - 코드를 나누면 코드를 이해하기 쉬워지고, 테스트하기 쉬워진다.
  - 5KB이상의 파일은 나누는 것이 좋다.
  - 다른 개발자가 약 5분 안에 이해할 수 있는 코드로 작성해야 한다.

## 2장 개발 패턴

### 패턴이란?

- 일반적인 프로그래밍 문제들에 대한 재사용 가능한 해결책
- 특정한 사용사례에 대해 최적화, 검증되어있다.
- 특정한 패러다임을 공유하므로 다른 개발자들과 소통하기 쉽다.
- 각각의 장단점이 있으므로, 잘못된 사용은 성능을 떨어뜨릴 수 있다.

### 안티패턴?

- 특정 패턴이라기보다는 일반적인 오류라고 할 수 있다.
- 예시
  - 반복
  - 최고라고 생각하는 새로운 솔루션을 직접 만들기: 바퀴를 다시 발명하지 말자.
  - 오류 기반의 코드개발: `일반적인 오류`를 처리하자. 모든 오류를 처리하는 코드는 불필요하고 유지보수하기 어렵다. 기록만 해 두자.
  - 시행착오를 통한 프로그래밍: 개발을 운의 문제로 끌어내지 말자.

### NodeJS 패턴

- 이벤트 기반 패턴
- 이벤트 스트림 패턴

### 패턴의 유형

- 아키텍처적 패턴
  - 프론트 컨트롤러 패턴
    - 모든 요청을 하나의 컨트롤러로 보내는 패턴
  - MVC 패턴
    - 모델, 뷰, 컨트롤러로 나누어 개발하는 패턴
    - 유사한 패턴
      - MVVM 패턴
      - MVA 패턴
  - 액티브 레코드 패턴
    - 데이터베이스의 테이블을 객체로 나타내는 패턴
    - 애플리케이션과 데이터 사이의 추상화 계층이 성능에 영향을 미칠 수 있다.
    - 데이터 객체와 데이터베이스 사이의 강결합으로 테스트하기 어렵다.
  - 서비스 로케이터 패턴
    - 서비스의 접근을 추상화하는 패턴
    - 서비스의 위치를 변경하더라도 코드를 변경하지 않아도 된다.
    - 다만 단일장애점이 될 수 있다.
  - 이벤트 주도 패턴
    - 이벤트를 통해 통신하는 패턴
    - 느슨한 결합을 통해 유연한 시스템을 만들 수 있다.
    - 확장 및 유지보수가 쉽다.

- 생성 패턴
  - 팩토리 메서드 패턴
  - 지연 초기화 패턴
  - 싱글턴 패턴
  - 빌더 패턴
  - 객체 풀 패턴
    - 객체를 미리 생성해 두고, 필요할 때 꺼내 쓰는 패턴

- 구조 패턴
  - 어댑터 패턴
  - 컴포지트 패턴
  - 데코레이터 패턴
  - 퍼사드 패턴
  - 프록시 패턴

- 행동 패턴
  - 중재자 패턴
  - 템플릿 메서드 패턴
  - 옵저버 패턴

### 이벤트 주도 아키텍처

## 3장 가비지 컬렉션

## 4장 CPU 프로파일링

## 5장 데이터와 캐시

## 6장 테스트, 벤치마킹, 분석

## 7장 병목 현상
