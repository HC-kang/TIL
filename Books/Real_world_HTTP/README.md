# 리얼 월드 HTTP

## Chapter 01 HTTP/1.0의 신택스: 기본이 되는 네 가지 요소

- `메서드`와 `경로`
- `헤더`
- `바디`
- `스테이터스 코드`

### 1.1 HTTP의 역사

- 1990년: HTTP/0.9
- 1996년: HTTP/1.0
- 1997년: HTTP/1.1
- 2005년: HTTP/2

- HTTP/0.9
  - HTML 문서를 가져오기 위한, GET 메서드만 지원하는 최소한의 프로토콜
  - 차후 폼 전송, 정보 갱신, 채팅기능 구현 등에 활용되며 확장되었음.
  - 사실상 0.9라는 명명은 HTTP/1.0 등장 이후 구별하기 위해 명명되었음.

#### 1.1.1 테스트 에코 서버 실행

- 생략: `./examples/test-echo-server` 참조

#### 1.1.2 도커 설치

- 생략

### 1.2 HTTP/0.9로 할 수 있는 것을 시험하다

- HTTP/0.9는 현재 프로토콜과 호환성이 없으므로(하위 호환성이 없음) HTTP/1.0을 사용하여 테스트 진행

```sh
# curl 실행 예시
$ curl --http1.0 http://localhost:18888/greeting
<html><boxy>hello</boxy></html>

# 서버측 로그
GET /greeting HTTP/1.0
Host: localhost:18888
Connection: close
Accept: */*
User-Agent: curl/7.52.1
```

### 1.3 HTTP/0.9에서 1.0으로의 여정

- HTTP/0.9의 한계
  - 하나의 문서만 전송 가능
  - HTML 문서만 전송 가능
    - 콘텐츠의 형식을 서버가 전달할 수 없음
  - 클라이언트는 검색만 가능
  - 새로운 데이터를 추가하거나 갱신, 삭제하는 기능이 없음
  - 서버가 요청을 올바르게 응답했는지 확인할 수 있는 방법이 없음


### 1.4 HTTP의 조상(1) 전자메일

- HTTP 헤더는 현재 요청과 응답에서 모두 사용됨.
  - 이를 통해 여러 가지 유용한 정보를 전달할 수 있음.
  - 이러한 헤더는 전자메일 시스템에서 유래되었음.

- 메일의 원시 정보

    ```
    Delivered-To: some@email.com
    (생략)
    MIME-Version: 1.0
    Received: by 10.176.69.212 with HTTP; Wed, 6 Apr 2016 06:26:27 -0700 (PDT)
    From: "Some Name" <email@email.com>
    Date: Wed, 6 Apr 2016 15:26:27 +0200
    Message-ID: <CAE5P5=someId@mail.gmail.com>
    Subject: Some Subject
    To: some@email.com
    Content-Type: text/plain; charset=UTF-8

    hello
    ```

    - 헤더는 `:`로 구분된 `키:값`의 형태로 구성됨.
    - 한 줄에 하나의 헤더를 작성함.
    - 헤더의 끝은, 빈 줄로 본문과 구분됨.
    - 대소문자를 구분하지 않음.
    - 파싱이 쉽도록 정규화되어있음.
    - 즉, 헤더에는 본문 이외의 모든 정보가 포함되어 있음.
      - 추가 정보, 지시, 명령, 당부 등

#### 1.4.1 헤더의 전송

- curl을 통해서도 헤더를 전송할 수 있음

  ```sh
  $ curl --http1.0 -H "X-Test: Hello" http://localhost:18888
  ```

- RFC에서는, 같은 헤더를 여러 번 보내는 것도 허용하고있음.
  - 이러한 경우 서버의 구현에 따라 배열이나 구분자를 사용한 문자열등으로 처리됨.

#### 1.4.2 헤더 수신

- 생략

#### 1.4.3 MIME 타입

- MIME(Multipurpose Internet Mail Extensions) 타입은, 전자메일 시스템에서 사용되는 콘텐츠 타입을 정의하는 표준
  - `Content-Type` 헤더를 통해 전달됨.
    - 예시
      - `Content-Type: text/plain; charset=UTF-8`
      - `Content-Type: text/html; charset=UTF-8`
      - `Content-Type: image/jpeg`
      - `Content-Type: application/json`
      - `Content-Type: application/octet-stream`
      - `Content-Type: application/x-www-form-urlencoded`

#### 1.4.4 Content-Type과 보안

- `Content-Type` 헤더는, 클라이언트가 콘텐츠를 올바르게 해석할 수 있도록 도와줌.

#### 1.4.5 전자메일과의 차이

- `헤더`와 `본문`으로 구성되어있다.
- HTTP요청에서는 선두에 메서드, 패스, 상태코드가 추가된다.
- 결과적으로, HTTP는 전자메일의 확장이고, HTTP통신은 고속으로 전자메일이 왕복하는것이라고 할 수 있다.

### 1.5 HTTP의 조상(2) 뉴스 그룹

- 과거에는 뉴스 그룹, 혹은 유즈넷으로 불리우는 전자게시판이 있었음.
  - 이러한 게시판은 분산 아키텍처로 구성되어있었으며, 클라이언트-서버 혹은 마스터-슬레이브 통신을 위해 NNTP(Network News Transfer Protocol)를 사용하였음.
- HTTP는 이러한 NNTP로부터 메서드와 스테이터스 코드를 차용하였음.

#### 1.5.1 메서드

- 뉴스 그룹에는 아래와 같은 메서드가 존재하였음
  - `LIST`: 그룹 목록을 가져옴
  - `HEAD`: 본문을 제외한 헤더만 가져옴
  - `BODY`: 본문만 가져옴
  - `POST`: 새로운 글을 작성함

- HTTP는 이러한 메서드를 차용하되, 파일시스템과 같은 철학을 공유함.
  - `GET`: 서버에 헤더와 콘텐츠 요청
  - `HEAD`: 서버에 헤더만 요청
  - `POST`: 새로운 문서 투고

- 자바스크립트의 XML HttpRequest가 추가되기 이전까지는 `GET`과 `POST`만 사용되었음.
- 이후, 위 메서드 이외에도 많은 메서드가 추가되고 삭제되었음.

#### 1.5.2 스테이터스 코드

- 100번대: 처리가 게속됨. 특수한 경우에 대한 응답. 정보의 전달을 위한 것.
- 200번대: 성공. 요청이 성공적으로 처리되었음.
- 300번대: 리디렉트. 추가 동작이 필요함. 요청한 리소스가 다른 위치에 있음.
- 400번대: 클라이언트 오류. 요청에 오류가 있음.
- 500번대: 서버 오류. 서버가 유효한 요청을 처리하지 못함.

### 1.6 리디렉트

- 리디렉트는, 클라이언트가 요청한 리소스가 다른 위치에 있을 때 사용됨.
  - 이는, 서버가 클라이언트에게 새로운 URL을 알려주는 것.
  - 이러한 리디렉트는 `Location` 헤더를 통해 전달됨.
  - 리디렉트의 다섯가지 종류
    
    |스테이터스 코드|메서드 변경|영구적/일시적|캐시|설명|
    |---|---|---|---|---|
    |301 Moved Permanently|O|영구적|O|요청한 리소스가 새로운 URL에 있음. 웹사이트 이전, HTTP와 HTTPS간 리디렉트 등에 사용됨.|
    |302 Found|O|일시적|지시에 따름|요청한 리소스가 일시적으로 다른 URL에 있음. 모바일 페이지로 리디렉트, 쿠키를 사용한 세션 관리 등에 사용됨.|
    |303 See Other|허용|영구적|X|로그인 후 리디렉트, 폼 전송 후 리디렉트 등에 사용됨.|
    |307 Temporary Redirect| |지시에 따름|RFC 7231에 추가됨.|
    |308 Permanent Redirect| |영구적|O|RFC 7538에 추가됨.|

  - 301/308은 모두 영구적 이동을 의미하며, 검색엔진도 이를 인지함. 구글에서는 301을 권장.
  - 302/307은 모두 일시적 이동을 의미함.
  - 303은 요청한 페이지에서 반환할 콘텐츠가 없거나, 별도의 페이지를 표시하고자 할 때 사용됨.

### 1.7 URL

- URI, URL, URN의 관계
  - URI(Uniform Resource Identifier): 리소스에 대한 식별자. URL과 URN을 포함함.
    - URL(Uniform Resource Locator): 웹 개발에서의 대부분의 URI는 URL임. 리소스의 위치를 나타냄.
    - URN(Uniform Resource Name): 웹 시스템에서는 거의 사용되지 않음.

#### 1.7.1 URL의 구조

- URL은 `scheme://user:password@host:port/path?query#fragment`의 형태로 구성됨.
  - `scheme`: 프로토콜. `http`, `https`, `ftp`, `file` 등이 있음.
  - `user:password`: 인증정보. `user`만 있을 수도 있고, 둘 다 없을 수도 있음.
  - `host`: 호스트명. 도메인명이나 IP주소가 올 수 있음. **실제로 통신하는 서버의 주소**
  - `port`: 포트번호. 생략될 수 있음.
  - `path`: 리소스의 경로. 파일명이나 디렉토리명이 올 수 있음.
  - `query`: 쿼리스트링. `?`로 시작하며, `&`로 구분됨.
  - `fragment`: 프래그먼트. `#`로 시작함.

- 예시
  - `http://www.oreilly.com/index.html/some/path?query=1#fragment`

- 우측으로 갈수록 정보가 구체화됨.
- 사람이 읽기 쉬운 형태로 URL을 작성하는 것이 좋음.

#### 1.7.2 URL과 국제화

- 퓨니코드(Punycode)를 사용하여 도메인명을 인코딩함.
  - 예시: `http://www.한글도메인.com` -> `https://xn--bj0bj3i97fq8o5lq.com`
    - `xn--`로 시작하는 문자열로 시작하면, 퓨니코드로 인코딩된 도메인명임.

### 1.8 바디

- HTTP/0.9
  - 요청에 바디가 없었음.
  - 응답의 경우에도 HTML콘텐츠 자체가 응답이었음.

- HTTP/1.0
  - 응답과 요청 모두에 헤더가 추가되었음.
  - 또한 요청에도 바디를 추가할 수 있게 되었음.
  - 따라서, 헤더와 바디의 구분자로 공백 라인을 사용함.
  - 예시

    ```http
    POST /path HTTP/1.0
    Content-Length: 11

    hello world
    ```

#### 1.8.1 GET 요청 시의 바디

- 일반적으로 GET 요청에는 바디를 `포함하지 않을 것으로 기대`함.
  - 하지만, HTTP/1.0에서는 GET 요청에도 바디를 포함할 수 있음.
  - 로이 필딩은, GET 요청에 바디를 포함할 수는 있지만, 서버는 이를 무시해야 한다고 말하고 있음.
    - 왜 이렇게 만들었는지 모르겠다.

- 다만, Body가 금지된 메서드가 있는데, `TRACE`메서드에서는 바디를 포함하면 안된다고 명시되어 있음.

### 1.9 마치며

- HTTP의 주요 구성요소
  - 메서드와 경로
  - 헤더
  - 바디
  - 스테이터스 코드

## Chapter 02 HTTP/1.0의 시맨틱스: 브라우저 기본 기능의 이면

### 2.1 단순한 폼 전송(x-www-form-urlencoded)

- 가장 간단한 형태의 POST 요청인 `application/x-www-form-urlencoded`를 사용한 폼 전송 방법
- 예시
  - HTML

    ```http
    <form method="POST"
      <input name="title">
      <input name="author">
      <input type="submit">
    </form>
    ```

  - CURL

    ```sh
    $ curl --http1.0 -d title="The Art of Community" -d author="Jono Bacon" http://localhost:18888
    ```

- 주의사항
  - `-d` 플래그를 사용하면, 문자열을 있는 그대로 연결함. 이 경우 문자열 내에 `&`와 `=`까지도 그대로 연결하므로, 주의가 필요함.
  - `--data-urlencode` 플래그를 사용하면, `&`와 `=`를 인코딩하여 전송함.

### 2.2 폼을 이용한 파일 전송

- HTML의 폼에서는 `multipart/form-data`를 사용하여 파일을 전송할 수 있음.
- 이 경우 `boundary`를 사용하여 각 파트를 구분함.
  - 브라우저마다 독자적인 형태로 구분자를 생성함.
- 예시

  ```http
  ------WebKitFormBoundary7MA4YWxkTrZu0gW
  Content-Disposition: form-data; name="title"

  The Art of Community
  ------WebKitFormBoundary7MA4YWxkTrZu0gW
  Content-Disposition: form-data; name="author"

  Jono Bacon
  ------WebKitFormBoundary7MA4YWxkTrZu0gW--
  ```

- 위와 같은 형식으로 `multipart/form-data`는 각 항목마다 추가적인 메타정보를 포함할 수 있음.
- `application/x-www-form-urlencoded`는 각 항목에 대해 여러 정보를 전송할 수 없어 파일 이름만 전송하게 되므로, 올바른 파일 전송을 할 수 없음.

### 2.3 폼을 이용한 리디렉트

- 이전 장에서, 300번대 스테이터스 코드를 사용한 리디렉트에 대해 다루었음.
- 그러나 이런 방법은 아래의 두 가지 한계가 있음.
  - URL의 길이제한(2048바이트)로 인해 GET요청으로 보낼 수 있는 데이터에 제한이 있음.
  - 데이터가 URL에 포함되므로, 전송 내용이 데이터 로그로 남을 수 있음.
- 이러한 이유로, HTML의 폼을 이용한 리다이렉트를 할 수 있음.

### 2.4 콘텐트 니고시에이션

- 하나의 요청 안에서, 서버와 클라이언트가 서로의 최고의 설정을 결정하는 것을 `콘텐트 네고시에이션`이라고 함.

  |요청 헤더|응답|네고시에이션 대상|
  |---|---|---|
  |Accept|Content-Type 헤더|MIME 타입|
  |Accept-Language|Content-Language 헤더 / html 태그|표시 언어|
  |Accept-Charset|Content-Type 헤더|문자셋|
  |Accept-Encoding|Content-Encoding 헤더|바디 압축 방식|

#### 2.4.1 파일 종류 결정

- 예시

  ```http
  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
  ```

    - `image/webp`: `q`값이 1.0이므로(기본값이 1.0), 서버가 이를 지원한다면 이를 사용함.
    - `*/*;q=0.8`: `q`값이 0.8이므로, webp를 지원하지 않는 경우에 사용됨.
- 만약 서로 지원하는 타입이 없다면, 서버는 `406 Not Acceptable`을 응답함.

#### 2.4.2 표시 언어 결정

- 예시

  ```http
  Accept-Language: en-US,en;q=0.8,ko;q=0.6
  ```

  - `en-US`: `q`값이 1.0이므로, 서버가 이를 지원한다면 이를 사용함.
  - `en;q=0.8`: `q`값이 0.8이므로, `en-US`를 지원하지 않는 경우에 사용됨.
  - `ko;q=0.6`: `q`값이 0.6이므로, `en`을 지원하지 않는 경우에 사용됨.

#### 2.4.3 문자셋 결정

- 생략

#### 2.4.4 압축을 이용한 통신속도 향상

- 일반적인 텍스트 파일의 경우 약 1/10의 크기로 압축될 수 있음.
- 반복이 많은 JSON과 같은 형태는 약 1/20의 크기로 압축될 수 있음.
- 압축 형태의 종류
  - `gzip`: 가장 많이 사용되는 압축 형태
  - `deflate`: `gzip`와 유사하나, `gzip`보다 압축률이 떨어짐.
  - `br`: `gzip`보다 더 좋은 압축률을 가짐.
- `identity`: 압축하지 않음을 의미함.

### 2.5 쿠키

- 쿠키는 서버가 클라이언트에게 전달하는 정보를 저장하는 방법
- 이를 통해 Stateless한 HTTP프로토콜에서 상태를 유지할 수 있음.
- 이러한 쿠키도 결국 HTTP 헤더의 일종임.  

#### 2.5.1 쿠키의 잘못된 사용법

- 영속성 문제
  - 쿠키는 클라이언트에 저장되므로, 클라이언트가 쿠키를 삭제하거나, 쿠키가 만료되면 서버에서는 이를 알 수 없음.
  - 따라서 쿠키를 데이터베이스 대용으로 사용하면 안됨.
  - 쿠키에는 사라지더라도 문제가 없는 정보만 저장해야 함.
- 용량 문제
  - 쿠키의 크기는 하나당 4KB로 제한되어 있음.
  - 또한 하나의 도메인당 20개, 총 300개의 쿠키를 저장할 수 있음.
  - 또한 쿠키는 매 요청마다 전송되므로, 쿠키의 크기가 클 경우 네트워크 트래픽이 증가하게 됨.
- 보안 문제
  - secure, httpOnly, SameSite 등의 속성을 사용하여 보안을 강화할 수 있음.
  - 그러나 쿠키는 사용자가 직접 접근 및 수정할 수 있으므로 보안에 취약함.

#### 2.5.2 쿠키에 제약을 주다

- `Domain`: 쿠키가 전송될 도메인을 지정함.
- `Path`: 쿠키가 전송될 경로를 지정함.
- `Secure`: HTTPS 프로토콜을 사용할 때에만 쿠키를 전송함.
- `HttpOnly`: 자바스크립트에서 쿠키에 접근할 수 없도록 함.
- `SameSite`: 같은 출처(Origin)으로만 쿠키를 전송함.

### 2.6 인증과 세션

#### 2.6.1 BASIC 인증과 Digest 인증

- BASIC 인증
  - 유저명과 패스워드를 Base64로 인코딩하여 전송함.
  - Base64는 암호화가 아니므로, 보안에 취약함.
  - SSL/TLS를 사용하지 않는 경우 보안에 취약함.
- Digest 인증
  - BASIC 인증의 보안성을 개선한 방식.
  - 패스워드를 해시화하여 전송함.
  - 그러나 매 요청마다 패스워드를 전송하고 해시화하기 때문에, 서버의 부하가 증가함.
- 두 방식의 문제점
  - 특정 패스 이하를 보호하는 방식으로, 최상위 경로에서 사용자 고유 정보를 노출 할 수 없음.
  - 매 요청마다 유저명과 패스워드를 전송해야 하므로, 서버의 부하가 증가함.
  - 명시적인 로그오프가 없음.
  - 로그인한 단말을 식별 할 수 없음.

#### 2.6.2 쿠키를 사용한 세션 관리

- 위에서 언급한 문제로 인해, 현재는 폼 전송을 통한 로그인과 쿠키를 사용한 세션 관리를 사용함.
- 이 경우 ID와 PW를 직접 전송하므로, SSL/TLS가 필수적임.

#### 2.6.3 서명된 쿠키를 이용한 세션 데이터 저장

- 생략

### 2.7 프록시

- 프록시는 클라이언트와 서버 사이에 위치한 중계 서버임.
- 프록시와 게이트웨이의 비교
  - 프록시
    - 통신의 내용을 이해한다.
    - 필요에 따라 콘텐츠를 수정하거나, 서버 대신 응답한다.
  - 게이트웨이
    - 통신의 내용을 이해하지 못한다.
    - 내용의 수정이 불가능하다.
    - 클라이언트는 게이트웨이의 존재를 알면 안된다.

### 2.8 캐시

- 나날이 증가하는 웹 트래픽을 줄이기 위해 캐시의 개념이 등장하였음.
- 콘텐츠가 변경되지 않았을 때, 파일을 재사용 할 수 있음.
- 기본적으로 `GET`, `HEAD`요청 이외에는 캐시되지 않음.

#### 2.8.1 갱신 일자에 따른 캐시

- `Last-Modified`: 콘텐츠가 마지막으로 수정된 날짜를 전달함.
- 예시
  - 응답 헤더

    ```http
    Last-Modified: Wed, 06 Apr 2016 15:26:27 GMT
    ```
  
  - 요청 헤더

    ```http
    If-Modified-Since: Wed, 06 Apr 2016 15:26:27 GMT
    ```

- 웹 브라우저가 다시 동일한 요청을 할 때, 브라우저는 이 정보를 `If-Modified-Since` 헤더에 담아 서버에 전달함.
- 콘텐츠가 해당 시간 이후로 수정되었다면 `200 OK`를 반환하며 새로운 콘텐츠를 전달함.
- 콘텐츠가 해당 시간 이후로 수정되지 않았다면 `304 Not Modified`를 반환하며 바디를 응답에 포함하지 않음.
- 그러나 결국은 서버와 클라이언트 간의 통신이 발생하므로, 갱신일자에 따른 캐시는 한계가 있음.

#### 2.8.2 Expires

- `Expires` 헤더를 사용하면 위와 같은 요청 자체도 발생시키지 않을 수 있음.
- 클라이언트는 `Expires` 헤더를 통해 콘텐츠의 만료일을 알 수 있음.
  - 따라서 만료 이전에는 캐시된 콘텐츠를 사용하고, 요청 자체를 발생시키지 않음.
- 절대 변하지 않는 컨텐츠라도, 최대 1년까지의 캐시 수명을 정하는 것이 RFC2068의 권장사항임.
- 예시

  ```http
  Expires: Wed, 06 Apr 2016 15:26:27 GMT
  ```

#### 2.8.3 Pragma: no-cache

- 이는 프록시 서버에 대한 클라이언트의 지시임.
- `no-cache`는 프록시 서버에게, 변경사항이 없더라도 캐시된 콘텐츠를 사용하지 말라는 지시임.

#### 2.8.4 ETag 추가

- 컨텐츠가 다양해지고 유즈케이스가 증가함에 따라, 단순히 시간 비교만으로는 캐시를 관리하기 어려워짐.
  - 예를 들어, 동일한 콘텐츠라도 사용자의 상태별로 다른 콘텐츠를 전달해야 하는 경우가 있음.
    - 로그인, 구매여부 등
- 이러한 문제를 해결하기 위해 ETag가 등장하였음.
- `ETag`는 콘텐츠의 해시값을 전달함.
  - 이를 통해 클라이언트는 콘텐츠의 변경 여부를 확인할 수 있음.
- 예시
  - 응답 헤더

    ```http
    ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
    ```

  - 요청 헤더

    ```http
    If-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"
    ```

#### 2.8.5 Cache-Control(1)

- `Cache-Control` 서버는 헤더를 사용해서 클라이언트에 캐시에 대한 지시를 전달할 수 있음.
- 종류
  - `public`: 프록시 서버에 의해 캐시될 수 있음. 복수의 사용자간에 캐시를 공유할 수 있음.
  - `private`: 클라이언트에 의해 캐시될 수 있음. 복수의 사용자간에 캐시를 공유할 수 없음.
  - `max-age=n`: 캐시의 유효기간을 초 단위로 지정하며, 이 시간동안 서버에 문의하지 않고 캐시를 사용함. 이후로는 서버에 문의하고 `304 Not Modified`를 반환받는 경우에만 캐시를 사용함.
  - `s-maxage=n`: max-age와 유사하나, 공유 캐시에 대한 지시임.
  - `no-cache`: 캐시가 유효한지 매 번 문의함. `max-age=0`과 거의 동일함.
    - `Pragma: no-cache`와는 다르게 `Expires`만 사용하지 않는것임.
  - `no-store`: 캐시를 사용하지 않음.

#### 2.8.6 Cache-Control(2)

- 클라이언트 측에서 `Cache-Control` 헤더를 사용하여, 프록시 서버에 대한 지시를 전달할 수 있음.
- 종류
  - `no-cache`: `Pragma: no-cache`와 동일함.
  - `no-store`: 응답의 `no-store`와 동일함. 프록시 서버에게 캐시를 삭제하도록 요청함.
  - `max-age`: 프록시에 저장된 캐시가 최초 저장 이후 몇 초 동안 유효한지 지정함.
  - `max-stale`: 캐시가 만료되었더라도, 몇 초 동안 사용할 수 있는지 지정함.
  - `min-fresh`: 캐시가 만료되기 전에 몇 초 동안 사용할 수 있는지 지정함.
  - `no-transform`: 프록시 서버가 콘텐츠를 변환하지 않도록 지시함.
  - `only-if-cached`: 캐시가 있을 때에만 캐시된 콘텐츠를 사용하도록 지시함. 캐시가 없을 경우 `504 Gateway Timeout`을 반환함. 

- 서버 측에서 프록시에게 지시하는 경우도 있음.
  - `no-transform`: 프록시 서버가 콘텐츠를 변환하지 않도록 지시함.
  - `must-revalidate`: 프록시가 서버에 문의할 때, 응답을 받지 못하면 프록시가 클라이언트에게 `504 Gateway Timeout`을 반환함.

#### 2.8.7 Vary

- 같은 URL이라도, 클라이언트의 요청에 따라 다른 콘텐츠를 전달해야 하는 경우가 있음.
  - Language, User-Agent 등

### 2.9 리퍼러(Referer)

- 사용자가 어느 경로에서 링크를 클릭했는지를 알 수 있음.
- 철자는 오타이지만, 하위 호환성을 위해 이러한 철자가 사용되고 있음.
- 북마크 등을 통해 접근한 경우에는 `Referer` 헤더가 전송되지 않거나, `about:blank`가 전송됨.
- 이 헤더를 통해, 검색엔진 등에서 유입된 키워드를 파악할 수 있음.
  - 대체로 검색엔진은 검색결과를 `?q=검색어`와 같은 형태로 전달하기 때문임.
- 리퍼러 정책 활용 방법
  - `Referrer-Policy` 헤더
  - `<meta name="referrer" content="설정값">`
  - `<a>태그 등 몇가지 요소의 referrerpolicy 속성 및 rel="noreferrer" 속성`
- 설정값
  - `no-referrer`: 리퍼러를 전송하지 않음.
  - `no-referrer-when-downgrade`: HTTPS -> HTTP로 이동할 때에는 리퍼러를 전송하지 않음.
  - `same-origin`: 같은 출처로만 리퍼러를 전송함.
  - `origin`: 같은 출처로만 리퍼러를 전송함. 하지만, 경로와 쿼리스트링은 제외함.
  - `strict-origin`: `origin`과 동일하나, HTTP -> HTTPS로 이동할 때에는 리퍼러를 전송하지 않음.
  - `origin-when-cross-origin`: 같은 도메인 내에서는 완전한 URL을 전송하나, 다른 도메인으로 이동할 때에는 도메인만 전송함.
  - `strict-origin-when-cross-origin`: `origin-when-cross-origin`과 동일하나, HTTP -> HTTPS로 이동할 때에는 리퍼러를 전송하지 않음.
  - `unsafe-url`: 모든 URL을 전송함.

### 2.10 검색 엔진용 콘텐츠 접근 제어

- `robot.txt`
- `sitemap.xml`

#### 2.10.1 robots.txt

- 검색엔진은 `robots.txt`를 통해 사이트의 콘텐츠를 수집할 수 있는지 여부를 확인함.
- 강제성은 없으나, 대부분의 검색엔진은 이를 준수함.
- 일종의 블랙리스트임.

#### 2.10.2 robots.txt와 재판 결과

- 생략

#### 2.10.3 사이트맵

- 사이트맵은 검색엔진에게 사이트의 구조를 알려주는 역할을 함.
- 일종의 화이트리스트임.

### 2.11 마치며

- 생략
