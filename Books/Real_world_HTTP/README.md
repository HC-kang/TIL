# 리얼 월드 HTTP

## Chapter 01 HTTP/1.0의 신택스: 기본이 되는 네 가지 요소

- `메서드`와 `경로`
- `헤더`
- `바디`
- `스테이터스 코드`

### 1.1 HTTP의 역사

- 1990년: HTTP/0.9
- 1996년: HTTP/1.0
- 1997년: HTTP/1.1
- 2005년: HTTP/2

- HTTP/0.9
  - HTML 문서를 가져오기 위한, GET 메서드만 지원하는 최소한의 프로토콜
  - 차후 폼 전송, 정보 갱신, 채팅기능 구현 등에 활용되며 확장되었음.
  - 사실상 0.9라는 명명은 HTTP/1.0 등장 이후 구별하기 위해 명명되었음.

#### 1.1.1 테스트 에코 서버 실행

- 생략: `./examples/test-echo-server` 참조

#### 1.1.2 도커 설치

- 생략

### 1.2 HTTP/0.9로 할 수 있는 것을 시험하다

- HTTP/0.9는 현재 프로토콜과 호환성이 없으므로(하위 호환성이 없음) HTTP/1.0을 사용하여 테스트 진행

```sh
# curl 실행 예시
$ curl --http1.0 http://localhost:18888/greeting
<html><boxy>hello</boxy></html>

# 서버측 로그
GET /greeting HTTP/1.0
Host: localhost:18888
Connection: close
Accept: */*
User-Agent: curl/7.52.1
```

### 1.3 HTTP/0.9에서 1.0으로의 여정

- HTTP/0.9의 한계
  - 하나의 문서만 전송 가능
  - HTML 문서만 전송 가능
    - 콘텐츠의 형식을 서버가 전달할 수 없음
  - 클라이언트는 검색만 가능
  - 새로운 데이터를 추가하거나 갱신, 삭제하는 기능이 없음
  - 서버가 요청을 올바르게 응답했는지 확인할 수 있는 방법이 없음


### 1.4 HTTP의 조상(1) 전자메일

- HTTP 헤더는 현재 요청과 응답에서 모두 사용됨.
  - 이를 통해 여러 가지 유용한 정보를 전달할 수 있음.
  - 이러한 헤더는 전자메일 시스템에서 유래되었음.

- 메일의 원시 정보

    ```
    Delivered-To: some@email.com
    (생략)
    MIME-Version: 1.0
    Received: by 10.176.69.212 with HTTP; Wed, 6 Apr 2016 06:26:27 -0700 (PDT)
    From: "Some Name" <email@email.com>
    Date: Wed, 6 Apr 2016 15:26:27 +0200
    Message-ID: <CAE5P5=someId@mail.gmail.com>
    Subject: Some Subject
    To: some@email.com
    Content-Type: text/plain; charset=UTF-8

    hello
    ```

    - 헤더는 `:`로 구분된 `키:값`의 형태로 구성됨.
    - 한 줄에 하나의 헤더를 작성함.
    - 헤더의 끝은, 빈 줄로 본문과 구분됨.
    - 대소문자를 구분하지 않음.
    - 파싱이 쉽도록 정규화되어있음.
    - 즉, 헤더에는 본문 이외의 모든 정보가 포함되어 있음.
      - 추가 정보, 지시, 명령, 당부 등

#### 1.4.1 헤더의 전송

- curl을 통해서도 헤더를 전송할 수 있음

  ```sh
  $ curl --http1.0 -H "X-Test: Hello" http://localhost:18888
  ```

- RFC에서는, 같은 헤더를 여러 번 보내는 것도 허용하고있음.
  - 이러한 경우 서버의 구현에 따라 배열이나 구분자를 사용한 문자열등으로 처리됨.

#### 1.4.2 헤더 수신

- 생략

#### 1.4.3 MIME 타입

- MIME(Multipurpose Internet Mail Extensions) 타입은, 전자메일 시스템에서 사용되는 콘텐츠 타입을 정의하는 표준
  - `Content-Type` 헤더를 통해 전달됨.
    - 예시
      - `Content-Type: text/plain; charset=UTF-8`
      - `Content-Type: text/html; charset=UTF-8`
      - `Content-Type: image/jpeg`
      - `Content-Type: application/json`
      - `Content-Type: application/octet-stream`
      - `Content-Type: application/x-www-form-urlencoded`

#### 1.4.4 Content-Type과 보안

- `Content-Type` 헤더는, 클라이언트가 콘텐츠를 올바르게 해석할 수 있도록 도와줌.

#### 1.4.5 전자메일과의 차이

- `헤더`와 `본문`으로 구성되어있다.
- HTTP요청에서는 선두에 메서드, 패스, 상태코드가 추가된다.
- 결과적으로, HTTP는 전자메일의 확장이고, HTTP통신은 고속으로 전자메일이 왕복하는것이라고 할 수 있다.

### 1.5 HTTP의 조상(2) 뉴스 그룹

- 과거에는 뉴스 그룹, 혹은 유즈넷으로 불리우는 전자게시판이 있었음.
  - 이러한 게시판은 분산 아키텍처로 구성되어있었으며, 클라이언트-서버 혹은 마스터-슬레이브 통신을 위해 NNTP(Network News Transfer Protocol)를 사용하였음.
- HTTP는 이러한 NNTP로부터 메서드와 스테이터스 코드를 차용하였음.

#### 1.5.1 메서드

- 뉴스 그룹에는 아래와 같은 메서드가 존재하였음
  - `LIST`: 그룹 목록을 가져옴
  - `HEAD`: 본문을 제외한 헤더만 가져옴
  - `BODY`: 본문만 가져옴
  - `POST`: 새로운 글을 작성함

- HTTP는 이러한 메서드를 차용하되, 파일시스템과 같은 철학을 공유함.
  - `GET`: 서버에 헤더와 콘텐츠 요청
  - `HEAD`: 서버에 헤더만 요청
  - `POST`: 새로운 문서 투고

- 자바스크립트의 XML HttpRequest가 추가되기 이전까지는 `GET`과 `POST`만 사용되었음.
- 이후, 위 메서드 이외에도 많은 메서드가 추가되고 삭제되었음.

#### 1.5.2 스테이터스 코드

- 100번대: 처리가 게속됨. 특수한 경우에 대한 응답. 정보의 전달을 위한 것.
- 200번대: 성공. 요청이 성공적으로 처리되었음.
- 300번대: 리디렉트. 추가 동작이 필요함. 요청한 리소스가 다른 위치에 있음.
- 400번대: 클라이언트 오류. 요청에 오류가 있음.
- 500번대: 서버 오류. 서버가 유효한 요청을 처리하지 못함.

### 1.6 리디렉트

- 리디렉트는, 클라이언트가 요청한 리소스가 다른 위치에 있을 때 사용됨.
  - 이는, 서버가 클라이언트에게 새로운 URL을 알려주는 것.
  - 이러한 리디렉트는 `Location` 헤더를 통해 전달됨.
  - 리디렉트의 다섯가지 종류
    
    |스테이터스 코드|메서드 변경|영구적/일시적|캐시|설명|
    |---|---|---|---|---|
    |301 Moved Permanently|O|영구적|O|요청한 리소스가 새로운 URL에 있음. 웹사이트 이전, HTTP와 HTTPS간 리디렉트 등에 사용됨.|
    |302 Found|O|일시적|지시에 따름|요청한 리소스가 일시적으로 다른 URL에 있음. 모바일 페이지로 리디렉트, 쿠키를 사용한 세션 관리 등에 사용됨.|
    |303 See Other|허용|영구적|X|로그인 후 리디렉트, 폼 전송 후 리디렉트 등에 사용됨.|
    |307 Temporary Redirect| |지시에 따름|RFC 7231에 추가됨.|
    |308 Permanent Redirect| |영구적|O|RFC 7538에 추가됨.|

  - 301/308은 모두 영구적 이동을 의미하며, 검색엔진도 이를 인지함. 구글에서는 301을 권장.
  - 302/307은 모두 일시적 이동을 의미함.
  - 303은 요청한 페이지에서 반환할 콘텐츠가 없거나, 별도의 페이지를 표시하고자 할 때 사용됨.

### 1.7 URL

- URI, URL, URN의 관계
  - URI(Uniform Resource Identifier): 리소스에 대한 식별자. URL과 URN을 포함함.
    - URL(Uniform Resource Locator): 웹 개발에서의 대부분의 URI는 URL임. 리소스의 위치를 나타냄.
    - URN(Uniform Resource Name): 웹 시스템에서는 거의 사용되지 않음.

#### 1.7.1 URL의 구조

- URL은 `scheme://user:password@host:port/path?query#fragment`의 형태로 구성됨.
  - `scheme`: 프로토콜. `http`, `https`, `ftp`, `file` 등이 있음.
  - `user:password`: 인증정보. `user`만 있을 수도 있고, 둘 다 없을 수도 있음.
  - `host`: 호스트명. 도메인명이나 IP주소가 올 수 있음. **실제로 통신하는 서버의 주소**
  - `port`: 포트번호. 생략될 수 있음.
  - `path`: 리소스의 경로. 파일명이나 디렉토리명이 올 수 있음.
  - `query`: 쿼리스트링. `?`로 시작하며, `&`로 구분됨.
  - `fragment`: 프래그먼트. `#`로 시작함.

- 예시
  - `http://www.oreilly.com/index.html/some/path?query=1#fragment`

- 우측으로 갈수록 정보가 구체화됨.
- 사람이 읽기 쉬운 형태로 URL을 작성하는 것이 좋음.

#### 1.7.2 URL과 국제화

- 퓨니코드(Punycode)를 사용하여 도메인명을 인코딩함.
  - 예시: `http://www.한글도메인.com` -> `https://xn--bj0bj3i97fq8o5lq.com`
    - `xn--`로 시작하는 문자열로 시작하면, 퓨니코드로 인코딩된 도메인명임.

### 1.8 바디

- HTTP/0.9
  - 요청에 바디가 없었음.
  - 응답의 경우에도 HTML콘텐츠 자체가 응답이었음.

- HTTP/1.0
  - 응답과 요청 모두에 헤더가 추가되었음.
  - 또한 요청에도 바디를 추가할 수 있게 되었음.
  - 따라서, 헤더와 바디의 구분자로 공백 라인을 사용함.
  - 예시

    ```http
    POST /path HTTP/1.0
    Content-Length: 11

    hello world
    ```

#### 1.8.1 GET 요청 시의 바디

- 일반적으로 GET 요청에는 바디를 `포함하지 않을 것으로 기대`함.
  - 하지만, HTTP/1.0에서는 GET 요청에도 바디를 포함할 수 있음.
  - 로이 필딩은, GET 요청에 바디를 포함할 수는 있지만, 서버는 이를 무시해야 한다고 말하고 있음.
    - 왜 이렇게 만들었는지 모르겠다.

- 다만, Body가 금지된 메서드가 있는데, `TRACE`메서드에서는 바디를 포함하면 안된다고 명시되어 있음.

### 1.9 마치며

- HTTP의 주요 구성요소
  - 메서드와 경로
  - 헤더
  - 바디
  - 스테이터스 코드

## Chapter 02 HTTP/1.0의 시맨틱스: 브라우저 기본 기능의 이면

### 2.1 단순한 폼 전송(x-www-form-urlencoded)

### 2.2 폼을 이용한 파일 전송

### 2.3 폼을 이용한 리디렉트

### 2.4 콘텐트 니고시에이션

#### 2.4.1 파일 종류 결정

#### 2.4.2 표시 언어 결정

#### 2.4.3 문자셋 결정

#### 2.4.4 압축을 이용한 통신속도 향상

### 2.5 쿠키

#### 2.5.1 쿠키의 잘못된 사용법

#### 2.5.2 쿠키에 제약을 주다

### 2.6 인증과 세션

#### 2.6.1 BASIC 인증과 Digest 인증

#### 2.6.2 쿠키를 사용한 세션 관리

#### 2.6.3 서명된 쿠키를 이용한 세션 데이터 저장

### 2.7 프록시
