# 당신의 Node.js를 죽이는 n가지 방법 - 메모리 누수

## 개요

모름지기 무언가를 살려야 하는 사람들이 가장 먼저 배워야 할 것은 무엇일까요? 제 생각에는 반대로 그 무언가를 죽이는 방법을 배워야 한다고 생각합니다. 그리고 이러한 지식을 통해 각 상황에 맞는, 적절한 방법을 선택할 수 있어야 합니다. 이 글에서는 Node.js에서 발생하는 메모리 누수를 일으키는 다양한 방법과 메모리 누수를 탐지하는 방법에 대해 알아보겠습니다.

## 메모리 누수란?

현대의 컴퓨터라는 개념을 다루는데 있어서 메모리는 정말 중요한 자원입니다. 그리고 꽤나 비싸죠. 그리고 언제나 유한하죠. 네, 항상 모자랍니다.

그런데 이런 메모리가, 서버가 운영되는 동안 점차 줄어든다면 어떨까요? 사용 할 수 있는 메모리가 점점 줄어들다가 마침내 서버가 죽어버린다면 어떨까요?

이것이 바로 메모리 누수입니다. 메모리 누수는 프로그램이 종료될 때까지 해제되지 않는 메모리를 말합니다. 메모리 누수는 프로그램의 성능을 저하시키고, 프로그램이 죽는 원인이 될 수 있습니다.

## 정상적인 메모리 해제

정상적인 메모리 해제는 더 이상 필요하지 않은 메모리를 해제하는 것을 말합니다. 즉, 더이상 사용되지 않는 메모리를 다시 사용할 수 있는 상태로 만드는 것입니다.

C나 C++과 같은 언어에서는 개발자가 직접 메모리를 할당/해제해야 하기에 그만큼 자유도가 높지만 책임도 큽니다. 그러나 자바스크립트와 같은 고수준 언어에서는 가비지 컬렉터가 메모리를 자동으로 해제해주기 때문에 개발자가 직접 메모리를 해제할 필요가 없습니다.

더군다나 뒤에서 다룰 현대의 가비지 컬렉터는 매우 똑똑해져서 개발자가 신경쓰지 않아도 대부분의 메모리를 해제해줍니다.
덕분에 자바스크립트를 사용하는 개발자들은 일반적인 상황에서 메모리 관리에 대해 크게 걱정할 필요가 없습니다.

### 가비지 컬렉터(Feat. V8 엔진)

Node.js는 V8 엔진의 가비지 컬렉터(이하 GC)를 사용합니다.
이 GC는 크게 두 가지 방식으로 동작합니다.

#### 1. Minor GC: Scavenge

Minor GC는 young generation의 메모리를 관리하는 것입니다. 대부분의 객체는 young generation에 할당되며, 이 공간은 매우 빠르게 가비지 컬렉션됩니다. 이 공간은 다른 공간과 독립적이며, 대부분의 객체는 여기에 할당됩니다.

Minor GC는 크게 두 단계로 이루어집니다.

- 1단계
  - from space에 있는 객체들을 순회하며 참조가 있는 객체를 찾습니다.
  - 참조가 있는 객체를 from space에서 to space로 이동시킵니다.
  - to space로 이동한 객체는 생존한 객체로 간주되어 mark됩니다.
  - to space로 새로운 객체가 생성됩니다.
  - from space는 비워집니다.
  - from space와 to space의 이름을 바꿉니다.
- 2단계
  - from space에 있는 객체들을 순회하며 참조가 있는 객체를 찾습니다.
  - mark된 객체가 있다면 이는 생존한 객체로 간주되어 old generation으로 이동시킵니다.
  - 그 외 참조가 있는 객체는 to space로 이동시킵니다.
  - to space로 새로운 객체가 생성됩니다.
  - from space는 비워집니다.
  - from space와 to space의 이름을 바꿉니다.

이 과정을 반복하다가 특정 시점에 old generation으로 이동시키는데, 이를 Major GC라고 합니다.

#### 2. Major GC: Mark-Sweep

Major GC는 old generation의 메모리를 관리하는 것입니다. 대부분의 객체는 young generation에 할당되며, 일정 시간이 지나면 old generation으로 이동합니다. Major GC는 old generation의 메모리를 관리하는 것입니다.

Major GC는 크게 세 단계로 이루어집니다.

- Marking
  - GC가 객체들을 순회하며 사용 여부를 판단합니다.
  - known roots를 시작으로 참조가 있는 객체를 찾아 mark합니다.
  - 이 과정에서 DFS(깊이 우선 탐색) 알고리즘이 사용됩니다.
~~

### 수동 메모리 해제

수동 메모리 해제는 개발자가 직접 메모리를 해제하는 것을 말합니다. C나 C++이 아닌 자바스크립트에서도 종종 수동 메모리 해제가 필요할 수 있습니다. 메모리 누수를 방지하기 위해 개발자가 직접 메모리를 해제해야 하는 경우가 있습니다. 이런 경우에 대해서는 아래에서 자세히 다루겠습니다.

## 메모리 누수를 일으키는 대표적인 방법

### 1. 전역변수 사용

전역변수는 프로그램이 종료될 때까지 메모리를 차지합니다. 따라서 전역변수를 사용할 때는 필요가 끝난 후에 null로 초기화하여 메모리를 해제하는 것이 중요합니다.

### 2. 클로저 사용

클로저는 외부 함수의 변수에 접근할 수 있는 내부 함수를 말합니다. 클로저는 외부 함수의 변수를 참조하고 있기 때문에 외부 함수의 변수가 메모리에서 해제되지 않습니다. 클로저를 사용할 때는 외부 함수의 변수를 참조하는 것이 필요한지 신중하게 판단해야 합니다.

### 3. 해제되지 않는 이벤트 리스너

이벤트 리스너를 등록하면 이벤트가 발생할 때까지 메모리를 차지합니다. 따라서 이벤트 리스너를 등록할 때는 사용 후 이벤트 리스너를 해제하는 함수를 만들어야 합니다.

### 4. 해제되지 않는 타이머

타이머를 등록하면 타이머가 종료될 때까지 메모리를 차지합니다. 타이머를 등록할 때는 타이머를 해제하는 함수를 만들어야 합니다.

### 5. 해제되지 않는 파일 디스크립터

파일 디스크립터를 열면 해당 디스크립터가 닫힐 때까지 메모리를 차지합니다. 파일 디스크립터를 열 때는 사용 후 파일 디스크립터를 닫는 함수를 만들어야 합니다.

## 메모리 누수를 탐지하는 방법

### 1. node --trace_gc index.js

이 명령어를 사용하면 가비지 컬렉션이 수행될 때마다 상세한 로그를 출력하여 메모리 누수를 탐지할 수 있습니다.

### 2. node --inspect index.js

이 명령어를 통해 Chrome DevTools와 같은 디버깅 도구를 사용하여 메모리 누수를 실시간으로 분석할 수 있습니다.

### 3. 자바스크립트 디버그 터미널

자바스크립트 디버깅 터미널을 사용하여 코드 실행 중 메모리 사용량을 모니터링하고 누수를 탐지할 수 있습니다.

### 4. pm2 monit

PM2의 모니터링 도구를 사용하여 애플리케이션의 메모리 사용량을 실시간으로 확인할 수 있습니다.

### 5. Heapdump

Heapdump를 사용하여 특정 시점의 힙 메모리 상태를 덤프하고, 이를 분석하여 메모리 누수를 탐지할 수 있습니다.