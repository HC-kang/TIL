# SSL/TLS

- SSL(Secure Socket Layer)
- TLS(Transport Layer Security)

## Cryptography

### Symmetric Key Cryptography

- AES(Advanced Encryption Standard)

- Master Secret
- Pre Master Secret

- SNI(Server Name Indication)

### Asymmetric Key Cryptography

- RSA(Rivest-Shamir-Adleman)
- DSA(Digital Signature Algorithm)
- Public Key
- Private Key

### 비도(Strength of Cryptography)

- 64bit: 2^64
- 128bit: 2^128
- 256bit: 2^256
- 512bit: 2^512

- RSA(Rivest-Shamir-Adleman)

## PKI(Public Key Infrastructure)

- R.A.(Root Authority, Registration Authority)
- C.A.(Certificate Authority)
- R.A. -> C.A. -> User: Certificate Chain

## Ethernet (TCP/IP)

---

# SSL/TLS 톺아보기: 웹 보안의 핵심

안녕하세요!  
오늘은 이전에 다루었던 HTTP에 이어서 웹 보안의 중요한 축을 담당하는 SSL/TLS에 대해 조금 깊이있게 다루어보려고 합니다.  
기술적인 내용을 다루기 때문에, 이해가 어려운 부분이 있을 수 있는데요, 이를 최대한 쉽게 설명하고자 노력하겠습니다. 혹시라도 틀린 부분이나, 궁금한 점이 있으시다면 언제든지 질문해 주세요!  

개발자로 일하고 계신분들이라면 다들 SSL/TLS에 대해서 대략적으로는 알고 계실 것입니다. 요즘에는 HTTPS를 사용하지 않으면 어지간한 서비스는 불법이거든요. 그렇다면, SSL/TLS가 무엇인지, 어떻게 작동하는지, 왜 이것이 중요한지 알아보도록 하겠습니다.

## SSL과 TLS: 이 두가지 이름은 무엇일까?

`SSL`과 `TLS`는 각각 `Secure Socket Layer`와 `Transport Layer Security`의 약자입니다. 둘다 뭐 비슷한 의미를 품고있고, 실제로 많은 경우에 이를 혼용하고있습니다.  
이를 굳이 따져보자면 마치 `호치키스`와 `스테이플러`의 차이같다고 할 수 있습니다. 왜냐하면, `SSL`은 1990년대 중반에 넷스케이프에 의해 개발되었고, 이후 `TLS`로 발전하게 되었기 때문입니다. 
TLS는 SSL 3.0을 기반으로 만들어졌지만, 더 높은 보안성과 성능을 제공합니다. 1999년 IETF(Internet Engineering Task Force)에 의해 표준화된 이후, TLS는 현재 인터넷 보안에서 표준으로 자리 잡고 있습니다.

즉, **SSL은 먼저 개발된 하나의 제품**이고, **TLS는 이것이 규격화된 하나의 표준 프로토콜**이라고 할 수 있습니다.

> **성공한 제품** : **산업 표준**  
> SSL : TLS  
> 호치키스 : 스테이플러  
> 포크레인 : 굴삭기  

결론적으로, 엄밀히 따지면 현재 사용되는 것은 TLS이지만, SSL이라고 부르는 경우도 많습니다. 다만 이 글에서는 이들보다, HTTP에 SSL/TLS가 적용된 HTTPS를 더 많이 언급할 것입니다.

## HTTPS, HTTP에 보안을 더한 것

다음으로 알아볼 것은, 이번 글의 본격적인 주제인 HTTPS입니다.  
HTTPS는 HTTP(Hyper Text Transfer Protocol) + S(Secure)로, 다들 아시고 짐작하셨다 시피 HTTP에 보안을 더한 것입니다. 

기존 HTTP는 데이터를 평문으로 전송하기 때문에, 중간에 누군가가 데이터를 가로채어 볼 수 있습니다. 이를 방지하기 위해, HTTPS는 데이터를 암호화하여 전송합니다. 이를 통해 중간에 누군가가 데이터를 가로채어도, 데이터를 해독할 수 없게 됩니다.

그렇다면 이러한 보안을 정확히 어떻게 구현하는 것일까요?

![alt text](images/windtalker.png)
  - 영화 "윈드토커", 소수의 인디언만이 사용하는 언어를 암호 통신의 수단으로 사용하는 전쟁 영화

물론 이러한 암호 통신을 위한 방법은 수도없이 많습니다. 약속된 그들만의 언어를 사용할 수도 있고, 특정한 도서나 출판물을 사용한 약속을 통해 암호화를 할 수도 있습니다.
실제로 제 과거 군 경험을 예로 들어보자면, 군대에는 CEOI라는 것이 있습니다. 단순히 종이 한 장에 암호화 및 복호화를 위한 약속(키)가 주욱 적혀있을 뿐인데, 이것만으로도 암호화 통신을 할 수 있습니다.

### 가장 단순하고 쉬운 방법: 대칭키(Symmetric Key) 암호화

![alt text](images/symmetric.png)

HTTPS에서 사용하는 방식도 이와 비슷합니다. 서버와 클라이언트가 특정한 키(대칭키)를 공유하고 이를 바탕으로 실제 통신에는 이 키를 사용해 해싱(암호화)된 데이터를 주고받습니다. 이를 통해 중간에 누군가가 데이터를 가로채어도, 키를 가지고있지 않다면 데이터를 해독할 수 없게 됩니다.

하지만 여기에는 한가지 큰 문제가 있습니다.

> **그런데.. 그 대칭키는 어떻게 안전하게 공유하지?**

네 맞습니다. 대칭키는 양쪽이 동일한 키를 가지고 있어야 합니다. 그 키를 클라이언트가 만들건, 서버가 만들건, 필수적으로 이를 교환하는 과정이 필요합니다. 그런데 만에하나 이 키가 중간에 해커로부터 유출된다면 모든 통신은 노출되어버리게 됩니다.

남성분들은 아시겠지만, 이것이 군대에서 CEOI를 그렇게 소중하게 목에 걸고 다니는 이유입니다. CEOI가 외부로 유출된다면, 조직 내의 모든 통신은 노출된다고 볼 수 있기 때문이죠.

#### 참고 1) 암호화 방식의 첫 번째 축: 대칭키란 무엇일까?

> ⚠️ 앞으로 중간중간 몇 가지 참고사항이 있습니다.  
> 이것들은 이해를 돕기 위한 것이니, 이미 잘 알고계시다면 넘어가셔도 무방합니다.

대칭키란, 암호화와 복호화에 동일한 키를 사용하는 방식입니다. 가장 널리 사용되는 대칭키 알고리즘으로는 AES(Advanced Encryption Standard)가 있습니다. AES는 빠르고 안전한 암호화 방식으로, 일반적으로 TLS 1.3에서는 128비트, 256비트의 키를 사용합니다. 이는 아래와 같은 방식으로 쉽게 사용 해 볼 수 있습니다.

여기서는 16바이트(128비트)의 키를 생성해보겠습니다.

```bash
openssl rand -hex 16
> 4353eed991856ca1730a2a6daaea9a5b
```

추가적으로 IV(Initialization Vector)라는 것도 있습니다. 이는 암호화를 할 때, 암호화된 데이터의 패턴을 무작위로 만들어주는 역할을 합니다. 이를 통해 같은 데이터를 암호화해도, 매번 다른 결과를 만들어내어 보안성을 높입니다.

```bash
openssl rand -hex 16
> 1402346b532b87618d6f7b247a2cd0ef
```

이제 암호화할 문자열을 생성해보겠습니다.

```bash
echo "Hello, I'm ford. nice to see you" > plaintext.txt
```

이제 암호화를 해보겠습니다.

```bash
openssl enc -aes-128-cbc -in plaintext.txt -out ciphertext.bin -K 4353eed991856ca1730a2a6daaea9a5b -iv 1402346b532b87618d6f7b247a2cd0ef
```

그러면 아래와 같은 파일이 생성됩니다.

```bin
// ciphertext.bin
�uQG@�qv,"�n4���+�",c ���L�PN��:S�^P�g�^w�
```

이제 복호화를 해보겠습니다.

```bash
openssl enc -d -aes-128-cbc -in ciphertext.bin -out decrypted.txt -K 4353eed991856ca1730a2a6daaea9a5b -iv 1402346b532b87618d6f7b247a2cd0ef
```

그러면 아래와 같은 파일이 생성됩니다.

```txt
// decrypted.txt
Hello, I'm ford. nice to see you
```

넵, 이렇게 정상적으로 복호화가 되었습니다. 이렇게 대칭키를 사용한 암호화 방식은 비교적 적은 연산량으로 빠르게 암호화를 할 수 있습니다.

그러면 이번에는 한 대칭키를 한번 한 글자만 틀려볼까요?

```bash
# key의 마지막 문자를 b 에서 a로 변경
openssl enc -d -aes-128-cbc -in ciphertext.bin -out decrypted-failed.txt -K 4353eed991856ca1730a2a6daaea9a5a -iv 1402346b532b87618d6f7b247a2cd0ef
> bad decrypt
```

결과물은 아래와 같습니다. 전혀 알아 볼 수 없죠? 복호화가 실패했기 때문입니다.

```txt
�v�*f�j�5ˇ�ȄM,d�ͩ�O&�ՒS|
```

##### 참고 1-1) iv? 이건 또 뭐죠?

위의 암/복호화 과정에서 은근슬쩍 `iv`라는 항목이 사용되었습니다. 과연 이건 또 뭘까요?

![iv](images/iv.png)

간단하게만 설명하자면, iv(Initialization Vector)는 일종의 양념같은 존재입니다. 이를 통해 동일한 데이터를 암호화 하더라도 매번 다른 결과를 만들어내어 보안성을 높일 수 있게 해줍니다.

iv의 본질은 비밀보다는 **매번 다른 결과를 만들어내는 것**이기 때문에, 이 값은 암호화된 데이터와 함께 공개되어도 상관없습니다. 그래서 암호화된 데이터와 함께 전송되기도 합니다.

### 그렇다면 두 번째 방법: 비대칭키(Asymmetric Key) 암호화

그렇다면 이 문제를 해결하기 위한 방법은 무엇일까요? 서로가 같은 키를 가지고 있지 않아도 통신을 할 수 있는 방법이 있을까요?  
네, 그 방법이 바로 `비대칭키 암호화`입니다.

![alt text](images/asymmetric.png)

비대칭키 암호화는 두 개의 다른 키, 즉 ***공개키***와 **개인키**를 사용합니다. ***공개키***로 암호화한 데이터는 **개인키**로만 복호화할 수 있으며, 반대로 **개인키**로 암호화한 데이터는 ***공개키***로만 복호화할 수 있습니다. 후자의 경우는 특별히 `전자서명`이라고 부르기도 합니다.

![alt text](images/asymmetric2.png)

위 도식과 같이, 이전과는 다르게 이번에는 자신의 공개키를 상대방에게 전달하고, 상대방은 이를 통해 데이터를 암호화하여 전달합니다. 그리고 이를 받은 자신은 개인키로 복호화하여 데이터를 확인합니다.

이렇게 하면, 제3자가 중간에 공개키와 데이터를 가로채더라도 이 데이터를 복호화할 수 있는 개인키를 가지고 있지 않기 때문에 데이터를 확인할 수 없게 됩니다.

만약 양방향 통신을 해야한다면 서로 공개키를 교환하여 통신을 할 수 있겠죠?  
이로서 이전 대칭키를 사용하는 경우에 발생했던 문제점을 완전히 해결한것처럼 보입니다.

하지만 이 방법에도 한 가지 문제가 있습니다. 그것은 바로 `성능`입니다. 대칭키 암호화에 비해 비대칭키 암호화는 연산량이 많아서 느리다는 점이 큰 문제입니다. 이러한 이유로 우리는 이 문제를 해결하기 위해 또다른 방법을 사용합니다.

#### 참고 2) 암호화 방식의 두 번째 축: 비대칭키란 무엇일까?

비대칭키란, 암호화와 복호화에 서로 다른 키를 사용하는 방식입니다. 가장 널리 사용되는 비대칭키 알고리즘으로는 RSA(Rivest-Shamir-Adleman)가 있습니다. 
세 단어 모두 알고리즘의 개발자들의 이름을 따서 지어졌습니다. 읽기도 힘드네요.  
RSA는 공개키 암호화 방식으로, 공개키로 암호화한 데이터는 개인키로만 복호화할 수 있으며, 반대로 개인키로 암호화한 데이터는 공개키로만 복호화할 수 있습니다.

RSA 암호화는 보통 2048비트, 4096비트의 키를 사용합니다. 이전에는 1024비트의 키를 사용하기도 했지만, 이제는 보안성이 떨어져 사용되지 않습니다.  
여기서는 2048비트의 키를 생성해보겠습니다.

```bash
openssl genrsa -out private.pem 2048
```

이렇게 하면 Private Key가 생성됩니다. 생성된 키는 아래와 같이 생겼습니다.

```pem
-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC7EMlVx2Huqyno
...
...
L2/3i9pOV3bgD6ZStSvB4+U=
-----END PRIVATE KEY-----
```

이제 이 Private Key를 이용하여 Public Key를 생성해보겠습니다.

```bash
openssl rsa -in private.pem -pubout -out public.pem
```

```pem
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuxDJVcdh7qsp6HNUX/LQ
...
...
TwIDAQAB
-----END PUBLIC KEY-----
```

딱 봐도 AES에 비하면 훨씬 길죠? 그만큼 연산량도 크고 무겁습니다. 그러면 이제 이 키를 이용하여 암호화를 해보겠습니다.

```bash
echo "Hello, I'm ford. nice to see you" > plaintext.txt
openssl pkeyutl -encrypt -inkey public.pem -pubin -in plaintext.txt -out ciphertext.bin
```

결과물은 이렇게 생겼습니다. 암호화가 잘 된 것을 확인할 수 있습니다.

```bin
�l��R�p�]o+N�xAo����bѽjd��.�Po���ԭ���z�� q�W S�a�P��M����.�^J�J�v<���'��H���Pf9�~	�g�?�]�6w75̱�d҆,�������N'��C����v#a/%{GqRo�/�m1�>7�/�J��0T��#���XC't�e]
7���������.�[`�Y
K��mxB�J�R��p%����H���i�^9��!�!����*]�K�*�=.�59���d
```

이제 복호화를 해보겠습니다.

```bash
openssl pkeyutl -decrypt -inkey private.pem -in ciphertext.bin -out decrypted.txt
```

```txt
Hello, I'm ford. nice to see you
```

### 그렇다면 이제 세 번째 방법: 공개키 + 대칭키 모두를 사용하자!

![alt text](images/hybrid.png)

드디어 이제, 최종적으로 이 문제를 해결할 수 있는 방법을 찾았습니다. 그 방법은 생각보다 간단합니다. 공개키를 사용하여 대칭키를 교환하는 것입니다. 이를 통해 대칭키를 안전하게 교환하고, 이후에는 대칭키를 사용하여 데이터를 주고받습니다.

자, 여기까지의 과정은 생각보다 어렵지 않죠? 이제 이러한 개념을 바탕으로 본격적으로 HTTPS가 어떻게 작동하는지 알아보도록 하겠습니다.

#### 참고 3) 암호화의 강도: 키 길이에 따른 보안 수준.

위의 AES와 RSA를 설명하는 부분에서 계속해서 `AES-128`, `RSA-2048` 등의 이름모를 숫자들이 등장했습니다. 이를 `비도`라고 부르는데, 이는 암호화의 강도를 나타내는 지표입니다. 쉽게 말하면 키의 길이라고 할 수 있습니다.  
당연하게도 비도가 커지면(키의 길이가 길어지면) 이를 해독하는데 더 많은 시간이 걸리고, 공격자가 브루트포스 공격을 하더라도 더 많은 시간이 걸리게 됩니다.  
하지만 반대로 그만큼 연산량이 많아지기 때문에, 성능은 떨어지게 됩니다. 그래서 적당한 비도를 선택하는 것이 중요합니다.

## PKI(Public Key Infrastructure): 공개키 기반 구조

이제 HTTPS를 사용하기 위한 마지막 단계인 `PKI`에 대해 알아보겠습니다.

PKI는 위의 소제목에서도 알 수 있듯, 일종의 사회기반시설(Infra)라고 볼 수 있습니다. 전 세계에서 공용으로 사용하는 공개키를 관리하고, 이를 통해 안전한 통신을 할 수 있도록 도와주는 시스템입니다.

그런데 이게 왜 필요할까요..?

사실은, 조금 전에 알아본 공개키 + 대칭키 방식에도 숨겨진 문제가 있습니다. 바로 `신뢰`입니다. 무슨 뜬구름 잡는 소리냐구요? 좀 더 자세히 살펴봅시다.

![alt text](images/hybrid.png)

위 과정에서 가장 먼저 Alice는 Bob에게 자신의 공개키를 전달합니다.  
그런데 만약 이 둘의 사이에 Charlie가 숨어있다면 어떻게 될까요? Charlie는 둘 사이의 통신을 가로채어, 자신의 공개키를 Bob에게 전달할 수도 있습니다. 그러면 Bob은 이 공개키로 대칭키를 암호화하여 전달하게 됩니다.  
그리고 아무렇지 않은척 대칭키를 Alice의 공개키로 암호화하여 전달하면 이후의 모든 통신을 Charlie가 가로챌 수 있게 됩니다. 이것이 바로 `중간자 공격`입니다.

![alt text](images/hybrid-fail.png)

자, 이제 어느정도 감이 오실겁니다. 이를 해결하기 위해 등장한 것이 바로 `인증서`입니다.  
일반적인 환경에서 Alice와 Bob은 서버와 클라이언트로 볼 수 있습니다. 서버는 클라이언트에게 자신의 공개키를 전달하고, 클라이언트는 이를 통해 데이터를 주고받죠. 이 과정에서 서버는 자신이 누구인지 증명할 수 있는 `인증서`를 클라이언트에게 전달합니다.

이 인증서는 `CA(Certificate Authority)`라는 기관이 발급하며, 이를 통해 서버의 신원을 확인할 수 있습니다. 이를 통해 중간자 공격을 방지할 수 있습니다.

![alt text](images/naver-ca.png)

위 그림은 네이버의 인증서를 확인하는 화면입니다. 여기서 `NAVER Corp.` 라는 조직이 `DigiCert Inc`라는 CA로부터 발급받은 인증서라는 것을 확인할 수 있습니다.

여기서 조금만 더 집요하게 굴어봅시다. 그렇다면 CA는 누구고, 이 CA는 어떻게 신뢰할 수 있는 것일까요? 여기서 등장하는 두 가지 개념이 있습니다. 바로 `RA(Root Authority)`와 `Certificate Chain(Chain of Trust)`입니다.

### RA(Root Authority): 최상위 인증 기관

`RA`는 `CA`의 최상위 인증 기관입니다. 이름 그대로 전세계 모든 인증 기관의 최상위에 위치하며, 그만큼 명망있고 신뢰도 높은 기관입니다. 대표적으로 `VeriSign`, `DigiCert`, `COMODO`등이 있습니다. 이 `RA`는 자신의 서명을 통해 `CA`에게 인증서를 발급하고, 이를 통해 `CA`는 다시 하위 `CA` 혹은 서버에게 인증서를 발급합니다.

### Certificate Chain(Chain of Trust): 신뢰 체인

눈치 빠른 분들은 아시겠지만, 위에서 언급한 `RA`와 `CA`의 연속된 관계를 `Certificate Chain`이라고 합니다. 이는 `RA`가 `CA`에게 인증서를 발급하고, `CA`는 이를 통해 서버에게 인증서를 발급하는 과정을 말합니다. 이를 통해 서버의 신원을 확인할 수 있습니다.

![alt text](images/naver-chain.png)

위 그림은 네이버의 인증서를 확인하는 화면입니다. 여기서 `DigiCert Global Root CA`라는 최상위 인증 기관이 `DigiCert TLS Hybrid ECC SHA384 2020 CA1`라는 중간 인증 기관에게 인증서를 발급하고, 이를 통해 `*.naver.com`이라는 서버에게 인증서를 발급했다는 사실을 알수있죠.

이를 좀 더 개념적으로 정리해보면 아래와 같습니다.

![alt text](images/chain-of-trust.png)

'ONGOING'

## SSL/TLS 핸드셰이크 과정: 보안 연결 설정의 핵심


안녕하세요! 오늘은 웹 보안의 중요한 축을 담당하는 SSL/TLS에 대해 톺아보면서 기술적으로 깊이 있는 내용을 다루어 보겠습니다. SSL과 TLS는 인터넷 보안에서 중요한 역할을 하며, 우리가 일상적으로 사용하는 HTTPS는 바로 이 기술에 기반하고 있습니다. 이번 포스팅에서는 SSL/TLS의 원리와 세부적인 기술 요소까지 살펴보며, 왜 이 기술이 필수적인지 알아보겠습니다.

## SSL과 TLS: 무엇이 다른가?

SSL(Secure Socket Layer)과 TLS(Transport Layer Security)는 인터넷 통신에서 데이터를 암호화하여 보안을 보장하는 프로토콜입니다. SSL은 1990년대 중반 Netscape에 의해 개발되었으며, 이후 TLS로 발전하게 되었습니다. TLS는 SSL 3.0을 기반으로 만들어졌지만, 더 높은 보안성과 성능을 제공합니다. 1999년 IETF(Internet Engineering Task Force)에 의해 표준화된 이후, TLS는 현재 인터넷 보안에서 표준으로 자리 잡고 있습니다【5†source】.

SSL과 TLS는 기본적으로 암호화된 통신을 가능하게 하지만, TLS는 더 안전한 해시 알고리즘과 키 교환 메커니즘을 사용해 SSL의 단점을 보완합니다. 또한, TLS는 SSL보다 더 유연한 암호화 방식 협상 프로세스를 지원하여 다양한 보안 요구 사항에 대응할 수 있습니다.

## 암호화 방식의 두 축: 대칭키와 비대칭키 암호화

SSL/TLS는 두 가지 암호화 방식을 결합하여 사용합니다. 대칭키 암호화는 빠른 속도로 대량의 데이터를 암호화하는 데 적합하고, 비대칭키 암호화는 보안성이 높아 키 교환에 주로 사용됩니다.

### 1. 대칭키 암호화 (Symmetric Key Cryptography)

대칭키 암호화에서는 암호화와 복호화에 동일한 키를 사용합니다. 가장 널리 사용되는 대칭키 알고리즘으로는 AES(Advanced Encryption Standard)가 있습니다. AES는 빠르고 안전한 암호화 방식으로, 128비트, 192비트, 256비트 키를 사용할 수 있습니다. SSL/TLS에서는 세션 암호화를 위해 대칭키 암호화를 사용하며, 이 때 생성된 **마스터 시크릿(Master Secret)**이 데이터 암호화에 사용됩니다【5†source】.

대칭키 암호화의 주요 장점은 속도입니다. 그러나 이 방식의 치명적인 단점은 **키 분배 문제**입니다. 양쪽이 동일한 키를 사용해야 하므로, 키를 안전하게 공유하는 방법이 필요합니다. 이 문제를 해결하기 위해 SSL/TLS는 비대칭키 암호화를 활용합니다.

### 2. 비대칭키 암호화 (Asymmetric Key Cryptography)

비대칭키 암호화는 두 개의 다른 키, 즉 공개키와 개인키를 사용합니다. 공개키로 암호화한 데이터는 개인키로만 복호화할 수 있으며, 반대로 개인키로 암호화한 데이터는 공개키로만 복호화할 수 있습니다. 가장 널리 사용되는 비대칭키 암호화 알고리즘은 **RSA**(Rivest-Shamir-Adleman)입니다【5†source】【5†source】.

SSL/TLS에서는 주로 비대칭키를 사용하여 안전하게 대칭키를 교환하는 데 사용합니다. 비대칭키를 이용해 먼저 **프리 마스터 시크릿(Pre-Master Secret)**을 생성하고, 이를 서버의 공개키로 암호화하여 서버에 전송합니다. 서버는 이 데이터를 개인키로 복호화한 뒤, 클라이언트와 동일한 마스터 시크릿을 생성합니다. 이렇게 생성된 마스터 시크릿은 이후 대칭키 암호화에 사용됩니다.

### 암호화의 강도: 키 길이에 따른 보안 수준

암호화의 강도는 주로 사용되는 키의 길이로 측정됩니다. 키가 길수록 가능한 조합의 수가 많아지므로 공격자가 모든 가능한 키를 대입해보는 **브루트 포스 공격**(brute-force attack)이 사실상 불가능해집니다. 아래는 일반적인 키 길이와 그에 따른 보안 수준입니다:

- **64비트**: 2^64 가지의 조합. 오늘날 대부분의 경우 안전하지 않음.
- **128비트**: 2^128 가지의 조합. 현재 많은 웹사이트에서 기본적으로 사용하는 수준.
- **256비트**: 2^256 가지의 조합. 매우 높은 보안 수준을 요구하는 환경에서 사용됨.
- **512비트**: 2^512 가지의 조합. 일반적으로 많이 사용되지 않지만, 이론상 가장 강력한 보안 수준【5†source】.

## PKI(Public Key Infrastructure): 공개키 기반 구조

SSL/TLS는 인증서를 통해 상대방의 신원을 확인하고, 신뢰할 수 있는 통신을 보장합니다. 이를 위해 **PKI(공개키 기반 구조)**를 사용합니다. PKI는 인증 기관(CA, Certificate Authority)이 발급한 디지털 인증서를 기반으로 통신하는 상대방의 신뢰성을 보장합니다. **인증서 체인(Certificate Chain)**은 Root CA에서 시작해 Intermediate CA를 거쳐 최종 사용자에게 도달하는 방식으로 구축됩니다【5†source】.

### CA(Certificate Authority) 역할

CA는 디지털 인증서를 발급하고 관리하는 기관으로, 웹 서버나 사용자에게 인증서를 발급합니다. SSL/TLS 핸드셰이크 과정에서 서버는 클라이언트에게 자신의 인증서를 제공하여 신뢰성을 입증하고, 클라이언트는 CA에 의해 서명된 서버의 인증서를 검증합니다. 만약 CA가 신뢰할 수 있는 기관이라면, 클라이언트는 해당 서버와 안전하게 통신할 수 있다고 판단하게 됩니다.

## SSL/TLS 핸드셰이크 과정: 보안 연결 설정의 핵심

SSL/TLS는 클라이언트와 서버 간에 안전한 통신을 시작하기 위해 **핸드셰이크 과정**을 거칩니다. 이 과정은 매우 복잡하지만, 그 핵심 단계를 기술적으로 분석하면 다음과 같습니다.

1. **Client Hello**: 클라이언트가 지원하는 암호화 알고리즘, TLS 버전, 세션 ID, 난수를 서버에 보냅니다.
2. **Server Hello**: 서버는 클라이언트의 요청에 응답하며, 사용할 암호화 알고리즘과 TLS 버전을 선택합니다.
3. **서버 인증서 전송**: 서버는 자신의 공개키가 포함된 인증서를 클라이언트에 전송합니다.
4. **키 교환(Client Key Exchange)**: 클라이언트는 서버의 공개키를 사용해 대칭키 암호화에 사용할 **프리 마스터 시크릿**을 생성하고 서버로 전송합니다.
5. **Change Cipher Spec**: 클라이언트와 서버 모두 이제 암호화된 통신을 사용할 준비가 되었음을 알리는 메시지를 전송합니다.
6. **Finished**: 클라이언트와 서버가 각각 자신이 선택한 암호화 방식과 키를 사용해 보안 설정을 완료했음을 알리는 메시지를 주고받습니다【5†source】【5†source】.

이 과정은 양측이 안전하게 키를 교환하고, 이후 통신을 암호화하는 것을 보장합니다. 특히, RSA와 같은 비대칭키 암호화는 이 과정에서 매우 중요한 역할을 합니다.

## SSL/TLS의 보안 메커니즘: 데이터 보호와 무결성 보장

SSL/TLS는 다음과 같은 주요 보안 메커니즘을 통해 데이터를 보호합니다:

1. **암호화(Encryption)**: 데이터는 대칭키로 암호화되어 전송 중에 도청당하더라도 내용을 알 수 없습니다.
2. **무결성 검사(Integrity Check)**: 데이터가 전송 중 변조되지 않았는지 확인하기 위해 **메시지 인증 코드(MAC)**를 사용합니다.
3. **인증(Authentication)**: 서버는 CA에 의해 발급된 인증서를 통해 자신의 신원을 증명하며, 클라이언트도 서버의 인증서를 검증하여 피싱 공격 등을 방지할 수 있습니다【5†source】.

## SSL/TLS의 확장성: SNI(Server Name Indication) 지원

하나의 IP 주소에 여러 도메인을 호스팅하는 경우, SSL/TLS에서는 **SNI(Server Name Indication)** 기술을 사용하여 클라이언트가 연결하려는 특정 도메인을 서버에 알립니다. 이를 통해 여러 도메인이 하나의 서버에서 SSL/TLS 연결을 처리할 수 있게 됩니다【5†source】.

## 결론

SSL/TLS는 현대 인터넷에서 보안을 제공하는 중요한 기술입니다. 이를 통해 우리는 안전한 데이터 전송, 인증 및 데이터 무결성 보장을 실현할 수 있습니다. SSL/TLS는 복잡한 암호화 알고리즘과 인증 메커니즘을 사용하여 우리의 온라인 활동을 보호하며, 이를 올바르게 구현하고 관리하는 것이 중요합니다.

SSL/TLS의 기술적인 원리를 이해하고, 이를

 올바르게 구현하는 것은 모든 웹 개발자와 시스템 관리자에게 필수적인 역량입니다. 앞으로도 이와 같은 보안 기술이 지속적으로 발전하며, 우리의 인터넷 환경을 더욱 안전하게 만들 것입니다.

더 궁금한 점이 있거나 추가적인 내용이 필요하다면 언제든지 질문해 주세요!

---

대칭키란, 암호화와 복호화에 동일한 키를 사용하는 방식입니다. 가장 널리 사용되는 대칭키 알고리즘으로는 AES(Advanced Encryption Standard)가 있습니다. AES는 빠르고 안전한 암호화 방식으로, 128비트, 192비트, 256비트 키를 사용할 수 있습니다. SSL/TLS에서는 세션 암호화를 위해 대칭키 암호화를 사용하며, 이 때 생성된 **마스터 시크릿(Master Secret)**이 데이터 암호화에 사용됩니다.