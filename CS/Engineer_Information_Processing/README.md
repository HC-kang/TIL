# 정보처리기사 실기

출처: [DUKI의 개발](https://dustink.tistory.com/149)

## 1. 요구사항 확인

1. 소프트웨어 개발 방법론(중요도 ★★★)
   - 소프트웨어 생명주기(SDLC; Software Development Life Cycle): 시스템의 요구분석부터 유지보수까지 전 공정을 체계화한 절차
   - 소프트웨어 생명주기 모델 종류
     - 폭포수 모델: 가장 오래된 모델. 각 단계를 확실히 마무리 후 다음 단계로 진행
     - 프로토타이핑 모델: 주요 기능을 프로토타입으로 구현, 고객의 피드백을 반영하여 SW 개발
     - 나선형 모델: 위험 최소화를 위해 점진적으로 시스템 개발
     - 반복적 모델: 구축대상을 나누어 병렬적으로 개발 후 통합하거나 반복적으로 개발
   - 소프트웨어 개발 방법론: 소프트웨어 개발의 시작부터 시스템을 사용하지 않는 과정까지 전 과정을 형상화한 방법론
   - 소프트웨어 개발 방법론 종류
     - 구조적 방법론: 전체 시스템을 기능에 따라 나누어 개발하고 이를 통합하는 방법론
       - 나씨-슈나이더만 차트: 논리의 기술에 중점을 둔 도형식 표현방법
     - 정보공학 방법론: 정보시스템 개발에 필요한 관리 절차와 작업 기법을 체계화한 방법론
     - 객체 지향 방법론: '객체'라는 기본 단위로 시스템을 분석 및 설계하는 방법론
     - 컴포넌트 기반 방법론(CBD): 컴포넌트를 조립해서 하나의 새로운 응용프로그램을 작성하는 방법론
     - 애자일 방법론: 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적응하면서 효율적인 시스템을 개발 할 수 있는 신속 적응적 개량 개발 방법론
     - 제품 계열 방법론: 특정 제품에 적용하고싶은 공통된 기능을 정의해 개발하는 방법론. 임베디드 SW작성에 유용
   - 애자일(Agile)방법론 유형
     - XP(eXtreme Programming): 의사소통 개선과 즉각적 피드백으로 소프트웨어 품질을 높이기 위한 방법론
       - XP 5가지 가치: 용기, 단순성, 의사소통, 피드백, 존중
      - 스크럼(Scrum): 매일 정해진 시간, 장소에서 짧은 시간의 개발을 하는 팀을 위한 프로젝트 중심 방법론
      - 린(Lean): 도요타의 린 시스템 품질기법을 소프트웨어 개발 프로세스에 적용해서 낭비 요소를 제거하여 품질을 향상시킨 방법론
        - Lean의 7가지 가치: 낭비제거, 품질 내재화, 지식 창출, 늦은 확정, 빠른 인도, 사람 존중, 전체 최적화
    - 객체 지향 분석(OOA): 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 클래스(객체), 속성과 연산, 관계를 정의
    - 객체 지향 분석 방법론 종류
      - OOSE(Object Orient Software Engineering): 유스케이스를 모든 모델의 근간으로 활용되는 방법론, 야콥슨
      - OMT(Object Modeling Technology): 그래픽 표기법을 이용하여 소프트웨어 구성 요소를 모델링, 럼바우.
        - 분석 절차: 객체 모델링 -> 동적 모델링 -> 기능 모델링
        - 객체 모델링: 객체들 간의 관계를 정의하여 ER 다이어그램을 만드는 과정까지의 모델링. 객체 다이어그램 활용.
        - 동적 모델링: 시간의 흐름에 따라 객체들의 동적인 행위를 표현하는 모델링. 상태 다이어그램 활용
        - 기능 모델링: 프로세스들의 자료 흐름을 중심으로 처리 과정을 표현하는 모델링. 자료 흐름도(DFD)활용.
    - 비용산정 모형 분류
      - 하햐식 산정방법: 경험이 많은 전문가에게 비용산정 의뢰 또는 전문가와 조정자를 통해 비용산정
        - 전문가 판단
        - 델파이 기법: 전문가의 경험적 지식을 통한 문제 해결 및 미래 예측을 위한 기법
      - 상향식 산정방법: 세부적인 요구사항과 기능에 따라 필요한 비용 산정
        - 코드라인 수(LoC; Lines of Code): 원시 코드 라인수의 낙관치, 중간치, 비관치를 측정하여 예측치를 구해 비용 산정
        - Man Month: 한 사람이 1개월 동안 할 수 있는 일의 양을 기준으로 비용 산정
        - COCOMO: 보헴이 제안한 모형. 프로그램의 규모에 따라 비용산정
          - 조직형(Organic Mode): 5만 라인 이하
          - 반 분리형(Semi-Detached Mode): 30만 라인 이하
          - 임베디드형(Embedded Mode): 30만 라인 이상
          - 푸트남(Putnam): 개발주기의 단계별로 요구할 인력의 분포를 가정하는 방식
          - 기능점수(FP) 모형: 소프트웨어 기능을 증대시키는 요인별로 가중치를 부여하여 비용 산정
      - 비용 산정 자동화 추정 도구
        - SLIM: Rayleigh-Norden 곡선과 Putnam 예측 모델을 기초로 하여 개발된 자동화 추정 도구
        - ESTIMACS: 다양한 프로젝트와 개인별 요소를 수용하도록 FP 모형을 기초로 하여 개발된 자동화 추정 도구
      - 일정관리 모델: 프로젝트가 일정 기한 내에 완료될 수 있도록 관리하는 모델
        - 주 공정법(CPM): 여러 작업의 수행 순서가 얽혀있는 프로젝트의 일정을 계산하는 기법
          - 주 공정(Critical Path: 임계 경로): 프로젝트의 시작에서 종료까지 가장 긴 시간이 걸리는 경로
        - PERT: 일의 순서를 계획적으로 정리하기 위한 수렴 기법. 비관치, 중간치, 낙관치를 이용
        - 중요 연쇄 프로젝트 관리(CCPM): 주 공정 연쇄법으로 자원제약사항을 고려하여 일정을 작성하는 기법
2. 현행 시스템 분석(중요도: ★★★)
   - 현행 시스템 파악: 현행 시스템이 어떤 기술 요소를 사용하는지 파악하는 활동
   - 현행 시스템 파악 절차
     - 구성/기능/인터페이스 파악 -> 아키텍처 및 소프트웨어 구성 파악 -> 하드웨어 및 네트워크 구성 파악
   - 소프트웨어 아키텍처: 여러가지 소프트웨어 구성요소와 그 구성요소가 가진 특성 중 외부에 드러나는 특성, 그리고 구성요소 간의 관계를 표현하는 시스템의 구조나 구조체
   - 소프트웨어 아키텍처 4+1 뷰: 고객의 요구사항을 정리해놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어적인 접근 방법
     - 유스케이스 뷰: 유스케이스 또는 아키텍처를 도출하고 설계하며 다른 뷰를 검증하는데 사용되는 뷰
     - 논리 뷰: 시스템의 기능정인 요구사항이 어떻게 제공되는지 설명 해 주는 뷰
     - 구현 뷰: 개발환경 안에서 정적인 소프트웨어 모듈의 구성을 보여주는 뷰. 컴포넌트 구조와 의존성을 보여주고 부가적인 정보를 정의
     - 배포 뷰: 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가를 매핑해서 보여주는 뷰
   - 소프트웨어 아키텍처 패턴 유형
     - 계층화 패턴(Layered Pattern): 시스템을 계층으로 구분하여 구성하는 패턴
     - 클라이언트-서버 패턴(Client-Server Pattern): 하나의 서버와 다수의 클라이언트로 구성된 패턴
     - 파이프-필터 패턴(Pipe-Filter Pattern): 데이터스트림을 생성하고 처리하는 시스템에서 사용 가능한 패턴. 재사용성이 좋고, 추가가 쉬워 확장에 용이
     - 브로커 패턴(Broker Pattern): 분리된 컴포넌트들로 이루어진 분산 시스템에서 사용. 각 컴포넌트들의 원격 서비스 실행을 통해 상호작용 가능
     - MVC 패턴: 대형 어플리케이션을 3개의 서브 시스템으로 구조화한 패턴. 컴포넌트로 분리되어있어 서로 영향을 받지 않고 개발 작업 수행 가능
       - 모델: 핵심 기능과 데이터 보관
       - 뷰: 사용자에게 정보 표시
       - 컨트롤러: 사용자로부터 요청을 입력받아 처리
   - 소프트웨어 아키텍처 비용 평가 모델 종류
     - SAAM: 변경 용이성과 기능성에 집중, 경험이 없는 조직에서도 활용 가능한 비용 평가 모델
     - ATAM: 아키텍처 품질 속성을 만족시키는지 판단 및 품질속성들의 이해 상층관계까지 평가하는 모델
     - ADR: 소프트웨어 아키텍처 구성요소 간 응집도 평가 모델
     - ARID: 전체 아키텍처가 아닌 특정부분에 대한 품질요소에 집중하는 비용 평가 모델
   - 디자인 패턴: 소프트웨어 설계에서 공통으로 발생하는 문제에 대하여 자주 쓰이는 설계 방법을 정리한 패턴
   - 디자인 패턴 유형
     - 목적
       - 생성: 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행하는 패턴.
       - 구조: 클래스나 객체의 조합을 다루는 패턴
       - 행위: 클래스나 객체들이 상호 작용하는 방법과 역할 분담을 다루는 패턴
     - 범위
       - 클래스: 상속 관계를 다루는 패턴, 컴파일 타임에 정적으로 결정
       - 객체: 객체 간 관련성을 다루는 패턴, 런타임에 동적으로 결정
   - 디자인 패턴 종류
     - 생성패턴: 빌더, 프로토타입, 팩토리메소드, 추상팩토리, 싱글턴
     - 구조패턴: 브릿지, 데코레이터, 퍼사드, 플라이웨이트, 프록세, 컴포짓, 어댑터
     - 행위패턴: 메디에이터, 인터프리터, 이터레이터, 템플릿메소드, 옵저버, 상태, 비지터, 커맨드, 전략, 메멘토, Chain of Responsibility
   - 운영체제(OS): 컴퓨터 사용자와 컴퓨터 하드웨어간의 인터페이스를 담당하는 프로그램
     - 운영체제의 종류
       - PC: 윈도우, 유닉스, 리눅스
       - 모바일: 안드로이드, IOS
   - OSI 계층: 네트워크 통신에서 충돌문제를 완화하기 위해 국제 표준화 기구(ISO)에서 제시한 모델
     - 응용 계층(Application): 사용자와 네트워크간 응용 서비스 연결, 데이터 생성
     - 표현 계층(Presentation): 데이터 형식 설정과 부호 교환, 암호화/복호화
     - 세션 계층(Session): 연결 접속 및 동기 제어
     - 전송 계층(Transport): 신뢰성 있는 통신 보장, 데이터 분할과 재조립, 흐름 제어, 혼잡제어 담당
     - 네트워크 계층(Network): 단말 간 데이터 전송을 위한 최적화된 경로 제공
     - 데이터 링크 계층(Data Link): 인접 시스템 간 데이터 전송, 전송오류 제어
     - 물리 계층(Physical): 0과 1의 비트 정보를 회선에 보내기 위한 전기적 신호로 변환
   - DBMS: 데이터의 집합을 만들고, 저장 및 관리 할 수 있는 기능들을 제공하는 응용 프로그램
   - 미들웨어: 분산컴퓨팅 환경에서 응용 프로그램과 프로그램이 운영되는 환경 간에 원만한 통신이 이루어질 수 있도록 제어해주는 소프트웨어. 대표적인 미들웨어: WAS
     - 웹 어플리케이션 서버(WAS): 서버 계층에서 애플리케이션이 동작 할 수 있는 환경을 제공하고 안정적인 트랜잭션 처리와 관리, 다른 이기종의 시스템과 애플리케이션 연동을 지원하는 서버

3. 요구사항 확인(중요도 ★★★)
   - 요구공학(Requirements Engineering): 사용자의 요구가 반영된 시스템을 개발하기 위해 사용자 요구사항에 대한 도출, 분석, 명세, 확인 및 검증하는 구조화된 활동.
   - 요구사항의 분류
     - 기능적 요구사항: 시스템이 제공하는 기능, 서비스에 대한 요구사항
       - 특정 입력/상황에 대해 시스템이 어떻게 반응/동작해야하는지에 대한 기술
       - 특성: 기능성, 완전성, 일관성
     - 비기능적 요구사항: 시스템 구축에 대한 제약사항에 관한 요구사항
       - 품직속성에 관련하여 시스템이 갖춰야할 사항에 관한 기술, 시스템이 준수해야할 제한 조건에 관한 기술
       - 특성: 신뢰성, 사용성, 효율성, 유지보수성, 이식성, 보안성 및 품질 관련 요구사항, 제약사항
   - 요구공학 프로세스: 도출 -> 분석 -> 명세 -> 확인 및 검증
   - 요구사항 도출 단계 주요 기법
     - 인터뷰, 브레인스토밍, 델파이기법, 롤플레잉, 설문조사
       - 델파이기법: 전문가의 경험적 지식을 통해 문제해결 및 미래예측을 위한 방법
   - 요구사항 확인 및 검증 단계의 주요 기법
     - 요구사항 검토: 여러 검토자들이 에러, 잘못된 가정, 불명확성, 표준과의 차이를 검토
     - 정형 기술 검토 활용
       - 동료검토: 2~3명 리뷰 진행, 요구사항 명세서를 설명하고 이해관계자들이 들으면서 결함을 발견하는 형태로 진행
       - 워크스루: 검토자료를 회의 전에 배포하여 짧은 시간동안 회의를 진행하는 형태로 리뷰를 통해 오류를 검출하고 문서화
       - 인스펙션: 소프트웨어 요구, 설계 원시 코드 등의 저작자 외의 다른 전문가 또는 팀이 검사하여 오류를 찾아내는 공식적 검토 방법
     - 프로토타이핑 활용: 프로토타입(견본품)을 통해 효과적으로 요구 분석을 수행하면서 명세서를 산출하는 작업
     - 모델 검증: 분석단계에서 개발된 모델의 품질 검증 필요
     - 테스트케이스 및 테스트를 통한 확인: 각각의 요구사항을 어떻게 확인 할 것인지에 대한 계획을 수립하고 테스트케이스 작성
     - CASE 도구 활용 검증: 자동화된 일관성 분석을 제공하는 CASE 도구 활용
     - 베이스라인을 통한 검증: 요구사항 변경을 체계적으로 추적하고 통제하는 시점인 베이스라인을 통한 요구사항에 대한 지속적 검증 수행
     - 요구사항 추적표(RTM)을 통한 검증: 요구사항 정의서를 기준으로 개발 단계별 최종 산출물이 어떻게 반영되고, 변경되었는지 확인 가능한 문서

4. 분석 모델 확인하기(중요도 ★)
   - 분석모델 검증 방법: 유스케이스 모델 검증, 개념수준의 분석 클래스 검증, 분석 클래스 검증

## 2. 화면설계

1. UI 요구사항 확인(중요도 ★★★)
   - UI: 사용자와 시스템 사이에서 의사소통 할 수 있도록 고안된 물리적, 가상의 매개체
   - UI 유형
     - CLI(Command Line Interface): 명령어를 텍스트로 입력하여 조작하는 인터페이스
     - GUI(Graphical User Interface): 그래픽 환경을 기반으로 마우스나 전자펜을 이용한 사용자 인터페이스
     - NUI(Natural User Interface): 신체부위를 이용하는 사용자 인터페이스
     - OUI(Organic User Interface): 현실에 존재하는 모든 사물이 입출력장치로 변화할 수 있는 인터페이스
   - UI 설계 원칙
     - 직관성: 누구나 쉽게 이해하고 사용할 수 있어야 함.
     - 유효성: 정확하고 완벽하게 사용자의 목표가 달성될 수 있어야 함.
     - 학습성: 초보와 숙련자 모두가 쉽게 배우고 사용할 수 있게 제작
     - 유연성: 사용자의 요구사항을 최대한 수용하고, 실수를 방지 할 수 있도록 제작
   - UI 설계 지침: 사용자 중심, 일관성, 단순성, 결과 예측 가능, 가시성, 표준화, 접근성, 명확성, 오류발생해결
   - UI 품질 요구사항(ISO/IEC 9126기반)
     - 기능성: 실제 수행 결과와 품질 요구사항과의 차이를 분석, 시스템 동작을 관찰하기 위한 품질 기준
       - 적절성, 정밀성, 상호운용성, 보안성, 호환성
     - 신뢰성: 시스템이 일정한 시간 또는 작동되는 시간동안 의도하는 기능을 수행함을 보증하는 품질 기준
       - 성숙성, 고장 허용성, 회복성
     - 사용성: 사용자와 컴퓨터 사이에 발생하는 어떠한 행위를 정확하고 쉽게 인지할 수 있는 품질 기준
       - 이해성, 학습성, 운용성
     - 효율성: 할당된 시간에 한정된 자원으로 얼마나 빨리 처리할 수 있는가에 대한 품질 기준
       - 시간 효율성, 자원 효율성
     - 유지보수성: 요구사항을 개선하고 확장하는 데 있어 얼마나 용이한가에 대한 품질 기준
       - 분석성, 변경성, 안정성, 시험성
     - 이식성: 다른 플랫폼에서도 추가 작업 없이 얼마나 쉽게 적용 가능한가에 대한 품질기준
       - 적용성, 설치성, 대체성
   - UI표준: 디자인 철학과 원칙 기반하에 전체 시스템에 공통으로 적용되는 화면 간 이동, 화면구성 등에 관한 규약.
   - CRUD(Create, Read, Update, Delete): 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능
   - UI 개발을 위한 주요 기법
     - 3C 분석: 고객(Customer), 자사(Company), 경쟁사(Competitor)를 비교하고 분석하여 자사를 어떻게 차별화해서 경쟁에서 이길 것인가를 분석하는 기법
     - SWOT분석: 기업의 내외부 환경을 분석하여 Strength(강점), Weakness(약점), Opportunity(기회), Treat(위협) 요인을 규정하고 이를 토대로 경영 전략을 수립하는 방법
     - 시나리오 플래닝: 상황 변화를 사전에 예측하고 다양한 시나리오를 설계하여 불확실성을 제거하는 경영 전략 방법
     - 사용성 테스트: 사용자가 직접 제품을 사용하면서 시나리오에 맞춰 과제를 수행한 후 질문에 응답하는 테스트
     - 워크숍: 특정 문제나 과제에 대한 새로운 지식, 기술, 아이디어, 방법 등을 서로 교환하고 검토하는 세미나
   - UI 화면 설계 구분
     - 와이어프레임: 화면 단위의 레이아웃을 설계하는 작업(ppt, 키노트, 스케치, 일러스트)
     - 스토리보드: 서비스 구축을 위한 모든 정보(정책, 프로세스, 와이어프레임, 기능 정의 등)가 담겨있는 설계 산출물(ppt, 키노트, 스케치)
     - 프로토타입: 정적인 화면(와이어프레임, 스토리보드)에 동적 효과를 적용하여 실제 구현된 것 처럼 시뮬레이션 할 수 있는 모형. 전체적인 기능을 간략한 형태로 구현한 시제품(HTML, CSS)

2. UI 설계(중요도 ★★★)
   - UML(Unified Modeling Language): 객체 지향 소프트웨어 개발 과정에서 산출물을 명세화, 시각화, 문서화 할 때 사용되는 모델링 기술과 방법론을 통합해서 만든 표준화된 범용 모델링 언어
   - UML 특징: 가시화 언어, 구축 언어, 명세화 언어
   - UML 구성요소: 사물, 관계, 다이어그램
   - UML 다이어그램:
     - 구조적 다이어그램 / 정적 다이어그램
       - 클래스: 클래스의 **속성 및 연산**과 **클래스간의 정적인 관계**를 표현
       - 객체: 클래스에 속한 사물(객체=인스턴스)를 특정 시점의 객체와 객체 사이의 관계로 표현
       - 컴포넌트: 시스템을 구성하는 물리적인 컴포넌트와 그들 사이의 의존관계 표현
       - 배치: 컴포넌트 사이의 종속성을 표현하고, 물리적 요소들의 위치를 표현
       - 복함체 구조: 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현
       - 패키지: 유스케이스, 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계
     - 행위적 다이어그램 / 동적 다이어그램
       - 유스케이스: 시스템이 제공하고 있는 기능 및 그와 관련된 외부 요소를 사용자 관점에서 표현
       - 시퀀스: 객체 간 동적 상호작용을 시간적 개념을 중심으로 메시지 흐름으로 표현
       - 커뮤니케이션: 동작에 참여하는 객체들이 주고받는 메시지를 표현하고, 객체 간의 연관까지 표현
       - 상태: 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지 표현
       - 활동: 객체의 처리 로직이나 조건에 따른 처리 흐름을 순서대로 표현
       - 타이밍: 객체 간의 상태 변화와 시간 제약을 명시적으로 표현
   - UI 시나리오 문서의 작성요건: 완전성, 일관성, 이해성, 가독성, 추적용이성, 수정용이성
   - UI 설계 도구의 유형
     - 화면 설계 도구: 파워목업, 발사믹 목업, 카카오오븐
     - 프로토타이핑 도구: UX핀, 엑슈어, 네이버 프로토나우
     - UI 디자인 도구: 스케치, Adobe XD
     - UI 디자인 산출물로 작업하는 프로토타이핑 도구: 인버전, 픽사에이트, 프레이머

## 3. 데이터 입출력 구현

1. 논리 데이터 저장소 확인(중요도 ★★★)
   - 데이터 모델: 현실 세계의 정보를 인간과 컴퓨터가 이해할 수 있도록 추상화하여 표현한 모델
   - 데이터 모델 절차: 요구사항 분석 -> 개념적 설계 -> 논리적 설계 -> 물리적 설계
   - 논리 데이터 모델링: 업무의 모습을 모델링 표기법으로 형상화하여 사람이 이해하기 쉽게 표현하는 프로세스
   - 논리적 데이터 모델링 종류
     - 관계 데이터 모델: 테이블 형태, 1;1, N:M
     - 계층 데이터 모델: 트리 형태(상하 관계), 1:N
     - 네트워크 데이터 모델: 그래프 형태, N:M
   - 관계 대수: 관계형 데이터베이스에서 원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적 정형 언어
   - 관계 대수 연산자 종류
     - 일반 집합 연산자
       - 합집합: ∪
       - 교집합: ∩
       - 차집합: -
       - 카티션 프로덕트: ×
     - 순수 관계 연산자
       - 셀렉트: σ
       - 프로젝트: π
       - 조인: ⋈
       - 디비전: ÷
   - 관계해석: 튜플 관계해석과 도메인 해석을 하는 비절차적 언어
   - 논리 데이터 모델링 속성: 개체, 속성, 관계
   - 개체-관계(E-R) 모델: 데이터와 그들간의 관계를 사람이 이해할 수 있는 형태로 표현한 모델
   - 정규화: 데이터 모델에서 중복성을 제거하여 이상 현상을 방지하고, 데이터의 일관성과 정확성을 유지하기 위해 무손실 분해하는 과정
   - 이상현상: 데이터의 중복성으로 인해 릴레이션을 조작할 때 발생하는 비합리적 현상
     - 삽입이상: 불필요한 세부정보가 입력되는 경우
     - 삭제이상: 원치않는 다른 정보가 함께 삭제되는 경우
     - 갱신이상: 특정부분만 수정되어 중복된 값이 모순을 일으키는 경우
   - 정규화 단계
     - 1정규형(1NF): 도메인이 원자 값으로 구성
     - 2정규형(2NF): 부분함수 종속성 제거(완전 함수적 종속을 만족)
     - 3정규형(3NF): 이행함수 종속성 제거
     - 보이스-코드 정규형(BCNF): 결정자 후보 키가 아닌 함수 종속 제거
     - 4정규형(4NF): 다중 값 종속 제거
     - 5정규형(5NF): 조인 종속 제거
   - 반정규화: 정규화된 개체, 속성, 관계에 대해 성능향상과 개발운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법

2. 물리 데이터 저장소 설계(중요도 ★★★)
   - 참조 무결성 제약조건: 릴레이션과 릴레이션 사이에 대한 참조의 일관성을 보장하기 위한 조건
     - 제한: 다른 테이블이 삭제할 테이블을 참조중이면 제거하지 않는 옵션
     - 연쇄: 참조하는 테이블까지 연쇄적으로 제거하는 옵션
     - 널값: 참조되는 릴레이션에서 튜플을 삭제하고, 참조하는 튜플들의 외래값에 NULL 값을 넣는 옵션. 만약 NOT NULL 조건일 시 삭제 연산이 불가능
   - 인덱스: 데이터 레코드를 빠르게 접근하기 위해 '키 값, 포인터' 쌍으로 구성되는 데이터 구조
     - 클러스터드 인덱스: 인덱스의 **키의 순서에 따라 데이터가 정렬**되어 저장되는 방식
     - 넌클러스터드 인덱스: 인덱스의 키값만 정렬되어 있고, **실제 데이터는 정렬되지 않는 방식**
   - 뷰: 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로 구성된 가상 테이블
   - 클러스터: 데이터 액세스 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법. 클러스터의 분포도가 넓을수록 유리함.
   - 파티션: 대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것.
     - 범위분할: 지정한 열의 값을 기준으로 분할.
     - 해시분할: 해시 함수를 적용한 결과 값에 따라 데이터를 분할
     - 리스트분할: 특정 파티션에 저장 될 데이터에 대한 명시적인 제어가 가능한 분할 기법
     - 조합분할: 범위, 해시, 리스트 분할 중 2개 이상의 파티셔닝을 결합하는 방식. 파티션이 너무 클 때 활용.
   - 파티션의 장점: 성능 향상, 가용성 향상, 백업 가능, 경합 감소

3. 데이터베이스 기초 활용하기(중요도 ★★★)
   - 데이터베이스: 다수의 인원, 시스템 또는 프로그램이 사용할 목적으로 통합하여 관리되는 데이터의 집합
   - 데이터베이스의 정의
     - 통합된 데이터: 자료의 중복을 배제한 데이터의 모임
     - 저장된 데이터: 저장 매체에 저장된 데이터
     - 운영 데이터: 조직의 업무를 수행하는 데 필요한 데이터
     - 공용 데이터: 여러 애플리케이션, 시스템들이 공동으로 사용하는 데이터
   - 데이터베이스의 특성
     - 실시간 접근성: 쿼리에 대하여 실시간 응답이 가능해야 함.
     - 계속적인 변화: 새로운 데이터의 삽입, 삭제 갱신으로 항상 최신의 데이터를 유지
     - 동시공용: 다수의 사용자가 동시에 같은 내용의 데이터를 이용 할 수 있어야 함.
     - 내용참조: 사용자가 요구하는 데이터 내용으로 데이터를 찾음
   - 데이터베이스의 종류
     - 파일 시스템: 파일에 이름을 부여하고 저장이나 검색을 위해 논리적으로 그것들을 어디에 위치시켜야 하는지 등을 정의한 뒤 관리하는 데이터베이스 전 단계의 데이터 관리 방식
     - 관계형 데이터베이스 시스템(RDBMS): 관계형 모델을 기반
       - Oracle, SQL Server, MySQL, MariaDB 등
     - 계층형 데이터베이스 시스템(HDBMS): 데이터를 상하 종속적인 관계로 계층화하여 관리
       - IMS, System2000 등
     - 네트워크 데이터베이스 관리시스템(NDBMS): 데이터를 네트워크상의 망상 형태로 표현한 데이터 모델
       - 종류: IDS, IDMS 등
   - DBMS: 데이터 관리의 복잡성을 해결하는 동시에 데이터 추가, 변경, 검색, 삭제 및 백업, 복구, 보안 등의 기능을 지원하는 소프트웨어
   - DBMS 유형
     - 키-값(Key-Value) DBMS: Unique한 키에 하나의 값을 가지고 있는 형태
     - 컬럼 기반 데이터 저장(Column Family Data Store) DBMS: Key 안에 (Column, value) 조합으로 된 여러 개의 필드를 갖는 DBMS
     - 문서 저장(Document Store) DBMS: 값(Value)의 데이터 타입이 문서(Document) 라는 타입을 사용하는 DBMS
     - 그래프(Graph) DBMS: 시멘틱 웹가 온톨로지 분야에서 활용되는, 그래프로 데이터를 표현하는 DBMS
   - DBMS 특징: 무결성, 일관성, 회복성, 보안성, 효율성
   - 빅 데이터: 시스템, 서비스, 조직(회사) 등에서 주어진 비용, 시간 내에 처리 가능한 수십 페타바이트 크기의 비정형 데이터
     - 빅데이터의 특성: 데이터의 양, 데이터의 다양성, 데이터의 속도
       - 비정형 / 반정형 데이터 수집: 내/외부 정제되지 않은 데이터를 확보하여 수집 및 전송하는 기술
       - 정형 데이터 수집: 내/외부 정제된 대용량의 데이터의 수집 및 전송 기술
       - 분산데이터 저장/처리: 대용량 파일의 효과적인 분산 저장 및 처리기술
       - 분산데이터베이스: HDFS 칼럼 기반 데이터베이스로 실시간 랜덤 조회 및 업데이트 가능
         - HDFS: 대용량 데이터의 집합을 처리하는 응용 프로그램에 적합하도록 설계된 하둡 분산 파일 시스템
   - NoSQL: 데이터 저장에 고정된 테이블 스키마가 필요하지 않고 조인 연산을 사용 할 수 없으며, 수평적으로 확장이 가능한 DBMS
     - NoSQL 특성
       - Basically Available: 언제든지 데이터에 접근할 수 있는 속성
       - Soft-State: 외부에서 전송된 정보를 통해 결정되는 속성
       - Eventually Consistency: 일관성이 유지되는 속성
     - NoSQL 유형
       - Key-Value Store: Unique 한 키에 하나의 값을 가지고 있는 형태
       - Column Family Data Store: Key 안에 (column, value) 조합으로 된 여러개의 필드를 갖는 DB
       - Document Store: 값의 데이터 타입이 문서(Document)라는 타입을 사용하는 DB
       - Graph DBMS: 시멘틱 웹과 온톨로지 분야에서 활용되는, 그래프로 데이터를 표현하는 DBMS
         - 시멘틱 웹: 온톨로지를 활용하여 서비스를 기술하고, 온톨로지의 의미적 상호 운용성을 이용해서 서비스 검색, 조합, 중재 기능을 자동화하는 웹.
         - 온톨로지: 실세계에 존재하는 모든 개념들과 개념들의 속성, 그리고 개념들간의 관계 정보를 컴퓨터가 이해할 수 있도록 서술해 놓은 지식 베이스.
   - 데이터 마이닝: 대규로 저장된 데이터 안에서 체계적이고 자동적으로 통계적 규칙이나 패턴을 찾아내는 기술
   - 데이터 마이닝 절차: 목적 설정 -> 데이터 준비 -> 가공 -> 마이닝 기법 적용 -> 정보 검증
   - 데이터 마이닝 주요 기법
   - 분류 규칙: 과거 데이터를 토대로 새로운 레코드의 결과값을 예측하는 기법
   - 연관 규칙: 데이터 안에 항목들 간의 종속관계를 찾아내는 기법
   - 연속 규칙: 연관 규칙에 시간 관련 정보가 포함된 형태의 기법
   - 데이터 군집화: 대상 레코드들을 유사한 특성을 지닌 몇개의 소그룹으로 분할하는 작업

## 4. 통합 구현

1. 연계 요구사항 분석(중요도 ★)
   - 연계 요구사항 분석: 서로 다른 두 시스템, 장치, 소프트웨어를 이어주는 중계 역할을 하는 연계 시스템과 관련된 요구사항을 분석하는 과장
   - 연계 요구사항 분석 참고문서
     - 개체 정의서: 데이터베이스 개념 모델링 단계에서 도출한 개체의 타입과 관련 속성, 식별자 등의 정보를 개괄적으로 명세화한 정의서
     - 테이블 정의서: 논리 및 물리 모델링 과정 설계 산출물
     - 인터페이스 명세서: 인터페이스 정의서에 작성한 항목을 자세히 작성한 것

2. 연계 메커니즘 구성(중요도 ★★☆)
   - 연계 매커니즘: 응용 소프트웨어와 연계 대상 모듈 간의 데이터 연계 시 요구사항을 고려한 연계방법과 주기를 설계하기 위한 메커니즘
     - 기능: 데이터를 생성하며 전송하는 송신 시스템과 송신 데이터를 수신하여 DB에 반영하는 수신 시스템으로 구성
   - 주요 연계 기술
     - 직접 연계
       - DB 링크: 데이터베이스에서 제공하는 DB링크 객체를 이용
       - DB 연결: 수신 시스템의 WAS에서 송신 시스템 DB로 연결하는 DB 커넥션 풀을 생성하고 연계 프로그램에서 해당 DB 커넥션 풀 명을 이용하여 연계
       - API/Open API: 송신 시스템의 DB에서 데이터를 읽어서 제공하는 애플리케이션 프로그래밍 인터페이스 프로그램
       - JDBC: 수신 시스템의 프로그램에서 JDBC 드라이버를 이용하여 송신 시스템DB와 연결
       - 하이퍼 링크: 현재 페이지에서 다른 부분으로 가거나, 전혀 다른 페이지로 이동하게 해주는 속성
     - 간접 연계
       - 연계 솔루션(EAI): 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션들 간의 정보전달, 연계, 통합을 가능하게 해 주는 솔루션
       - Web Service/ESB: 웹 서비스가 설명된 WSDL과 SOAP 프로토콜을 이용한 시스템 간 연계
       - 소켓(Socket): 소켓을 생성하여 포트를 할당하고, 클라이언트의 요청을 연결하여 통신

3. 내외부 연계 모듈 구현(중요도 ★★★)
   - EAI(Enterprise Application Integration): 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션 간의 정보를 전달, 연계 및 통합이 가능하도록 해주는 솔루션.
     - 미들웨어를 이용하여 비즈니스 로직을 중심으로 기업 내 애플리케이션을 통합 연계
   - EAI 구성요소
     - EAI 플랫폼: 이기종 시스템 간 애플리케이션 상호 운영
     - 어댑터: 다양한 애플리케이션을 연결하는 EAI의 핵심 장치로 데이터 입출력 도구
     - 브로커: 데이터 포맷과 코드를 변환하는 솔루션
     - 메시지 큐: 비동기 메세지를 사용하는 다른 응용 프로그램 사이에서 데이터를 송수신하는 기술
     - 비즈니스 워크플로우: 미리 정의된 기업의 비즈니스 workflow에 따라 업무를 처리하는 기능
   - EAI 구축 유형
     - 포인트 투 포인트: 가장 기초적인 애플리케이션 통합방법. 1:1로 단순 통합
     - 허브 앤 스포크: 단일한 접점의 허브 시스템을 통하여 데이터를 전송하는 중앙 집중식 방식
     - 메시지 버스: 애플리케이션 사이 미들웨어를 두어 연계하는 미들웨어 통합 방식
     - 하이브리드: 그룹 내는 허브엔 스포크 방식을 사용, 그룹 간에는 메시지 버스 방식을 사용하는 통합 방식
   - ESB(Enterpirse Service Bus): 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션들 간을 하나의 시스템으로 관리 운영 할 수 있도록 서비스 중심의 통합을 지향하는 아키텍처. 느슨한 결합 방식을 지원(서비스 변경이 있어도 연결된 다른 서비스에 영향이 없음)
     - 미들웨어를 이용하여 서비스 중심으로 서비스를 지원하기 위한 관련 시스템과 유기적 연계
   - ESB 구축 유형: 버스 방식의 분산형 토폴로지 구성
   - 웹 서비스: 네트워크에 분산된 정보를 서비스 형태로 개방하여 표준화된 방식으로 공유하는 기술. 서비스 지향 아키텍처.
   - 웹 서비스 유형
     - SOAP(Simple Objet Access Protocol): HTTP, HTTPS, SMTP 등을 사용하여 XML기반의 메시지를 네트워크 상태에서 교환하는 프로토콜
     - WSDL(Web Service Description Language): 웹 서비스명, 제공 위치, 메시지 포맷, 프로토콜 정보 등 웹서비스에 대한 상세 정보가 기술된 XML 형식으로 구현되어 있는 언어.
     - UDDI(Universal Description, Discovery and Integration): 웹 서비스에 대한 정보인 WSDL를 등록하고 검색하기 위한 저장소로 공개적으로 접근, 검색이 가능한 레지스트.
   - IPC(Inter-Process Communication): 운영체제에서 프로세스 간 서로 데이터를 주고받기 위한 통신 기술.
   - 연계 테스트: 송신 시스템과 수신 시스템을 연계하였을 경우, 데이터의 정합성과 데이터 전송 여부에 대한 테스트.

## 5. 인터페이스 구현

1. 인터페이스 기능 구현(중요도 ★★★)
   - 컴포넌트 명세서: 컴포넌트 개요, 부 클래스의 동작, 인터페이스를 통해 외부와 통신하는 명세
   - 인터페이스 명세서: 컴포넌트 명세서에 명시된 인터페이스 클래스의 세부적인 조건 및 기능을 명시한 명세서.
   - JSON(Javascript Object Notation): 속성-값 쌍 또는 키-값 쌍으로 이루어진 데이터 오브젝트를 전달하기 위해 인간이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷. AJAX에서 많이 사용되고 XML을 대체하는 주요 데이터 포멧.
   - XML(eXtensible Markup Language): HTML의 단점을 보완한 인터넷 언어. SGML의 복잡한 단점을 개선한 특수한 목적을 갖는 마크업 언어
   - AJAX(Asynchronous Javascript And XML): 웹과 같은 분산 하이퍼미디어 환경에서 자원의 존재 / 상태 정보를 표준화된 HTTP 메서드로 주고 받은 웹 아키텍처.
     - REST 메서드: HTTP메서드 중 CRUD메서드만 사용-POST, GET, PUT, DELETE
   - 데이터베이스 암호화 알고리즘
     - 대칭키 알고리즘: 암, 복호화에 같은 암호 키를 쓰는 알고리즘.
     - 비대칭 암호화 알고리즘: 공개키는 누구나 알 수 있지만, 비밀키는 키 소유자만 알 수 있게 사용하는 알고리즘.
     - 해시 암호화 알고리즘: 해시 값으로 원래 입력값으 찾아 낼 수 있는 일방향성의 특성을 가진 알고리즘
   - 중요 인터페이스 데이터의 암호화 전송을 위한 보안 기술
     - IPSec(IP Security): IP계층(3계층)에서 무결성과 인증을 보장하는 인증 헤더(AH)와 기밀성을 보장하는 암호화(ESP)를 이용하여 양 종단 간(End Point) 구간에 보안 서비스를 제공하는 터널링 프로토콜
     - SSL/TLS: 전송계층(4계층)과 응용계층(7계층) 사이에서 클라이언트와 서버 간의 웹 데이터 암호화(기밀성), 상호인증 및 접속 시 데이터 무결성을 보장하는 보안 프로토콜
     - S-HTTP(Secure Hypertext Transfer Protocol): 웹상에서 네트워크 트래픽을 암호화하는 주요 방법. 클라이언트와 서버 간에 전송되는 모든 메세지를 암호화하여 전송

2. 인터페이스 기능 구현 검증(중요도 ★★)
   - 인터페이스 구현 검증 도구
     - xUnit: 자바, C++, .Net 등 다양한 언어를 지원하는 단위테스트 프레임워크
     - STAF: 서비스 호출, 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크
     - FitNesse: 웹 기반 테스트 케이스 설계/실행/결과 확인 등을 지원하는 테스트 프레임워크
     - NTAF: FitNesse(협업기능)+STAP(재사용, 확장성) 통합한 테스트 자동화 프레임워크
     - Selenium: 다양한 브라우저 지원 및 개발언어를 지원하는 웹 어플리케이션 테스트 프레임워크
     - water: 루비(Ruby)기반 웹 애플리케이션 테스트 프레임워크
   - 인터페이스 감시 도구
     - 스카우터(SCOUTER): 애플리케이션에 대한 모니터링 및 DB Agent를 통해 오픈소스 DB 모니터링 기능, 인터페이스 감시 기능을 제공
     - 제니퍼(Jennifer): 애플리케이션의 개발부터 테스트, 오픈, 운영, 안정화까지 전 생애주기 단계동안 성능을 모니터링하고 분석해주는 APM 소프트웨어.

## 7. SQL 응용

1. 데이터베이스 기본(중요도 ★★★)
   - 트랜젝션(Transaction): 인가받지 않은 사용자로부터 데이터를 보장하기위해 DBMS가 가져야하는 특성. 하나의 논리적 기능을 정상적으로 수행하기 위한 작업의 기본 단위.
   - 트랜잭션의 특성
     - 원자성(Atomicity): 트랜잭션의 연산 자체가 성공 또는 실패되어야하는 성질(All or Nothing)
     - 일관성(Consistency): 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 하는 성질
     - 격리성(Isolation): 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않아야 한다는 성질
     - 영속성(Durability): 성공이 완료된 트랜잭션의 결과는 영속적으로 데이터베이스에 저장되어야 하는 성질
   - 트랜잭션 제어어(TCL; Transaction Control Language): 트랜잭션의 결과를 허용하거나 취소하는 목적으로 사용되는 언어
     - TCL 명령어
       - Commit: 트랜잭션을 메모리에 영구적으로 저장하는 명령어
       - Rollback: 트랜잭션 내역의 저장을 무효화시키는 명령어
       - Checkpoint(Savepoint): Rollback을 위한 시점을 지정하는 명령어
   - 데이터 정의어(DDL; Data Definition Language): DB를 구축하거나 수정할 목적으로 사용하는 언어
   - DDL 대상
     - 도메인(Domain): 하나의 속성이 가질 수 있는 원자값들의 집합
     - 스키마(Schema): 데이터베이스의 구조, 제약조건 등의 정보를 담고 있는 기본적인 구조
       - 외부 스키마, 개념 스키마, 내부 스키마
     - 테이블(Table): 데이터 저장 공간
     - 뷰(View): 하나 이상의 물리 테이블에서 유도되는 가상의 테이블
     - 인덱스(Index): 검색을 빠르게 하기 위한 데이터 구조
       - 인덱스 종류
         - 순서 인덱스(Ordered Index): 데이터가 정렬된 순서로 생성되는 인덱스
         - 해시 인덱스(Hash Index): 해시 함수에 의해 직접 데이터에 키 값으로 접근하는 인덱스
         - 비트맥 인덱스(Bitmatp Index): bit 값인 0 또는 1로 변환하여 인덱스 키로 사용하는 인덱스
         - 함수기반 인덱스(Functional Index): 수식이나 함수를 적용하여 만든 인덱스
         - 단일 인덱스(Single Index): 하나의 컬럼으로만 구성한 인덱스
         - 결합 인덱스(Concatenated Index): 두 개 이상의 컬럼으로 구성한 인덱스
         - 클러스터드 인덱스(Clustered Index): 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식(검색 빠름)
         - 넌클러스터드 인덱스(Non-Clustered Index): 인덱스의 키 값만 정렬되어있고 실제 데이터는 정렬되지 않은 방식(데이터 삽입, 삭제 시 데이터 재정렬 해야함)
   - DDL 명령어: CREATE, ALTER, DROP
     - CASCADE: 제거할 요소를 참조하는 다른 모든 개체를 함께 제거
     - RESTRICT: 다른 개체가 제거할 요소를 참조중일때는 제거를 취소
   - 데이터 조작어(DML; Data Manipulation Language): 저장된 데이터를 실질적으로 관리하는데 사용되는 언어
     - DML 유형: SELECT, INSERT, UPDATE, DELETE
   - 데이터 제어어(DCL: Data Control Language): 데이터의 보안, 무결성, 회복, 병행 제어 등을 정의하는데 사용하는 언어
     - DCL 유형
       - GRANT: 사용 권한 부여
       - REVOKE: 사용 권한 취소

2. 응용 SQL 작성하기(중요도 ★)
   - 데이터 분석 함수 종류
     - 집계 함수: 여러 행 또는 테이블 전체 행으로부터 하나의 결괏값을 반환하는 함수
     - 그룹 함수: 소그룹 간의 소계 및 중계 등의 중간 합계 분석 데이터를 산출하는 함수
     - 윈도 함수: 데이터베이스를 사용한 온라인 분석 처리 용도로 사용하기 위해서 표준 SQL에 추가된 기능

3. 절차형 SQL 활용하기(중요도 ★)
   - 절차형 SQL(Precedural SQL): SQL 언어에서도 절차 지향적인 프로그램이 가능하도록 하는 트랜잭션 언어
     - 절차형 SQL 종류
       - 프로시저(Procedural SQL): 일련의 쿼리들을 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합
       - 사용자 정의 함수(User-Defined Function): SQL 처리를 수행하고, 수행 결과를 단일 값으로 반환할 수 있는 절차형 SQL
       - 트리거(Trigger): 데이터베이스 시스템에서 삽입, 갱신, 삭제 등의 이벤트가 발생할 때 마다 관련 작업이 자동으로 수행되는 절차형 SQL

4. 데이터 조작 프로시저 최적화(중요도 ★)
   - 쿼리 성능 개선: 최소의 시간으로 원하는 결과를 얻도록 프로시저를 수정하는 작업
     - SQL성능 개선 절차: 문제있는 SQL 식별 -> 옵티마이저 통계 확인 -> SQL문 재구성 -> 인덱스 재구성 -> 실행계획 유지관리
   - 옵티마이저(Optimizer): SQL이 가장 효율적으로 수행되도록 최적의 경로를 찾아 주는 모듈
     - 옵티마이저 유형
       - 규칙기반 옵티마이저(RBO): 사전에 정의해둔 규칙에 의거하여 경로를 찾는 규칙 기반 옵티마이저
       - 비용기반 옵티마이저(CBO): 각 DBMS마다 고유의 알고리즘에 따라 산출되는 비용으로 최적의 경로를 찾는 비용 기반 옵티마이저
   - 힌트(Hint): 실행하려는 SQL문에 사전 정보를 주어서 SQL문 실행에 빠른 결과를 가져오는 효과를 만드는 문법
     - 옵티마이저의 실행 계획을 원하는대로 변경할 수 있게 한다.
     - 옵티마이저는 명시적인 힌트를 통해 실행 계획을 변경한다.

## 8. 서버 프로그램 구현

1. 개발환경 구축(중요도 ★★★)
   - 개발 도구 분류
     - 빌드 도구: 작성한 코드의 빌드 및 배포를 수행하는 도구(And, Maven, Gradle)
     - 구현 도구: 코드의 작성과 디버깅, 수정 드과 같이 작업 시 사용하는 도구(Eclipse, InteliJ, VS)
     - 테스트 도구: 코드의 기능 검증과 전체의 품질을 높이기 위해 사용하는 도구(xUnit, PMD, Sonar)
     - 형상 관리도구: 산출물에 대한 버전관리를 위한 도구(Git, SVN, CVS)
   - 서버 하드웨어 개발환경
     - 웹 서버: HTTP를 이용한 요청, 응답을 처리(Apache 웹 서버, 구글 웹 서버)
     - 웹 어플리케이션 서버(WAS): 동적 콘텐츠를 처리하고 제공하기 위해 사용(Tomcat, Jeus, Resin)
     - 데이터베이스 서버: 데이터의 수집, 저장을 위한 용도로 사용(MySQL, Oracle, MSSQL)
     - 파일 서버: 파일 저장 하드웨어로 물리 저장 장치를 활용한 서버(HDD, SSD)
   - 소프트웨어 개발환경
     - 운영체제: 사용자 관점에서 편리하고 유용하게 사용하기 위한 소프트웨어
     - 미들웨어: 웹 서버, JVM과 같은 개발 환경의 구성요소로 활용
     - DBMS: 데이터의 저장 및 활용을 위해 DBMS 설치
   - 형상관리(Configuration Management): 소프트웨어 개발을 위한 전체 과정에서 발생하는 모든 항목의 변경사항을 관리하기 위한 활동
     - 형상관리 절차: 형상식별(대상정의) -> 형상통제(버전관리) -> 형상감사(무결성) -> 형상기록(보고서)
   - 소프트웨어 형상 관리 도구 유형
     - 공유 폴더 방식: 매일 개발이 완료된 파일은 약속된 위치의 공유폴더에 복사하는 방식(RCS, SCCS)
     - 클라이언트/서버 방식: 중앙에 버전 관리 시스템을 항시 동작시키는 방식(CVS, SVN)
     - 분산 저장소 방식: 로컬 저장소와 원격 저장소로 분리되어 분산 저장하는 방식(Git)
   - 소프트웨어 형상관리 도구별 특징
     - CVS(Concurrent Versions System): 서버와 클라이언트로 구성되어 있고, 다수의 인원이 동시에 범용적인 운영체제로 접근 가능한 형상 관리 도구
     - SVN(Subversion): 하나의 서버에서 소스를 쉽고 유용하게 관리할 수 있게 도와주는 도구
     - RCS(Revision Control System): 소스 파일의 수정을 한 사람만으로 제한하여 다수의 사람이 파일 수정을 동시에 할 수 없도록 파일 잠금 방식으로 형상을 관리하는 도구
     - Bitkeeper: 중앙 통제 방식으로 대규모 프로젝트에서 빠른 속도를 내도록 개발된 형상 관리 도구
     - Git: 속도에 중점을 둔 분산형 버전 관리 시스템. 대형 프로젝트에서 효과적이고 유용함.
     - Clear Case: 복수 서버, 복수 클라이언트 구조, 필요한 서버를 하나씩 추가하여 확장성을 기할 수 있음.

2. 공통 모듈 구현(중요도 ★★)
   - 모듈(Module): 하나의 완전한 기능을 수행 할 수 있는 독립된 실체
   - 모듈화: 프로그램 개발시 생산성과 최적화, 관리에 용이하게 기능 단위로 분할하는 기법
     - 모듈화의 원리: 정보은닉, 분할과 정복, 데이터 추상화, 모듈 독립성
   - 응집도(Cohesion): 모듈의 독립성을 나타내는 정도로 모듈 내부 구성요소 간 연관 정도
     - 응집도 유형: 우연적 응집도, 논리적 응집도, 시간적 응집도, 절차적 응집도, 통신적 응집도, 순차적 응집도, 기능적 응집도
   - 결합도(Coupling): 외부 모듈과의 연관도 또는 모듈 간의 상호의존성, 모듈간의 관련성을 측정하는 척도.
     - 결합도 유형: 내용결합도, 공통결합도, 외부결합도, 제어결합도, 스탬프결합도, 자료결합도.
   - 응집도는 높을수록 좋고, 결합도는 낮을수록 좋다.
   - 공통 모듈 구현 절차: DTO/VO -> SQL -> DAO -> Service -> Controller -> 화면구현
     - DTO(Data Transfer Object): 프로세스 사이에서 데이터를 전송하는 객체
     - VO(Value Object): 고정 클래스를 가지는 객체
     - DAO(Data Access Object): 특정 타입의 데이터베이스에 추상 인터페이스를 제공하는 객체
   - 팬인 및 팬아웃
     - Fan-In: 어떤 모듈을 제어하는 모듈의 수 / 모듈 자신을 기준으로 모듈에 들어오면 팬인
     - Fan-Out: 어떤 모듈에 의해 제어되는 모듈의 수 / 모듈 자신을 기준으로 모듈에서 나가면 팬아웃
     - 시스템 복잡도를 최적화하기 위해 팬인은 높게, 팬아웃은 낮게 설계해야 한다.
   - 공통 모듈 테스트: IDE 도구를 활용하여 개별 공통 모듈에 대한 디버깅을 수행
     - 통합 개발환경(IDE): 개발에 필요한 다양한 틀을 하나의 인터페이스로 통합하여 제공하는 환경(Eclipse, VS, Android Studio, IDEA)
   - 공통 모듈 테스트 종류
     - 화이트 박스 테스트: 소스 코드를 보면서 테스트 케이스를 다양하게 만들어 테스트
     - 메서드 기반 테스트: 공통 모듈의 외부에 공개된 메서드 기반 테스트
     - 화면 기반 테스트: 화면 단위로 단위 모듈을 개발 후에 화면에 직접 데이터를 입력하여 테스트
       - 테스트 드라이버(Test Driver): 하위 모듈은 있지만, 상위 모듈은 없는 경우 사용
       - 테스트 스텁(Test Stub): 상위 모듈은 있지만 하위 모듈은 없는 경우 사용
   - Junit: 자바 프로그래밍 언어용 단위 테스트 도구

3. 배치 프로그램 구현(중요도 ★)
   - 배치 프로그램(Batch Program): 사용자와의 상호작용 없이 일련의 작업을 작업 단위로 묶어 정기적으로 반복 수행하거나 규칙에 따라 일괄 처리하는 기법
   - 배치 프로그램 유형:
     - 이벤트 배치: 사전에 정의해 둔 조건 충족 시 자동으로 실행
     - 온디맨드 배치: 사용자의 명시적 요구가 있을 때마다 실행
     - 정기 배치: 정해진 시간에 정기적으로 실행
   - 배치 스케줄러: 일괄 처리 작업이 설정된 주기에 맞춰 자동으로 수행되도록 지원하는 도구
   - 배치 스케줄러 종류
     - 스프링 배치(Spring Batch): 오픈소스 프레임워크
     - 쿼츠 스케줄러(Quartz Scheduler): 수행할 작업과 수행시간을 관리하는 요소들을 분리하여 일괄 처리 작업에 유연성을 제공(오픈소스 라이브러리)
   - Cron 표현식: 크론 표현식을 통해 배치 수행 시간을 시간 및 주기 등으로 설정
     - 리눅스 / 유닉스 크론 표현식: 분, 시간, 일, 월, 요일, 연도
     - 쿼츠 크론 표현식: 초, 분, 시간, 일, 월, 요일, 연도

## 9. 소프트웨어 개발 보안 구축

1. 소프트웨어 개발 보안 설계(중요도 ★★★)
   - SW 개발 보안: 소프트웨어 개발 과정에서 지켜야 할 일련의 보안 활동
     - SW 개발 보안 생명주기: 요구사항 명세 -> 설계 -> 구현 -> 테스트 -> 유지보수
   - SW 개발 보안 3대 요소
     - 기밀성(Confidentiality): 시스템 내의 정보와 자원은 인가된 사용자에게만 접근이 허용
     - 무결성(Integrity): 시스템 내의 정보는 오직 인가된 사용자만 수정 할 수 있음
     - 가용성(Availability): 인가받은 사용자는 시스템 내의 정보와 자원을 언제라도 사용할 수 있음
   - DoS(Denial of Service)공격: 시스템을 악의적으로 공격해서 해당 시스템의 자원을 부족하게 하여 원래 의도된 용도로 사용하지 못하게 하는 공격
   - DoS공격의 종류
     - SYN 플러딩(SYN Flooding): 서버의 동시 가용 사용자 수를 SYN 패킷만 보내 점유하여 다른 사용자가 서버를 사용 불가능하게 하는 공격
     - UDP 플러딩(UDP Flooding): 대량의 UDP 패킷을 만들어 임의의 포트 번호로 전송하여 응답 메시지를 생성하게 하여 지속해서 자원을 고갈시키는 공격
     - 스머프(Smurf)/스머핑(Smurfing): 출발지 주소를 대상의 IP로 설정하여 네트워크 전체에게 ICMP Echo 패킷을 직접 브로드캐스팅하여 마비시키는 공격
     - 죽음의 핑(PoD; Ping of Death): ICMP 패킷을 정상적인 크기보다 아주 크게 만들어 전송하여 정상적인 서비스를 못하도록 하는 공격
     - 랜드 어택(Land Attack): 출발지 IP와 목적지 IP를 같은 패킷 주소로 만들어 보내 시스템의 가용성을 침해하는 공격
     - 티어 드롭(Tear Drop): IP 패킷의 재조합 과정에서 잘못된 정보로 인해 수신 시스템이 문제를 발생하도록 만드는 공격
     - 봉크(Bonk)/보잉크(Boink): 프로토콜의 오류 제어를 이용한 공격 기법
   - DDoS(Distributed Denial of Service): 여러 대의 공격자를 분산 배치하여 동시에 동작하게 함으로서 특정 사이트를 공격하는 기법
   - DDoS 공격 도구
     - Trinoo: 많은 소스로부터 통합된 UDP flood 서비스 거부 공격을 유발하는 데 사용되는 도구
     - Tribe Flood Network: 많은 소스에서 하나 혹은 여러 개의 목표 시스템에 대해 서비스 거부 공격을 수행 할 수 있는 도구
     - Stacheldraht: 분산 서비스 거부 에이전트 역할을 하는 Linux 및 Solaris 시스템용 멀웨어 도구
   - DoS 와 DDoS의 차이
     - DoS는 직접 공격, DDoS는 공격하도록 지시
     - DoS는 한 사람에 의해 공격, DDoS는 수많은 감염 호스트를 통해 공격을 감행
   - DRDoS(Distributed Reflection DoS): 공격자는 출발지 IP를 공격대상 IP로 위조하여 다수의 반사 서버로 요청 정보를 전송, 공격 대상자는 반사 서버로부터 다량의 응답을 받아서 서비스 거부가 되는 공격
   - 세션 하이재킹(Session Hijacking): TCP의 세션 관리 취약점을 이용한 공격 기법. 케빈 미트닉이 사용
   - 애플리케이션 공격기법
     - HTTP GET 플러딩: 과도한 Get메시지를 이용하여 웹 서버의 과부하를 유발시키는 공격
     - Slowloris: HTTP GET 메서드를 사용하여 헤더의 최종 끝을 알리는 개행 문자열을 전송하지 않고, 대상 웹 서버와 연결상태를 장시간 지속시키고 연결 자원을 모두 소진시키는 서비스 거부 공격
     - RUDY: 요청 헤더의 Content-Length를 비정상으로 크게 설정하여 메시지 바디 부분을 매우 소량으로 보내 계속 연결 상태를 유지시키는 공격
     - Slow HTTP Read DoS: 다수 HTTP 패킷을 지속적으로 전송하여 웹 서버의 연결상태가 장시간 지속, 연결자원을 소진시키는 서비스 거부 공격
     - Hulk DoS: 공격자가 웹 페이지 주소를 지속적으로 변경하면서 다량으로 GET 요청을 발생시키는 서비스 거부 공격
     - Hash DoS: 많은 수의 파라미터를 POST 방식으로 웹서버로 전달하여 다수의 해시 충돌을 발생시켜서 자원을 소모시키는 서비스 거부 공격
   - 네트워크 공격
     - 스니핑: 공격대상의 데이터만 몰래 들여다보는 수동적인 공격 기법
     - 네트워크 스캐너, 스니퍼: 네트워크 하드웨어 및 소프트웨어의 구성 취약점 파악을 위해 공격자가 취약점을 탐색하는 공격 도구
     - 패스워드 트래킹
       - 사전 크래킹: ID 와 PW가 될 가능성이 있는 단어를 파일로 만들어 파일의 단어를 대입하여 크랙하는 공격 기법
       - 무차별 크래킹: 무작위로 패스워드의 자리에 대입하여 패스워드를 알아내는 공격 기법
       - 패스워드 하이브리드 공격: 사전공격 + 무차별 공격
       - 레인보우 테이블 공격: 크래킹 하고자 하는 해시 값을 테이블에서 검색해서 역으로 패스워드를 찾는 공격 기법
     - IP 스푸핑: 침입자가 인증된 컴퓨팅 시스템인것처럼 속여서 인증된 호스트의 IP주소로 위조하여 타깃에 전송하는 공격 기법
     - ARP 스푸핑: 공격자가 특정 호스트의 MAC 주소를 자신의 MAC 주소로 위조한 ARP Reply를 만들어 희생자에게 지속적으로 전송
     - ICMP Redirect 공격: 스니핑 시스템을 네트워크에 존재하는 또다른 라우터라고 알림으로써 패킷의 흐름을 바꾸는 공격기법
     - 트로이 목마: 악성 루틴이 숨어있는 프로그램. 실행하면 악성코드를 실행.
   - 버퍼 오버플로우(Buffer Overflow) 공격: 메모리에 할당된 버퍼 크기를 초과하는 양의 데이터를 입력하여 프로세스의 흐름을 변경시켜서 악성코드를 실행시키는 공격 기법
   - 백도어(Backdoor): 허가받지 않고 시스템에 접속하는 권리, 정상적인 인증 절차를 우회하는 기법
   - 보안 관련 용어
     - 스피어 피싱(Spear phishing): 발송 메일의 본문 링크나 첨부된 파일을 클릭하도록 유도해서 사용자의 개인정보를 탈취하는 공격기법
     - 스미싱(Smishing): SMS를 이용하여 개인 비밀정보를 요구하거나 휴대폰 소액 결제를 유도하는 피싱 공격
     - 큐싱(Qshing): QR코드를 통해 악성 앱을 내려받도록 유도하여 금융 정보 등을 빼내는 피싱 공격
     - 봇넷(Botnet): 악성 프로그램이 감염되어있는 컴퓨터들이 네트워크로 연결된 형태
     - APT 공격(Advanced Persistent Threat): 다양한 수단을 통한 지속적이고 지능적인 맞춤형 공격 기법
     - 공급망 공격(Supply Chain Attack): SW 개발사의 네트워크에 침투하여 악의적으로 코드를 삽입, 서버 배포하여 사용자가 설치 또는 업데이트시에 자동적으로 감염되도록 하는 공격 기법.
     - 제로데이 공격(Zero Day Attack): 보안 취약점이 발견되어 널리 공표되기 전에 해당 취약점을 이용하여 이루어지는 보안 공격기법
     - 웜(Worm): 스스로 복제하여 네트워크 등의 연결을 통하여 전파하는 악성 소프트웨어 프로그램
     - 악성 봇(Malicious Bot): 해커의 명령에 의해 원격에서 제어 또는 실행이 가능한 프로그램 또는 코드
     - 사이버 킬 체인(Cyber Kill Chain): 공격형 방위 시스템. APT 공격방어 분석 모델
     - 랜섬웨어(Randomware): 시스템의 파일을 암호화하여 인질처럼 잡고 몸값을 요구하는 악성 소프트웨어
     - 이블 트윈(Evil Twin)공격: 핫스팟에 연결한 무선 사용자들의 정보를 탈취하는 무선 네트워크 공격 기법
   - 서버 인증의 기능: 스니핑 방지(SSL인증서 설치), 피싱 방지, 데이터 변조 방지, 기업 신뢰도 향상(기업 인증)
   - 인증 기술의 유형
     - 지식기반 인증: 사용자가 기억하고 있는 지식(ID/PW)
     - 소지기반 인증: 소지하고 있는 사용자 물품(공인인증서, OTP)
     - 생체기반 인증: 고유한 사용자의 생체 정보(홍채, 얼굴, 지문)
     - 특정기반 인증: 사용자의 특징을 활용(서명, 몸짓)
   - 접근 통제 기법
     - 식별(Identification): 자신이 누구라고 시스템에 밝히는 행위
     - 인증(Authentication): 주체의 신원을 검증하기 위한 활동
     - 인가(Authorization): 인증된 주체에게 접근을 허용하는 활동
     - 책임추적성(Accountability): 주체의 접근을 추적하고 행동을 기록하는 활동
   - 서버 접근 통제 유형
     - 임의적 접근통제(DAC): 신분에 근거하여 객체에 대한 접근을 제한하는 방법
     - 강제적 접근 통제(MAC): 주체가 갖는 접근 허가 권한에 근거하여 객체에 대한 접근을 제한하는 방법
     - 역할 기반 접근 통제(RBAC): 중앙 관리자가 조직 내 맡은 역할에 기초하여 자원에 대한 접근을 제한하는 방법
   - 접근 통제 보호 모델
     - 벨-라파듈라 모델(BLP): 미 국방부지원 보안 모델. 보안요소 중 기밀성을 가중하며 강제적 정책에 의해 접근을 통제하는 모델
       - No Read Up: 보안 수준이 낮은 주체는 보안수준이 높은 객체를 읽어서는 안됨.
       - No Write Down: 보안수준이 높은 주체는 보안수준이 낮은 객체에 기록하면 안됨.
     - 비바 모델: 무결성을 보장하는 최초 모델
       - No Read Down: 높은 등급의 주체는 낮은 등급의 주체를 읽을 수 없음
       - No Write Up: 낮은 등급의 주체는 상위 등급의 객체를 수정 할 수 없음
   - 암호 알고리즘(Encryption Algorithm): 데이터의 무결성 및 기밀성 확보를 위해 정보를 쉽게 해독 할 수 없는 형태로 변환하는 기법
   - 양방향 방식: 대칭 키 암호 방식. 비대칭 키 암호 방식
   - 일방향 해시함수 방식: MDC, MAC
   - 대칭 키 암호 방식: 암호화와 복호화에 같은 암호 키를 쓰는 알고리즘
   - 블록 암호 방식: 고정길이의 블록을 암호화하여 반복하는 알고리즘(EDS, AES, SEED)
   - 스트림 암호 방식: 매우 긴 주기의 난수열을 발생시켜 평문과 더불어 암호문을 생성하는 방식(RC4)
   - 비대칭 키 암호 방식: 개인 키를 나눠 가지지 않은 사용자들이 안전하게 통신하는 방식. 공개키는 누구나 알 수 있으나 개인키는 키의 소유자만 알고있어야 한다.(RSA, 디피-헬만)
   - 일방향 암호 방식(해시 암호 방식): 임의 길이의 정보를 입력받아, 고정된 길이의 암호문(해시값)을 출력하는 암호 방식
     - MAC: 키를 사용하는 메시지 인증 코드로 메시지의 무결성과 송신자의 인증 보장
     - MDC: 키를 사용하지 않는 변경 감지 코드로 메시지의 무결성 보장
   - 대칭키 암호화 알고리즘
     - DES: 1975년 IBM 개발, 대칭 키 기반
     - SEED: 1999년 한국인터넷진흥원(KISA) 개발
     - AES: 2001년 미국 표준기술연구소(NIST)개발
     - ARIA: 2004년 국가정보원과 산학연구협회가 개발
     - IDEA: DES 대체, 스위스 연방기술기관 개발
     - LFSR: 선형함수로 계산되는 구조로 되어있는 스트림 암호화 알고리즘
   - 비대칭키 암호화 알고리즘
     - 디피-헬만: 최초의 공개키 알고리즘
     - RSA: 1977년 MIT 개발
     - ElGamal: 1984년 ElGamal 개발
     - ECC: 1985년 RSA 대안으로 개발
   - 해시 암호화 알고리즘
     - MD5: MD4 개선한 암호화 알고리즘. 파일의 무결성 검사에 사용
     - SHA-1: 1993년 NSA에 미국 정부 표준 지정
     - SHA-256/384/512: 256비트의 해시값을 생성하는 해시함수
     - HAS-160: 국내 표준 서명 알고리즘
     - HAVAL: 메시지를 1024bits 블록으로 나눔
   - IPSec(Internet Protocol Security): 무결성과 인증을 보장하는 인증헤더와 기밀성을 보장하는 암호화를 이용한 IP 보안 프로토콜
   - SSL(Secure Socket Layer)/TLS(Transport Layer Security): 클라이언트와 서버간의 웹데이터 암호화(기밀성), 상호 인증 및 전송시 데이터 무결성을 보장하는 보안 프로토콜
   - S-HTTP(Secure Hypertext Transfer Protocol): 웹상에서 네트워크 트래픽을 암호화하는 방법

2. 소프트웨어 개발 보안 구현(중요도 ★★★)
   - 시큐어 코딩 가이드: 설계 및 구현 단계에서 해킹 등의 공격을 유발할 가능성이 있는 잠재적인 보안 취약점을 사전에 제거하고, 외부 공격으로부터 안전한 소프트웨어를 개발하는 기법
     - 보안 취약점: 운영 단계의 보안 리스크
     - 보안 약점: 개발 단계의 보안 리스크
   - 입력 데이터 검증 및 표현: 입력 데이터로 인해 발생하는 문제들을 예방하기 위해 구현 단계에서 검증해야 하는 보안 점검 항목
   - 입력 데이터 검증 및 표현 취약점
     - XSS(Cross Site Script): 검증되지 않은 외부입력 데이터가 포함된 웹페이지를 사용자가 열람함으로써 웹페이지에 포함된 부적절한 스크립트가 실행되는 공격
       - 대책: 특수문자 필터링, HTML태그 사용 금지
     - 사이트 간 요청 위조(CSRF; Cross-Site Request Forgery): 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위를 특정 웹 사이트에 요청하게 하는 공격
       - 대책: 입력화면 폼 POS 방식 사용, 세션별 CSRF 토큰 사용
     - SQL 삽입(Injection): 악의적인 SQL 구문을 삽입, 실행시켜 데이터베이스의 접근을 통해 정보를 탈취하거나 조작 등의 행위를 하는 공격
       - 대책: 변수 타입 지정, 사용자 입력값 모두 체크하여 필터링
   - 보안 기능: 소프트웨어 개발 단계에서 인증, 접근제어, 기밀성, 암호화, 권한 관리 등을 적절하게 구현하기 위한 보안 점검 항목
   - 에러 처리:  프로그램 실행 시 발생하는 에러를 예외 처리하지 못하거나, 에러에 중요한 정보가 포함될 때 발생할 수 있는 취약점을 예방하기 위한 보안 점검 항목
   - 세션 통제: 세션과 관련되어 발생할 수 있는 취약점을 예방하기 위한 보안 점검 항목
   - 코드 오류: 개발자의 실수로 발생하는 프로그램 오류를 예방하기 위한 보안 점검 항목
   - 캡슐화: 외부에 은닉이 필요한 중요한 데이터와, 인가되지 않은 사용자들에게 노출되지 않게 보안 취약점을 예방하기 위한 보안 검증 항목
   - API 오용: 보안에 취약한 API를 오용하여 발생할 수 있는 보안 취약점 예방을 위한 보안 검증 항목
   - 네트워크 보안 솔루션
     - 방화벽(Firewall): 기업 내부, 외부 간 트래픽을 모니터링하여 시스템의 접근을 허용/차단하는 시스템
     - 웹 방화벽(WAF; Web Application Firewall): 단말기가 내부 네트워크에 접속을 시도할 때 이를 제어하고 통제하는 기능을 제공하는 솔루션
     - 네트워크 접근 제어(NAC; Network Access Control): 단말기가 내부 네트워크에 접속을 시도 할 때 이를 제어하고 통제하는 기능을 제공하는 솔루션
     - 침입 탐지 시스템(IDS; Intrusion Detection System): 네트워크에 발생하는 이벤트를 모니터링하고, 보안정책 위반 행위를 실시간으로 탐지하는 시스템
     - 침입 방지 시스템(IPS; Intrusion prevention System): 네트워크에 대한 공격이나 침입을 실시간적으로 차단하고, 유해트래픽에 대해 능동적으로 조치하는 시스템
     - 무선 침입 방지 시스템(WIPS; Wireless Intrusion Prevention System): 무선 단말기의 접속을 자동 탐지 및 차단하고 보안에 취약한 무선공유기를 탐지하는 시스템
     - 통합 보안 시스템(UTM; Unified Threat Management): 다양한 보안 장비의 기능을 하나의 장비로 통합하여 제공하는 시스템
     - 가상사설망(VPN; Virtual Private Network): 인터넷과 같은 공중망에 인증, 암호화, 터널링 기술을 활용해 마치 전용망을 사용하는 효과를 가지는 보안 솔루션
   - 시스템 보안 솔루션
     - 스팸 차단 솔루션(Anti-Spam Solution): 메일 서버 앞단에 위치하여 Proxy 메일 서버로 동작
     - 보안 운영체제(Secure OS): 컴퓨터 운영체제의 커널에 보안 기능을 추가한 솔루션
   - 콘텐츠 유출 방지 솔루션
     - 보안 USB: 정보 유출 방지 등의 보안 기능을 갖춘 USB 메모리
     - 데이터 유출 방지(DLP; Data Loss Prevention): 조직 내부의 중요 자료가 외부로 빠져나가는 것을 탐지하고 차단하는 솔루션
     - 디지털 저작권 관리(DRM): 디지털 저작물에 대한 보호와 관리를 위한 솔루션
   - 소프트웨어 개발 보안테스트 유형
     - 정적 분석: SW를 실행하지 않고 보안 약점을 분석. 개발 단계.
     - 동적 분석: SW를 실행환경에서 보안 약점 분석. 시험 단계.
   - 비즈니스 연속성 계획(BCP: Business Continuity Plan): 각종 재해, 장애, 재난으로부터 위기관리 기반으로 재해복구, 업무복구 및 재개, 비상계획 등을 통해 비즈니스 연속성을 보장하는 체계

## 10. 애플리케이션 테스트 관리

1. 애플리케이션 테스트 케이스 설계(중요도 ★★★)
   - 애플리케이션 테스트: 애플리케이션에 잠재되어있는 결함을 찾아내는 일련의 행위 또는 절차
   - 애플리케이션 테스트 원리
     - 완벽한 테스팅은 불가능: 결함을 줄일 수 는 있으나, 결함이 없다고 증명 할 수는 없음
     - 파레토 법칙: 20%에 해당하는 코드에서 전체 결함의 80%가 발견된다는 법칙
     - 살축제 패러독스: 동일한 테스트를 반복하면 더이상 결함이 발견되지 않는 현상
     - 정황 의존성: 소프트웨어 성격에 맞게 테스트 실시
     - 오류-부재의 쉐변: 요구사항을 충족시켜주지 못한다면, 결함이 없다고 해도 품질이 높다고 볼 수 없음.
   - 프로그램 실행 여부에 따른 분류
     - 정적 테스트: 테스트 대상을 실행하지 않고, 구조를 분석하여 논리성을 검증하는 테스트(리뷰, 정적 분석)
     - 동적 테스트: 소프트웨어를 실행하는 방식으로 테스트를 수행하여 결함을 검출하는 테스트(화이트박스 테스트, 블랙박스 테스트, 경험기반 테스트)
   - 화이트박스 테스트: 원시 코드의 논리적인 모든 경로를 테스트하여 테스트케이스를 설계하는 방법(구조 검사)
   - 화이트박스 테스트 유형
     - 구문(문장) 커버리지: 프로그램 내의 모든 명령문을 적어도 한 번 수행하는 커버리지
     - 결정(선택, 분기) 커버리지: 결정 포인트 내의 전체 조건식이 적어도 한 번은 참과 거짓의 결과가 도출되도록 수행하는 커버리지.
     - 조건 커버리지: 결정 포인트 내의 각 개별 조건식이 적어도 한 번은 참과 거짓의 결과가 되도록 수행하는 커버리지
     - 조건/결정 커버리지: 개별 조건식이 다른 개별 조건식에 영향을 받지 않고 전체 조건식에 독립적으로 영향을 주도록 하는 커버리지
     - 다중 조건 커버리지: 결정 조건 내 모든 경로를 테스트하는 기법
     - 기본 경로 커버리지: 수행 가능한 모든 경로를 테스트하는 기법
     - 제어 흐름 테스트: 프로그램 제어 구조를 그래프 형태로 나타내어 내부 로직을 테스트하는 기법
     - 데이터 흐름 테스트: 제어 흐름 그래프에 사용현황을 추가한 테스트 기법
   - 블랙박스 테스트: 사용자의 요구사항 명세를 보면서 수행하는 테스트(기능검사)
   - 블랙박스 테스트 유형
     - 동등 분할 테스트: 입력데이터의 영역을 유사한 도메인별로 유효값/무효값을 그룹핑하여 대푯값 테스트 케이스를 도출하여 테스트 하는 기법
     - 경곗값 분석 테스트: 입력 조건의 경계값을 테스트 케이스로 선정하여 검사하는 기법
     - 결정 테이블 테스트: 요구사항의 논리와 발생조건을 테이블 형태로 나열하여, 조건과 행위를 모두 조합해 테스트
     - 상태 전이 테스트: 이벤트에 의해 어느 한 상태에서 다른 상태로 전이되는 경우의 수를 수행하는 테스트
     - 유스케이스 테스트: 유스케이스로 모델링 되어 있을 때 프로세스 흐름을 기반으로 테스트 케이스를 명세화해 수행하는 테스트
     - 분류 트리 테스트: SW의 일부 또는 전체를 트리구조로 분석 및 표현하여 테스트 케이스 설계하여 테스트
     - 페어와이즈 테스트: 테스트 데이터 값들 간에 최소한 한 번씩을 조합하는 방식
     - 원인-결과 그래프 테스트: 그래프를 활용해 입력 데이터 간의 관계 및 출력에 미치는 영향을 분석하여 효용성이 높은 케이스를 선성하여 테스트
     - 비교 테스트: 여러 버전의 프로그램에 같은 입력값을 넣어 동일한 데이터가 나오는지 비교하는 테스트
   - 테스트 시각에 따른 분류
     - 검증(Verification): 소프트웨어 개발 과정을 테스트, 개발자 또는 시험자의 시각
     - 확인(Validation): 소프트웨어 결과를 테스트, 사용자 시각.
   - 테스트 목적에 따른 분류
     - 회복 테스트(Recovery Testing): 시스템에 고의로 실패를 유도하고, 시스템의 정상적 복귀 여부를 테스트하는 기법
     - 안전 테스트(Security Testing): 불법적인 소프트웨어가 접근하여 시스템을 파괴하지 못하도록 소스 코드 내의 보안적인 결함을 미리 점검하는 테스트 기법
     - 성능 테스트(Performance T.): 시스템이 응답하는 시간, 특정 시간 내에 처리하는 업무량, 사용자 요구에 시스템이 반응하는 속도 등을 측정하는 테스트 기법
     - 구조 테스트(Structure T.): 시스템의 내부 논리 경로, 소스 코드의 복잡도를 평가하는 테스트 기법
     - 회귀 테스트(Refression T.): 시스템의 변경 또는 수정된 코드에 새로운 결함이 없음을 확인하는 테스트
     - 병행 테스트(Parallel T.): 변경된 시스템과 기존 시스템에 동일한 데이터를 입력 후 결과를 비교하는 테스트.
   - 성능 테스트의 상세 유형
     - 부하 테스트(Load T.): 시스템에 부하를 계속 증가시켜 시스템의 임계점을 찾는 테스트
     - 강도 테스트(Stress T.): 임계점 이상의 부하를 가하여 비정상적인 상황에서의 처리 테스트
     - 스파이크 테스트(Spike T.): 짧은 시간에 사용자가 몰릴 때 시스템의 반응 측정 테스트
     - 내구성 테스트(Endurance T.): 오랜 시간동안 시스템에 높은 부하를 가하여 시스템 반응 테스트
   - 테스트 종류에 따른 분류
     - 명세 기반 테스트(블랙박스): 프로그램의 요구사항 명세서를 기반으로 테스트 케이스를 선정하여 테스트 하는 기법
     - 구조 기반 테스트(화이트박스): 소프트웨어 내부 논리 흐름에 따라 테스트케이스를 작성하고 확인하는 테스트 기법
     - 경험 기반 테스트(블랙박스): 유사 소프트웨어나 기술 등에 대한 테스터의 경험을 기반으로 수행하는 테스트
   - 테스트 케이스: 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 테스트 항목에 대한 명세서
   - 테스트 오라클: 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참값을 대입하여 비교하는 기법
   - 테스트 오라클 종류
     - 참(True) 오라클: 모든 입력값에 대하여 기대하는 결과를 제공하는 오라클
     - 샘플링(Sampling) 오라클: 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해주는 오라클
     - 휴리스틱(Heuristic) 오라클: 특정 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 추정(휴리스틱)으로 처리하는 오라클
     - 일관성 검사(Consistent)오라클: 애플리케이션 변경이 있을 때 수행 전과 후의 결괏값이 동일한지 확인하는 오라클
   - 테스트 레벨: 함께 편성되고 관리되는 테스트 활동의 그룹
   - 테스트 레벨 종류
     - 단위 테스트: 사용자 요구사항에 대한 단위 모듈, 서브 루틴 등을 테스트하는 단계
     - 통합 테스트: 단위테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트
     - 시스템 테스트: 개발된 소프트웨어가 정상적으로 수행되는지 검증하는 테스트
     - 인수 테스트: 계약상의 요구사항이 만족되었는지 확인하기 위한 테스트
   - 소프트웨어 개발 단계: 요구사항 -> 분석 -> 설계 -> 구현
   - 테스트 단계: 단위 테스트 -> 통합 테스트 -> 시스템 테스트 -> 인수 테스트
   - 인수 테스트
     - 사용자 인수 테스트: 사용자가 시스템 사용의 적절성 여부를 확인
     - 운영상의 인수 테스트: 시스템 관리자가 시스템 인수 시 수행하는 테스트 기법
     - 계약 인수 테스트: 계약상의 인수 / 검수 조건을 준수하는지 여부를 확인
     - 규정 인수 테스트: 소프트웨어가 정부 지침, 법규, 규정 등에 맞게 개발되었는지 확인
     - 알파 테스트: 개발자의 장소에서 사용자가 개발자와 함께 행하는 테스트 기법
     - 베타 테스트: 실제 사용자에게 대상 소프트웨어를 사용하게 하고 피드백을 받는 테스트
   - 테스트 시나리오: 테스트 수행을 위한 여러 테스트 케이스의 집합. 테스트 케이스의 동작 순서를 기술한 문서이며 테스트를 위한 절차를 명세한 문서.

2. 애플리케이션 통합 테스트(중요도 ★★★)
   - 단위 테스트: 개별적인 모듈 또는 컴포넌트를 테스트
   - 목 객체 생성 프레임워크: 객체 지향 프로그램에서는 컴포넌트 테스트 수행 시 테스트되는 메서드는 다른 클래스의 객체에 의존하는데, 이런 경우 메서드를 고립화하여 테스트하는 것이 불가능하므로 독립적인 컴포넌트 테스트를 위해서는 스텁의 객체 지향 버전인 목 객체가 필요하다
     - 목 객체 유형: 더미 객체, 테스트 스텁, 테스트 드라이버, 테스트 스파이, 가짜 객체
   - 통합 테스트: 단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트
   - 통합테스트 수행 방법 간 비교
     - 빅뱅 테스트: 모든 모듈을 동시에 통합 후 테스트 수행
       - 드라이브/스텁: 드라이버/스텁 없이 실제 모듈로 테스트
     - 상향식 테스트: 최하위 모듈부터 점진적으로 상위모듈과 함께 테스트
       - 드라이브/스텁: 테스트 드라이버 필요
     - 하향식 테스트: 최상위 모듈부터 하위모듈을 통합하면서 테스트
       - 드라이브/스텁: 테스트 스텁 필요
     - 샌드위치 테스트: 상위는 하향식 + 하위는 상향식 테스트
       - 드라이브/스텁: 테스트 스텁, 드라이버 필요
   - 테스트 자동화 도구: 반복적인 테스트 작업을 스크립트 형태로 구현함으로써 테스트 시간 단축과 인력 투입 비용을 최소화하는 한편, 쉽고 효율적인 테스트를 수행 할 수 있는 방법
   - 테스트 자동화 도구 유형
     - 정적 분석 도구(Static Analysis Tools): 만들어진 애플리케이션을 실행하지 않고 분석하는 도구
     - 테스트 실행 도구(Test Execution Tools): 테스트를 위해 작성된 스크립트를 실행하고, 스크립트 언어를 사용하여 테스트를 실행하는 도구
     - 성능 테스트 도구(Performance Test Tools): 가상의 사용자를 생성하고 테스트를 수행하여 목표를 달성했는지 확인하는 도구
     - 테스트 통제 도구(Test Control Tools): 테스트 계획 및 관리, 테스트 수행, 결함 관리 등을 수행하는 도구
     - 테스트 하네스 도구(Test harness Tools): 테스트가 실행될 환경을 시뮬레이션 하여 컴포넌트 및 모듈이 정상적으로 테스트되도록 하는 도구
   - 테스트 하네스 구성요소: 테스트 드라이버, 테스트 스텁, 테스트 슈트, 테스트 케이스, 테스트 시나리오, 테스트 스크립트, 목 오브젝트
   - 소프트웨어 결함: 개발자 오류로 인해 만들어지는 무서 또는 코딩상의 결점으로 개발자가 설계한 것과 다르게 동작하거나 다른 결과가 발생하는 현상
   - 테스트 결함 관리: 단계별 테스트 수행 후 발생한 결함의 재발 방지와 유사 결함 발견 시 처리 시간 단축을 위해 결함을 추적하고 관리하는 활동
   - 결함 분석 방법
     - 구체화: 결함의 원인을 찾기 위해 결함을 발생시킨 입력값, 테스트 절차, 테스트 환경을 명확히 파악하는 방법
     - 고립화: 입력값, 테스트 절차, 테스트 환경 중 어떤 요소가 결함 발생에 영향을 미치는 지 분석하는 방법
     - 일반화: 결함 발생에 영향을 주는 요소를 최대한 일반화 시키는 방법
   - 테스트 커버리지(Test Coverage): 주어진 테스트케이스에 의해 수행되는 테스트 범위를 측정하는 테스트 품질 측정 기준.
   - 테스트 커버리지 유형
     - 기능 기반 커버리지: 전체 기능을 모수로 설정하고, 실제 테스트가 수해된 기능의 수를 측정하는 방법
     - 라인 커버리지: 전체 소스 코드의 라인수를 모수로 테스트 시나리오가 수행한 소스 코드의 라인 수를 측정하는 방법
     - 코드 커버리지: 소스 코드의 구문, 조건, 결정 등의 구조 코드 자체가 얼마나 테스트되었는지를 측정하는 방법
   - 결함 심각도별 분류: 단순 결함(미관상 불량) -> 경미한 결함(표준 위반) -> 보통 결함(사소한 기능 오작동) -> 주요 결함(기능 장애) -> 치명적 결함(데이터 손실)
   - 결함 우선순위: 낮음(Low) -> 보통(Medium) -> 높음(High) -> 결정적(Critical)

3. 애플리케이션 성능 개선(중요도 ★)
   - 애플리케이션 성능 측정 지표
     - 처리량(Throughput): 애플리케이션이 주어진 시간에 처리 할 수 있는 트랜잭션의 수
     - 응답시간(Response Time): 사용자 입력이 끝난 후, 애플리케이션의 응답 출력이 개시될 때 까지의 시간
     - 경과시간(Turnaround Time): 애플리케이션에 사용자가 요구를 입력한 시점부터 트랜잭션을 처리 후 그 결과의 출력이 완료될 때 까지 걸리는 시간
     - 자원 사용률(Resource Usage): 애플리케이션이 트랜잭션을 처리하는 동안 사용하는 CPU 사용량, 메모리 사용량, 네트워크 사용량
   - 데이터베이스 관련 성능 저하 원인
     - 데이터베이스 락(DB Lock): 대량의 데이터 조회, 과도한 업데이트, 인덱스 새성 시 발생하는 현상
     - 불필요한 데이터베이스 패치(DB fetch): 실제 필요한 데이터보다 많은 데이터 요청이 들어올 경우 응답시간 저하 현상 발생
     - 연결 누수(Connection Leak): DB 연결과 관련한 JDBC 객체를 사용 후 종료하지 않을 경우 발생
     - 부적절한 커넥션 풀 크기(Connection Pool Size): 너무 작거나 크게 설정한 경우 성능 저하 현상이 발생할 가능성 존재
     - 확정(Commit) 관련: 트랜잭션이 확정되지 않고 커넥션 풀에 반환될 때 성능 저하 가능성 존재
   - 배드 코드(Bad Code): 프로그램 로직이 복잡하고 다른 개발자들이 이해하기 어려운 코드
     - 배드 코드 사례
       - 외계인 코드: 아주 오래되고나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 코드
       - 스파게티 코드: 소스코드가 복잡하게 얽힌 모습. 정상 작동 하지만 코드의 작동을 파악하기 어려운 코드
       - 알 수 없는 변수명: 변수나 메서드에 대한 이름 정의를 알 수 없는 코드
       - 로직 중복: 동일한 처리 로직이 중복되게 작성된 코드
   - 클린 코드(Clean Code): 가독성이 높고, 단순하며, 의존성이 적고, 중복을 최소화하여 깔끔하게 잘 정리된 코드
     - 클린코드 특징: 가독성이 높아 쉽게 이해됨. 개선도 쉬움. 버그 찾기도 쉬워 프로그래밍 속도 빨라짐.
     - 클린 코드 작성 원칙: 가독성, 단순성, 의존성 최소, 중복성 제거, 추상화
   - 리팩토링: 기능을 변경하지 않고, 복잡한 소스코드를 수정, 보완하여 가용성 및 가독성을 높이는 기법.

## 11. 응용 SW 기초 기술 활용

1. 운영체제의 특징(중요도 ★★★)
   - 운영체제(OS): 사용자가 컴퓨터의 하드웨어를 쉽게 사용 할 수 있도록 인터페이스를 제공해주는 소프트웨어
   - 운영체제 종류: 윈도우, 유닉스, 리눅스, 맥, 안드로이드 등
   - 메모리 관리 기법
     - 반입 기법: 메모리 적재 시기 결정(When)
     - 배치 기법: 메모리 적재 위치 결정(Where)
     - 할당 기법: 메모리 적재 방법 결정(How)
     - 교체 기법: 메모리 교체 대상 결정(Who)
   - 메모리 배치 기법
     - 최초 적합(First fit): 프로세스가 적재 될 수 있는 가용 공간 중에서 첫 번째 분할에 할당하는 방식
     - 최적 적합(Best fit): 가용 공간 중에서 가장 크기가 비슷한 공간을 선택하여 프로세스를 적재하는 방식
     - 최악 적합(Worst fit): 프로세스의 가용 공간들 중에서 가장 큰 공간에 할당하는 방식
   - 프로세스 상태
     - 생성(Create) 상태: 사용자에 의해 프로세스가 생성된 상태
     - 준비(Ready) 상태: CPU를 할당받을 수 있는 상태
     - 실행(Running) 상태: 프로세스가 CPU를 할당받아 동작중인 상태
     - 대기(Waiting) 상태: 프로세스 실행 중 입출력 처리등으로 인해 CPU를 양도하고 입출력 처리가 완료될 때 까지 대기 리스트에서 기다리는 상태
     - 완료(Complete) 상태: 프로세스가 CPU를 할당받아 주어진 시간 내에 완전히 수행을 종료한 상태
   - 프로세스 상태 전이
     - <img width="749" alt="image" src="https://user-images.githubusercontent.com/81678439/179684017-1bf1c48e-f920-4f32-b6fe-e4232f01f6c9.png">
   - 프로세스 스케줄링의 유형
     - 선점형 스케줄링: 우선순위가 높은 프로세스가 CPU를 점유하는 스케줄링
       - 라운드 로빈(Round Robbin): 프로세스는 같은 크기의 CPU 시간 할당
       - SRT(Shortest REmaining Time First): 여러 개의 큐를 이용하여 상위단계 작업에 의한 하위단계 작업이 선점
       - 다단계 큐(Multi Level Queue): 여러 개의 큐를 이용하여 상위단계 작업에 의한 하위단계 작업이 선점
       - 다단계 피드백 큐(MUlti Level Feedback Queue): 큐마다 서로 다른 CPU 할당량을 부여, FIFO + 라운드로빈 스케줄링 기법 혼합
     - 비선점형 스케줄링: 한 프로세스가 CPU를 할당 받으면 작업종료 전까지 다른 프로세스는 CPU를 점유 할 수 없는 스케줄링
       - 우선순위(Priority): 프로세스별 우선순위에 따라 CPU 할당
       - 기한부(Deadline): 작업들이 명시된 기한 내에 완료되도록 계획
       - FCFS(SHortest Job First): 가장 짧은 작업부터 수행, 평균 대기 시간 최소화, 기아현상 발생
       - HRN(Highest REsponse Ratio Next): 대기중인 프로세스 중 현재 응답률이 가장 높은 것을 선택, 기아현상 최소화 기법
   - 가상화(Virtualization): 물리적인 리소스들을 사용자에게 하나로 보이게 하거나, 하나의 물리적인 리소스를 여러 개로 보이게 하는 기술
   - 클라우드 컴퓨팅(Cloud Computing): 인터넷을 통해 가상화된 컴퓨터 시스템 리소스 제공
   - 클라우드 컴퓨팅 유형
     - 인프라형 서비스(IaaS; Infrastructure as a Service): 서버, 스토리지 같은 자원을 클라우드로 제공하는 서비스
     - 플랫폼형 서비스(PaaS; Platform as a Service): 애플리케이션 개발, 실행, 관리할 수 있게 하는 플랫폼을 제공하는 서비스
     - 소프트웨어형 서비스(SaaS; Software as a Service): 클라이언트를 통해 접속하여 소프트웨어 서비스 형태로 이용하는 서비스

2. 네트워크 계층 구조 파악(중요도 ★★★)
   - 네트워크: 원하는 정보를 원하는 수신자 또는 기기에 정확하게 전송하기 위한 기반 인프라
     - 광대역 네트워크(WAN): LAN에 비해 전송거리가 넓음
     - 근거리 네트워크(LAN): 한 건물 또는 작은 지역 커버
   - OSI(Open System Interconnection) 7계층
     - 응용 계층(Application L.): 사용자와 네트워크간 응용서비스 연결, 데이터 생성
     - 표현 계층(Presentation L.): 데이터의 형식 설정, 부호 교환, 암/복호화
     - 세션 계층(Session L.): 송수신 간의 논리적인 연결
     - 전송 계층(Transport L.): 송수신 프로세스 간의 연결
     - 네트워크 계층(Network L.): 단말기 간 데이터 전송을 위한 최적화된 경로 제공
     - 데이터링크 계층(Data Link L.): 인접 시스템 간 데이터 전송, 오류 제어
     - 물리 계층(Physical L.): 0과 1의 비트 정보를 회선에 보내기 위한 전기적 신호 변환
   - 프로토콜: 서로 다른 시스템이나 기기들 간의 데이터 교환을 원활이 하기 위한 표준화된 통신 규약
   - 프로토콜 기본 3요소
     - 구문(Syntax): 시스템 간의 정보 전송을 위한 데이터 형식, 코딩, 신호 레벨 등의 규정
     - 의미(Semantic): 시스템 간의 정보 전송을 위한 제어 정보로 조정과 에러 처리를 위한 규정
     - 타이밍(Timing): 시스템 간의 정보 전송을 위한 속도 조절과 순서 관리 규정
   - 네트워크 프로토콜(Network Protocol): 컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고받는 양식과 규칙의 체계
   - 데이터 링크 계층 프로토콜
     - HDLC(High-level Data Link Control): 점대점 방식이나 다중방식 통신에 사용되며, 동기식 비트 중심
     - PPP(Point-to-Point Protocol): 네트워크 분야에서 두 통신 노드간의 직접적 연결
     - 프레임 릴레이(Frame Relay): 프로토콜 처리를 간략화하여 데이터 처리속도의 향상 및 전송 지연을 감소시킨 고속 데이터 전송기술
     - ATM(Asynchronous Transport Mode): 53바이트 셀 단위로 전달하는 비동기식 시분할 다중화 방식의 패킷형 전송기술
   - 네트워크 계층 프로토콜
     - IP(Internet Protocol): 송수신 간의 패킷 단위로 데이터를 교환하는 네트워크에서 정보를 주고받는 데 사용
     - ARP(Address Resolution Protocol): IP네트워크 상에서 IP주소를 MAC주소(물리주소)로 변환하는 프로토콜
     - RARP(Reverse Address Resolution Protocol): 서버로부터 IP주소를 요청하기위해 사용하는 프로토콜
     - ICMP(Internet Control Message Protocol): IP 패킷을 처리 할 때 발생되는 문제를 알려주는 프로토콜
     - IGMP(Internet Group Management Protocol): 호스트 컴퓨터와 인접 라우터가 멀티캐스트 그룹 멤버십을 구성하는데 사용하는 통신 프로토콜
     - 라우팅 프로토콜(Routing Protocol): 데이터 전송을 위해 최적의 경로를 설정해주는 라우터 간의 상호 통신 프로토콜
   - IPv4(Internet Protocol version 4): 인터넷에서 사용되는 패킷 교환 네트워크상에서 데이터를 교환하기 위한 32비트 주소체계를 갖는 네트워크 계층 프로토콜
     - 8비트씩 4부분으로 나뉜 10진수
     - 0~255까지 3자리수 표현
     - 유니캐스트, 멀티캐스트, 브로드캐스트
   - IPv4 클래스 분류
     - A클래스: 국가나 대형 통신망에 사용(1~127), 네트워크 사용자에게 부여가 가능한 IP
     - B클래스: 중대형 통신망에 사용(128~191)
     - C클래스: 소규모 통신망에 사용(192~223)
     - D클래스: 멀티캐스트 용도로 에약된 주소(224~239)
     - E클래스: 연구를 위해 예약된 주소(공용 사용 불가)
   - IPv6(Internet Protocol version 6): IPv4의 주소 부족 문제를 해결하기 위해 개발
     - IPv4에 비해 자료 전송속도가 빠름
     - 128비트 주소체계
     - 16비트씩 8개 부분으로 나눈 16진수
     - 유니캐스트, 멀티캐스트, 애니캐스트
   - IPv4에서 IPv6로 전환 방법: 듀얼 스택, 터널링, 주소 변환 방식
   - 라우팅 프로토콜
     - 내부 라우팅 프로토콜(IGP)
       - RIP(Routing Information Protocol): AS(자율 시스템) 내에서 사용하는 거리 벡터 알고리즘에 기초하여 개발
       - OSPF(Open Shortest Path First): 자신을 기준으로 링크 상태 알고리즘을 적용하여 최단경로를 찾는 라우팅 프로토콜
     - 외부 라우팅 프로토콜(EGP)
       - BGP(Border Gateway Protocol): AS 상호간에 경로 정보를 교환하기 위한 라우팅 프로토콜
     - TCP(Transmission Control Protocol)
       - TCP 특징: 신뢰성 보장, 연결 지향적 특징, 흐름 제어, 혼잡 제어
     - UDP(User Datagram Protocol)
       - UDP 특징: 비신뢰성, 순서화되지 않은 데이터그램 서비스 제공, 실시간 응용 및 멀티캐스트 가능
     - 표현계층 프로토콜
       - JPEG: 이미지를 위해 만들어진 표준 규격
       - MPEG: 멀티미디어(비디오, 오디오)를 위해 만들어진 표준 규격
     - 응용계층 프로토콜
       - HTTP(Hyper Text Transfer Protocol): 텍스트 기반의 통신규약. 하이퍼텍스트를 빠르게 교환하기 위한 프로토콜
       - FTP(File Transfer Protocol): TCP/IP를 갖고 서버와 클라이언트 사이의 파일을 전송하기 위한 프로토콜
       - SMTP(Simple Mail Transfer Protocol): 인터넷에서 TCP 포트 25번을 사용하여 이메일을 보내기 위해 이용되는 프로토콜
       - POP3(Post Office Protocol Version 3): 원격 서버로부터 TCP/IP연결을 통해 이메일을 가져오는 데 사용하는 프로토콜
       - IMAP(Internet Messaging Access Protocol): 원격 서버로부터 TCP/IP연결을 통해 이메일을 가져오는 데 사용하는 프로토콜
       - Telnet: 인터넷이나 로컬 영역에서 네트워크 연결에 사용되는 네트워크 프로토콜
       - SSH(Secure Shell): 서로 연결되어있는 컴퓨터 간 원격 명령 실행이나 쉘 서비스 등을 수행. Telnet보다 강력한 보안 제공
       - SNMP(Simple Network Management Protocol): 라우터나 허브 등 네트워크 장치로부터 정보를 수집 및 관리
     - 패킷 교환 방식(Packet Switching): 작은 블록의 패킷으로 데이터를 전송하여 데이터를 전송하는 동안만 네트워크 자원을 사용하도록 하는 통신 방식
       - 활용: 이메일, 메시지
     - 패킷 교환 방식 기술
       - X.25: 통신을 원하는 두 단말장치가 패킷 교환망을 통해 패킷을 원활히 전달하기 위한 통신 프로토콜
       - 프레임 릴레이: ISDN을 사용하기 위한 프로토콜로서 ITU-T에 의해 표준으로 작성
       - ATM(Asynchronous Transfer Mode): 비동기 전송모드, 광대역 전송에 쓰이는 스위칭 기법
     - 서킷 교환 방식(Circuit Switching): 네트워크 리소스를 특정 사용층이 독점하도록 하는 통신 방식
       - 활용: 영상, 비디오
     - 애드 혹 네트워크(Ad-hoc Network): 노드들에 의해 자율적으로 구성되는 기반 구조가 없는 네트워크

3. 기본 개발환경 구축하기(중요도 ★)
   - 개발환경 인프라 구성방식
     - 온프레미스(On-Premise): 외부 인터넷망이 차단된 상태에서 인트라넷망만 활용하여 개발환경을 구축하는 방식
     - 클라우드(Cloud): 클라우드 공급 서비스를 제공하는 회사들(아마존, 구글, MS등)의 서비스를 임대하여 개발 환경을 구축하는 방식
     - 하이브리드(Hybrid): 온프레미스와 클라우드 방식을 혼용한 방식