# 정보처리기사 실기

출처: [DUKI의 개발](https://dustink.tistory.com/149)

## 1. 요구사항 확인

1. 소프트웨어 개발 방법론(중요도 ★★★)
   - 소프트웨어 생명주기(SDLC; Software Development Life Cycle): 시스템의 요구분석부터 유지보수까지 전 공정을 체계화한 절차
   - 소프트웨어 생명주기 모델 종류
     - 폭포수 모델: 가장 오래된 모델. 각 단계를 확실히 마무리 후 다음 단계로 진행
     - 프로토타이핑 모델: 주요 기능을 프로토타입으로 구현, 고객의 피드백을 반영하여 SW 개발
     - 나선형 모델: 위험 최소화를 위해 점진적으로 시스템 개발
     - 반복적 모델: 구축대상을 나누어 병렬적으로 개발 후 통합하거나 반복적으로 개발
   - 소프트웨어 개발 방법론: 소프트웨어 개발의 시작부터 시스템을 사용하지 않는 과정까지 전 과정을 형상화한 방법론
   - 소프트웨어 개발 방법론 종류
     - 구조적 방법론: 전체 시스템을 기능에 따라 나누어 개발하고 이를 통합하는 방법론
       - 나씨-슈나이더만 차트: 논리의 기술에 중점을 둔 도형식 표현방법
     - 정보공학 방법론: 정보시스템 개발에 필요한 관리 절차와 작업 기법을 체계화한 방법론
     - 객체 지향 방법론: '객체'라는 기본 단위로 시스템을 분석 및 설계하는 방법론
     - 컴포넌트 기반 방법론(CBD): 컴포넌트를 조립해서 하나의 새로운 응용프로그램을 작성하는 방법론
     - 애자일 방법론: 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적응하면서 효율적인 시스템을 개발 할 수 있는 신속 적응적 개량 개발 방법론
     - 제품 계열 방법론: 특정 제품에 적용하고싶은 공통된 기능을 정의해 개발하는 방법론. 임베디드 SW작성에 유용
   - 애자일(Agile)방법론 유형
     - XP(eXtreme Programming): 의사소통 개선과 즉각적 피드백으로 소프트웨어 품질을 높이기 위한 방법론
       - XP 5가지 가치: 용기, 단순성, 의사소통, 피드백, 존중
      - 스크럼(Scrum): 매일 정해진 시간, 장소에서 짧은 시간의 개발을 하는 팀을 위한 프로젝트 중심 방법론
      - 린(Lean): 도요타의 린 시스템 품질기법을 소프트웨어 개발 프로세스에 적용해서 낭비 요소를 제거하여 품질을 향상시킨 방법론
        - Lean의 7가지 가치: 낭비제거, 품질 내재화, 지식 창출, 늦은 확정, 빠른 인도, 사람 존중, 전체 최적화
    - 객체 지향 분석(OOA): 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 클래스(객체), 속성과 연산, 관계를 정의
    - 객체 지향 분석 방법론 종류
      - OOSE(Object Orient Software Engineering): 유스케이스를 모든 모델의 근간으로 활용되는 방법론, 야콥슨
      - OMT(Object Modeling Technology): 그래픽 표기법을 이용하여 소프트웨어 구성 요소를 모델링, 럼바우.
        - 분석 절차: 객체 모델링 -> 동적 모델링 -> 기능 모델링
        - 객체 모델링: 객체들 간의 관계를 정의하여 ER 다이어그램을 만드는 과정까지의 모델링. 객체 다이어그램 활용.
        - 동적 모델링: 시간의 흐름에 따라 객체들의 동적인 행위를 표현하는 모델링. 상태 다이어그램 활용
        - 기능 모델링: 프로세스들의 자료 흐름을 중심으로 처리 과정을 표현하는 모델링. 자료 흐름도(DFD)활용.
    - 비용산정 모형 분류
      - 하햐식 산정방법: 경험이 많은 전문가에게 비용산정 의뢰 또는 전문가와 조정자를 통해 비용산정
        - 전문가 판단
        - 델파이 기법: 전문가의 경험적 지식을 통한 문제 해결 및 미래 예측을 위한 기법
      - 상향식 산정방법: 세부적인 요구사항과 기능에 따라 필요한 비용 산정
        - 코드라인 수(LoC; Lines of Code): 원시 코드 라인수의 낙관치, 중간치, 비관치를 측정하여 예측치를 구해 비용 산정
        - Man Month: 한 사람이 1개월 동안 할 수 있는 일의 양을 기준으로 비용 산정
        - COCOMO: 보헴이 제안한 모형. 프로그램의 규모에 따라 비용산정
          - 조직형(Organic Mode): 5만 라인 이하
          - 반 분리형(Semi-Detached Mode): 30만 라인 이하
          - 임베디드형(Embedded Mode): 30만 라인 이상
          - 푸트남(Putnam): 개발주기의 단계별로 요구할 인력의 분포를 가정하는 방식
          - 기능점수(FP) 모형: 소프트웨어 기능을 증대시키는 요인별로 가중치를 부여하여 비용 산정
      - 비용 산정 자동화 추정 도구
        - SLIM: Rayleigh-Norden 곡선과 Putnam 예측 모델을 기초로 하여 개발된 자동화 추정 도구
        - ESTIMACS: 다양한 프로젝트와 개인별 요소를 수용하도록 FP 모형을 기초로 하여 개발된 자동화 추정 도구
      - 일정관리 모델: 프로젝트가 일정 기한 내에 완료될 수 있도록 관리하는 모델
        - 주 공정법(CPM): 여러 작업의 수행 순서가 얽혀있는 프로젝트의 일정을 계산하는 기법
          - 주 공정(Critical Path: 임계 경로): 프로젝트의 시작에서 종료까지 가장 긴 시간이 걸리는 경로
        - PERT: 일의 순서를 계획적으로 정리하기 위한 수렴 기법. 비관치, 중간치, 낙관치를 이용
        - 중요 연쇄 프로젝트 관리(CCPM): 주 공정 연쇄법으로 자원제약사항을 고려하여 일정을 작성하는 기법
2. 현행 시스템 분석(중요도: ★★★)
   - 현행 시스템 파악: 현행 시스템이 어떤 기술 요소를 사용하는지 파악하는 활동
   - 현행 시스템 파악 절차
     - 구성/기능/인터페이스 파악 -> 아키텍처 및 소프트웨어 구성 파악 -> 하드웨어 및 네트워크 구성 파악
   - 소프트웨어 아키텍처: 여러가지 소프트웨어 구성요소와 그 구성요소가 가진 특성 중 외부에 드러나는 특성, 그리고 구성요소 간의 관계를 표현하는 시스템의 구조나 구조체
   - 소프트웨어 아키텍처 4+1 뷰: 고객의 요구사항을 정리해놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어적인 접근 방법
     - 유스케이스 뷰: 유스케이스 또는 아키텍처를 도출하고 설계하며 다른 뷰를 검증하는데 사용되는 뷰
     - 논리 뷰: 시스템의 기능정인 요구사항이 어떻게 제공되는지 설명 해 주는 뷰
     - 구현 뷰: 개발환경 안에서 정적인 소프트웨어 모듈의 구성을 보여주는 뷰. 컴포넌트 구조와 의존성을 보여주고 부가적인 정보를 정의
     - 배포 뷰: 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가를 매핑해서 보여주는 뷰
   - 소프트웨어 아키텍처 패턴 유형
     - 계층화 패턴(Layered Pattern): 시스템을 계층으로 구분하여 구성하는 패턴
     - 클라이언트-서버 패턴(Client-Server Pattern): 하나의 서버와 다수의 클라이언트로 구성된 패턴
     - 파이프-필터 패턴(Pipe-Filter Pattern): 데이터스트림을 생성하고 처리하는 시스템에서 사용 가능한 패턴. 재사용성이 좋고, 추가가 쉬워 확장에 용이
     - 브로커 패턴(Broker Pattern): 분리된 컴포넌트들로 이루어진 분산 시스템에서 사용. 각 컴포넌트들의 원격 서비스 실행을 통해 상호작용 가능
     - MVC 패턴: 대형 어플리케이션을 3개의 서브 시스템으로 구조화한 패턴. 컴포넌트로 분리되어있어 서로 영향을 받지 않고 개발 작업 수행 가능
       - 모델: 핵심 기능과 데이터 보관
       - 뷰: 사용자에게 정보 표시
       - 컨트롤러: 사용자로부터 요청을 입력받아 처리
   - 소프트웨어 아키텍처 비용 평가 모델 종류
     - SAAM: 변경 용이성과 기능성에 집중, 경험이 없는 조직에서도 활용 가능한 비용 평가 모델
     - ATAM: 아키텍처 품질 속성을 만족시키는지 판단 및 품질속성들의 이해 상층관계까지 평가하는 모델
     - ADR: 소프트웨어 아키텍처 구성요소 간 응집도 평가 모델
     - ARID: 전체 아키텍처가 아닌 특정부분에 대한 품질요소에 집중하는 비용 평가 모델
   - 디자인 패턴: 소프트웨어 설계에서 공통으로 발생하는 문제에 대하여 자주 쓰이는 설계 방법을 정리한 패턴
   - 디자인 패턴 유형
     - 목적
       - 생성: 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행하는 패턴.
       - 구조: 클래스나 객체의 조합을 다루는 패턴
       - 행위: 클래스나 객체들이 상호 작용하는 방법과 역할 분담을 다루는 패턴
     - 범위
       - 클래스: 상속 관계를 다루는 패턴, 컴파일 타임에 정적으로 결정
       - 객체: 객체 간 관련성을 다루는 패턴, 런타임에 동적으로 결정
   - 디자인 패턴 종류
     - 생성패턴: 빌더, 프로토타입, 팩토리메소드, 추상팩토리, 싱글턴
     - 구조패턴: 브릿지, 데코레이터, 퍼사드, 플라이웨이트, 프록세, 컴포짓, 어댑터
     - 행위패턴: 메디에이터, 인터프리터, 이터레이터, 템플릿메소드, 옵저버, 상태, 비지터, 커맨드, 전략, 메멘토, Chain of Responsibility
   - 운영체제(OS): 컴퓨터 사용자와 컴퓨터 하드웨어간의 인터페이스를 담당하는 프로그램
     - 운영체제의 종류
       - PC: 윈도우, 유닉스, 리눅스
       - 모바일: 안드로이드, IOS
   - OSI 계층: 네트워크 통신에서 충돌문제를 완화하기 위해 국제 표준화 기구(ISO)에서 제시한 모델
     - 응용 계층(Application): 사용자와 네트워크간 응용 서비스 연결, 데이터 생성
     - 표현 계층(Presentation): 데이터 형식 설정과 부호 교환, 암호화/복호화
     - 세션 계층(Session): 연결 접속 및 동기 제어
     - 전송 계층(Transport): 신뢰성 있는 통신 보장, 데이터 분할과 재조립, 흐름 제어, 혼잡제어 담당
     - 네트워크 계층(Network): 단말 간 데이터 전송을 위한 최적화된 경로 제공
     - 데이터 링크 계층(Data Link): 인접 시스템 간 데이터 전송, 전송오류 제어
     - 물리 계층(Physical): 0과 1의 비트 정보를 회선에 보내기 위한 전기적 신호로 변환
   - DBMS: 데이터의 집합을 만들고, 저장 및 관리 할 수 있는 기능들을 제공하는 응용 프로그램
   - 미들웨어: 분산컴퓨팅 환경에서 응용 프로그램과 프로그램이 운영되는 환경 간에 원만한 통신이 이루어질 수 있도록 제어해주는 소프트웨어. 대표적인 미들웨어: WAS
     - 웹 어플리케이션 서버(WAS): 서버 계층에서 애플리케이션이 동작 할 수 있는 환경을 제공하고 안정적인 트랜잭션 처리와 관리, 다른 이기종의 시스템과 애플리케이션 연동을 지원하는 서버

3. 요구사항 확인(중요도 ★★★)
   - 요구공학(Requirements Engineering): 사용자의 요구가 반영된 시스템을 개발하기 위해 사용자 요구사항에 대한 도출, 분석, 명세, 확인 및 검증하는 구조화된 활동.
   - 요구사항의 분류
     - 기능적 요구사항: 시스템이 제공하는 기능, 서비스에 대한 요구사항
       - 특정 입력/상황에 대해 시스템이 어떻게 반응/동작해야하는지에 대한 기술
       - 특성: 기능성, 완전성, 일관성
     - 비기능적 요구사항: 시스템 구축에 대한 제약사항에 관한 요구사항
       - 품직속성에 관련하여 시스템이 갖춰야할 사항에 관한 기술, 시스템이 준수해야할 제한 조건에 관한 기술
       - 특성: 신뢰성, 사용성, 효율성, 유지보수성, 이식성, 보안성 및 품질 관련 요구사항, 제약사항
   - 요구공학 프로세스: 도출 -> 분석 -> 명세 -> 확인 및 검증
   - 요구사항 도출 단계 주요 기법
     - 인터뷰, 브레인스토밍, 델파이기법, 롤플레잉, 설문조사
       - 델파이기법: 전문가의 경험적 지식을 통해 문제해결 및 미래예측을 위한 방법
   - 요구사항 확인 및 검증 단계의 주요 기법
     - 요구사항 검토: 여러 검토자들이 에러, 잘못된 가정, 불명확성, 표준과의 차이를 검토
     - 정형 기술 검토 활용
       - 동료검토: 2~3명 리뷰 진행, 요구사항 명세서를 설명하고 이해관계자들이 들으면서 결함을 발견하는 형태로 진행
       - 워크스루: 검토자료를 회의 전에 배포하여 짧은 시간동안 회의를 진행하는 형태로 리뷰를 통해 오류를 검출하고 문서화
       - 인스펙션: 소프트웨어 요구, 설계 원시 코드 등의 저작자 외의 다른 전문가 또는 팀이 검사하여 오류를 찾아내는 공식적 검토 방법
     - 프로토타이핑 활용: 프로토타입(견본품)을 통해 효과적으로 요구 분석을 수행하면서 명세서를 산출하는 작업
     - 모델 검증: 분석단계에서 개발된 모델의 품질 검증 필요
     - 테스트케이스 및 테스트를 통한 확인: 각각의 요구사항을 어떻게 확인 할 것인지에 대한 계획을 수립하고 테스트케이스 작성
     - CASE 도구 활용 검증: 자동화된 일관성 분석을 제공하는 CASE 도구 활용
     - 베이스라인을 통한 검증: 요구사항 변경을 체계적으로 추적하고 통제하는 시점인 베이스라인을 통한 요구사항에 대한 지속적 검증 수행
     - 요구사항 추적표(RTM)을 통한 검증: 요구사항 정의서를 기준으로 개발 단계별 최종 산출물이 어떻게 반영되고, 변경되었는지 확인 가능한 문서

4. 분석 모델 확인하기(중요도 ★)
   - 분석모델 검증 방법: 유스케이스 모델 검증, 개념수준의 분석 클래스 검증, 분석 클래스 검증

## 2. 화면설계

1. UI 요구사항 확인(중요도 ★★★)
   - UI: 사용자와 시스템 사이에서 의사소통 할 수 있도록 고안된 물리적, 가상의 매개체
   - UI 유형
     - CLI(Command Line Interface): 명령어를 텍스트로 입력하여 조작하는 인터페이스
     - GUI(Graphical User Interface): 그래픽 환경을 기반으로 마우스나 전자펜을 이용한 사용자 인터페이스
     - NUI(Natural User Interface): 신체부위를 이용하는 사용자 인터페이스
     - OUI(Organic User Interface): 현실에 존재하는 모든 사물이 입출력장치로 변화할 수 있는 인터페이스
   - UI 설계 원칙
     - 직관성: 누구나 쉽게 이해하고 사용할 수 있어야 함.
     - 유효성: 정확하고 완벽하게 사용자의 목표가 달성될 수 있어야 함.
     - 학습성: 초보와 숙련자 모두가 쉽게 배우고 사용할 수 있게 제작
     - 유연성: 사용자의 요구사항을 최대한 수용하고, 실수를 방지 할 수 있도록 제작
   - UI 설계 지침: 사용자 중심, 일관성, 단순성, 결과 예측 가능, 가시성, 표준화, 접근성, 명확성, 오류발생해결
   - UI 품질 요구사항(ISO/IEC 9126기반)
     - 기능성: 실제 수행 결과와 품질 요구사항과의 차이를 분석, 시스템 동작을 관찰하기 위한 품질 기준
       - 적절성, 정밀성, 상호운용성, 보안성, 호환성
     - 신뢰성: 시스템이 일정한 시간 또는 작동되는 시간동안 의도하는 기능을 수행함을 보증하는 품질 기준
       - 성숙성, 고장 허용성, 회복성
     - 사용성: 사용자와 컴퓨터 사이에 발생하는 어떠한 행위를 정확하고 쉽게 인지할 수 있는 품질 기준
       - 이해성, 학습성, 운용성
     - 효율성: 할당된 시간에 한정된 자원으로 얼마나 빨리 처리할 수 있는가에 대한 품질 기준
       - 시간 효율성, 자원 효율성
     - 유지보수성: 요구사항을 개선하고 확장하는 데 있어 얼마나 용이한가에 대한 품질 기준
       - 분석성, 변경성, 안정성, 시험성
     - 이식성: 다른 플랫폼에서도 추가 작업 없이 얼마나 쉽게 적용 가능한가에 대한 품질기준
       - 적용성, 설치성, 대체성
   - UI표준: 디자인 철학과 원칙 기반하에 전체 시스템에 공통으로 적용되는 화면 간 이동, 화면구성 등에 관한 규약.
   - CRUD(Create, Read, Update, Delete): 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능
   - UI 개발을 위한 주요 기법
     - 3C 분석: 고객(Customer), 자사(Company), 경쟁사(Competitor)를 비교하고 분석하여 자사를 어떻게 차별화해서 경쟁에서 이길 것인가를 분석하는 기법
     - SWOT분석: 기업의 내외부 환경을 분석하여 Strength(강점), Weakness(약점), Opportunity(기회), Treat(위협) 요인을 규정하고 이를 토대로 경영 전략을 수립하는 방법
     - 시나리오 플래닝: 상황 변화를 사전에 예측하고 다양한 시나리오를 설계하여 불확실성을 제거하는 경영 전략 방법
     - 사용성 테스트: 사용자가 직접 제품을 사용하면서 시나리오에 맞춰 과제를 수행한 후 질문에 응답하는 테스트
     - 워크숍: 특정 문제나 과제에 대한 새로운 지식, 기술, 아이디어, 방법 등을 서로 교환하고 검토하는 세미나
   - UI 화면 설계 구분
     - 와이어프레임: 화면 단위의 레이아웃을 설계하는 작업(ppt, 키노트, 스케치, 일러스트)
     - 스토리보드: 서비스 구축을 위한 모든 정보(정책, 프로세스, 와이어프레임, 기능 정의 등)가 담겨있는 설계 산출물(ppt, 키노트, 스케치)
     - 프로토타입: 정적인 화면(와이어프레임, 스토리보드)에 동적 효과를 적용하여 실제 구현된 것 처럼 시뮬레이션 할 수 있는 모형. 전체적인 기능을 간략한 형태로 구현한 시제품(HTML, CSS)

2. UI 설계(중요도 ★★★)
   - UML(Unified Modeling Language): 객체 지향 소프트웨어 개발 과정에서 산출물을 명세화, 시각화, 문서화 할 때 사용되는 모델링 기술과 방법론을 통합해서 만든 표준화된 범용 모델링 언어
   - UML 특징: 가시화 언어, 구축 언어, 명세화 언어
   - UML 구성요소: 사물, 관계, 다이어그램
   - UML 다이어그램:
     - 구조적 다이어그램 / 정적 다이어그램
       - 클래스: 클래스의 **속성 및 연산**과 **클래스간의 정적인 관계**를 표현
       - 객체: 클래스에 속한 사물(객체=인스턴스)를 특정 시점의 객체와 객체 사이의 관계로 표현
       - 컴포넌트: 시스템을 구성하는 물리적인 컴포넌트와 그들 사이의 의존관계 표현
       - 배치: 컴포넌트 사이의 종속성을 표현하고, 물리적 요소들의 위치를 표현
       - 복함체 구조: 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현
       - 패키지: 유스케이스, 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계
     - 행위적 다이어그램 / 동적 다이어그램
       - 유스케이스: 시스템이 제공하고 있는 기능 및 그와 관련된 외부 요소를 사용자 관점에서 표현
       - 시퀀스: 객체 간 동적 상호작용을 시간적 개념을 중심으로 메시지 흐름으로 표현
       - 커뮤니케이션: 동작에 참여하는 객체들이 주고받는 메시지를 표현하고, 객체 간의 연관까지 표현
       - 상태: 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지 표현
       - 활동: 객체의 처리 로직이나 조건에 따른 처리 흐름을 순서대로 표현
       - 타이밍: 객체 간의 상태 변화와 시간 제약을 명시적으로 표현
   - UI 시나리오 문서의 작성요건: 완전성, 일관성, 이해성, 가독성, 추적용이성, 수정용이성
   - UI 설계 도구의 유형
     - 화면 설계 도구: 파워목업, 발사믹 목업, 카카오오븐
     - 프로토타이핑 도구: UX핀, 엑슈어, 네이버 프로토나우
     - UI 디자인 도구: 스케치, Adobe XD
     - UI 디자인 산출물로 작업하는 프로토타이핑 도구: 인버전, 픽사에이트, 프레이머

## 3. 데이터 입출력 구현

1. 논리 데이터 저장소 확인(중요도 ★★★)
   - 데이터 모델: 현실 세계의 정보를 인간과 컴퓨터가 이해할 수 있도록 추상화하여 표현한 모델
   - 데이터 모델 절차: 요구사항 분석 -> 개념적 설계 -> 논리적 설계 -> 물리적 설계
   - 논리 데이터 모델링: 업무의 모습을 모델링 표기법으로 형상화하여 사람이 이해하기 쉽게 표현하는 프로세스
   - 논리적 데이터 모델링 종류
     - 관계 데이터 모델: 테이블 형태, 1;1, N:M
     - 계층 데이터 모델: 트리 형태(상하 관계), 1:N
     - 네트워크 데이터 모델: 그래프 형태, N:M
   - 관계 대수: 관계형 데이터베이스에서 원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적 정형 언어
   - 관계 대수 연산자 종류
     - 일반 집합 연산자
       - 합집합: ∪
       - 교집합: ∩
       - 차집합: -
       - 카티션 프로덕트: ×
     - 순수 관계 연산자
       - 셀렉트: σ
       - 프로젝트: π
       - 조인: ⋈
       - 디비전: ÷
   - 관계해석: 튜플 관계해석과 도메인 해석을 하는 비절차적 언어
   - 논리 데이터 모델링 속성: 개체, 속성, 관계
   - 개체-관계(E-R) 모델: 데이터와 그들간의 관계를 사람이 이해할 수 있는 형태로 표현한 모델
   - 정규화: 데이터 모델에서 중복성을 제거하여 이상 현상을 방지하고, 데이터의 일관성과 정확성을 유지하기 위해 무손실 분해하는 과정
   - 이상현상: 데이터의 중복성으로 인해 릴레이션을 조작할 때 발생하는 비합리적 현상
     - 삽입이상: 불필요한 세부정보가 입력되는 경우
     - 삭제이상: 원치않는 다른 정보가 함께 삭제되는 경우
     - 갱신이상: 특정부분만 수정되어 중복된 값이 모순을 일으키는 경우
   - 정규화 단계
     - 1정규형(1NF): 도메인이 원자 값으로 구성
     - 2정규형(2NF): 부분함수 종속성 제거(완전 함수적 종속을 만족)
     - 3정규형(3NF): 이행함수 종속성 제거
     - 보이스-코드 정규형(BCNF): 결정자 후보 키가 아닌 함수 종속 제거
     - 4정규형(4NF): 다중 값 종속 제거
     - 5정규형(5NF): 조인 종속 제거
   - 반정규화: 정규화된 개체, 속성, 관계에 대해 성능향상과 개발운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법

2. 물리 데이터 저장소 설계(중요도 ★★★)
   - 참조 무결성 제약조건: 릴레이션과 릴레이션 사이에 대한 참조의 일관성을 보장하기 위한 조건
     - 제한: 다른 테이블이 삭제할 테이블을 참조중이면 제거하지 않는 옵션
     - 연쇄: 참조하는 테이블까지 연쇄적으로 제거하는 옵션
     - 널값: 참조되는 릴레이션에서 튜플을 삭제하고, 참조하는 튜플들의 외래값에 NULL 값을 넣는 옵션. 만약 NOT NULL 조건일 시 삭제 연산이 불가능
   - 인덱스: 데이터 레코드를 빠르게 접근하기 위해 '키 값, 포인터' 쌍으로 구성되는 데이터 구조
     - 클러스터드 인덱스: 인덱스의 **키의 순서에 따라 데이터가 정렬**되어 저장되는 방식
     - 넌클러스터드 인덱스: 인덱스의 키값만 정렬되어 있고, **실제 데이터는 정렬되지 않는 방식**
   - 뷰: 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로 구성된 가상 테이블
   - 클러스터: 데이터 액세스 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법. 클러스터의 분포도가 넓을수록 유리함.
   - 파티션: 대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것.
     - 범위분할: 지정한 열의 값을 기준으로 분할.
     - 해시분할: 해시 함수를 적용한 결과 값에 따라 데이터를 분할
     - 리스트분할: 특정 파티션에 저장 될 데이터에 대한 명시적인 제어가 가능한 분할 기법
     - 조합분할: 범위, 해시, 리스트 분할 중 2개 이상의 파티셔닝을 결합하는 방식. 파티션이 너무 클 때 활용.
   - 파티션의 장점: 성능 향상, 가용성 향상, 백업 가능, 경합 감소

3. 데이터베이스 기초 활용하기(중요도 ★★★)
   - 데이터베이스: 다수의 인원, 시스템 또는 프로그램이 사용할 목적으로 통합하여 관리되는 데이터의 집합
   - 데이터베이스의 정의
     - 통합된 데이터: 자료의 중복을 배제한 데이터의 모임
     - 저장된 데이터: 저장 매체에 저장된 데이터
     - 운영 데이터: 조직의 업무를 수행하는 데 필요한 데이터
     - 공용 데이터: 여러 애플리케이션, 시스템들이 공동으로 사용하는 데이터
   - 데이터베이스의 특성
     - 실시간 접근성: 쿼리에 대하여 실시간 응답이 가능해야 함.
     - 계속적인 변화: 새로운 데이터의 삽입, 삭제 갱신으로 항상 최신의 데이터를 유지
     - 동시공용: 다수의 사용자가 동시에 같은 내용의 데이터를 이용 할 수 있어야 함.
     - 내용참조: 사용자가 요구하는 데이터 내용으로 데이터를 찾음
   - 데이터베이스의 종류
     - 파일 시스템: 파일에 이름을 부여하고 저장이나 검색을 위해 논리적으로 그것들을 어디에 위치시켜야 하는지 등을 정의한 뒤 관리하는 데이터베이스 전 단계의 데이터 관리 방식
     - 관계형 데이터베이스 시스템(RDBMS): 관계형 모델을 기반
       - Oracle, SQL Server, MySQL, MariaDB 등
     - 계층형 데이터베이스 시스템(HDBMS): 데이터를 상하 종속적인 관계로 계층화하여 관리
       - IMS, System2000 등
     - 네트워크 데이터베이스 관리시스템(NDBMS): 데이터를 네트워크상의 망상 형태로 표현한 데이터 모델
       - 종류: IDS, IDMS 등
   - DBMS: 데이터 관리의 복잡성을 해결하는 동시에 데이터 추가, 변경, 검색, 삭제 및 백업, 복구, 보안 등의 기능을 지원하는 소프트웨어
   - DBMS 유형
     - 키-값(Key-Value) DBMS: Unique한 키에 하나의 값을 가지고 있는 형태
     - 컬럼 기반 데이터 저장(Column Family Data Store) DBMS: Key 안에 (Column, value) 조합으로 된 여러 개의 필드를 갖는 DBMS
     - 문서 저장(Document Store) DBMS: 값(Value)의 데이터 타입이 문서(Document) 라는 타입을 사용하는 DBMS
     - 그래프(Graph) DBMS: 시멘틱 웹가 온톨로지 분야에서 활용되는, 그래프로 데이터를 표현하는 DBMS
   - DBMS 특징: 무결성, 일관성, 회복성, 보안성, 효율성
   - 빅 데이터: 시스템, 서비스, 조직(회사) 등에서 주어진 비용, 시간 내에 처리 가능한 수십 페타바이트 크기의 비정형 데이터
     - 빅데이터의 특성: 데이터의 양, 데이터의 다양성, 데이터의 속도
       - 비정형 / 반정형 데이터 수집: 내/외부 정제되지 않은 데이터를 확보하여 수집 및 전송하는 기술
       - 정형 데이터 수집: 내/외부 정제된 대용량의 데이터의 수집 및 전송 기술
       - 분산데이터 저장/처리: 대용량 파일의 효과적인 분산 저장 및 처리기술
       - 분산데이터베이스: HDFS 칼럼 기반 데이터베이스로 실시간 랜덤 조회 및 업데이트 가능
         - HDFS: 대용량 데이터의 집합을 처리하는 응용 프로그램에 적합하도록 설계된 하둡 분산 파일 시스템
   - NoSQL: 데이터 저장에 고정된 테이블 스키마가 필요하지 않고 조인 연산을 사용 할 수 없으며, 수평적으로 확장이 가능한 DBMS
     - NoSQL 특성
       - Basically Available: 언제든지 데이터에 접근할 수 있는 속성
       - Soft-State: 외부에서 전송된 정보를 통해 결정되는 속성
       - Eventually Consistency: 일관성이 유지되는 속성
     - NoSQL 유형
       - Key-Value Store: Unique 한 키에 하나의 값을 가지고 있는 형태
       - Column Family Data Store: Key 안에 (column, value) 조합으로 된 여러개의 필드를 갖는 DB
       - Document Store: 값의 데이터 타입이 문서(Document)라는 타입을 사용하는 DB
       - Graph DBMS: 시멘틱 웹과 온톨로지 분야에서 활용되는, 그래프로 데이터를 표현하는 DBMS
         - 시멘틱 웹: 온톨로지를 활용하여 서비스를 기술하고, 온톨로지의 의미적 상호 운용성을 이용해서 서비스 검색, 조합, 중재 기능을 자동화하는 웹.
         - 온톨로지: 실세계에 존재하는 모든 개념들과 개념들의 속성, 그리고 개념들간의 관계 정보를 컴퓨터가 이해할 수 있도록 서술해 놓은 지식 베이스.
   - 데이터 마이닝: 대규로 저장된 데이터 안에서 체계적이고 자동적으로 통계적 규칙이나 패턴을 찾아내는 기술
   - 데이터 마이닝 절차: 목적 설정 -> 데이터 준비 -> 가공 -> 마이닝 기법 적용 -> 정보 검증
   - 데이터 마이닝 주요 기법
   - 분류 규칙: 과거 데이터를 토대로 새로운 레코드의 결과값을 예측하는 기법
   - 연관 규칙: 데이터 안에 항목들 간의 종속관계를 찾아내는 기법
   - 연속 규칙: 연관 규칙에 시간 관련 정보가 포함된 형태의 기법
   - 데이터 군집화: 대상 레코드들을 유사한 특성을 지닌 몇개의 소그룹으로 분할하는 작업

## 4. 통합 구현

1. 연계 요구사항 분석(중요도 ★)
   - 연계 요구사항 분석: 서로 다른 두 시스템, 장치, 소프트웨어를 이어주는 중계 역할을 하는 연계 시스템과 관련된 요구사항을 분석하는 과장
   - 연계 요구사항 분석 참고문서
     - 개체 정의서: 데이터베이스 개념 모델링 단계에서 도출한 개체의 타입과 관련 속성, 식별자 등의 정보를 개괄적으로 명세화한 정의서
     - 테이블 정의서: 논리 및 물리 모델링 과정 설계 산출물
     - 인터페이스 명세서: 인터페이스 정의서에 작성한 항목을 자세히 작성한 것

2. 연계 메커니즘 구성(중요도 ★★☆)
   - 연계 매커니즘: 응용 소프트웨어와 연계 대상 모듈 간의 데이터 연계 시 요구사항을 고려한 연계방법과 주기를 설계하기 위한 메커니즘
     - 기능: 데이터를 생성하며 전송하는 송신 시스템과 송신 데이터를 수신하여 DB에 반영하는 수신 시스템으로 구성
   - 주요 연계 기술
     - 직접 연계
       - DB 링크: 데이터베이스에서 제공하는 DB링크 객체를 이용
       - DB 연결: 수신 시스템의 WAS에서 송신 시스템 DB로 연결하는 DB 커넥션 풀을 생성하고 연계 프로그램에서 해당 DB 커넥션 풀 명을 이용하여 연계
       - API/Open API: 송신 시스템의 DB에서 데이터를 읽어서 제공하는 애플리케이션 프로그래밍 인터페이스 프로그램
       - JDBC: 수신 시스템의 프로그램에서 JDBC 드라이버를 이용하여 송신 시스템DB와 연결
       - 하이퍼 링크: 현재 페이지에서 다른 부분으로 가거나, 전혀 다른 페이지로 이동하게 해주는 속성
     - 간접 연계
       - 연계 솔루션(EAI): 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션들 간의 정보전달, 연계, 통합을 가능하게 해 주는 솔루션
       - Web Service/ESB: 웹 서비스가 설명된 WSDL과 SOAP 프로토콜을 이용한 시스템 간 연계
       - 소켓(Socket): 소켓을 생성하여 포트를 할당하고, 클라이언트의 요청을 연결하여 통신

3. 내외부 연계 모듈 구현(중요도 ★★★)
   - EAI(Enterprise Application Integration): 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션 간의 정보를 전달, 연계 및 통합이 가능하도록 해주는 솔루션.
     - 미들웨어를 이용하여 비즈니스 로직을 중심으로 기업 내 애플리케이션을 통합 연계
   - EAI 구성요소
     - EAI 플랫폼: 이기종 시스템 간 애플리케이션 상호 운영
     - 어댑터: 다양한 애플리케이션을 연결하는 EAI의 핵심 장치로 데이터 입출력 도구
     - 브로커: 데이터 포맷과 코드를 변환하는 솔루션
     - 메시지 큐: 비동기 메세지를 사용하는 다른 응용 프로그램 사이에서 데이터를 송수신하는 기술
     - 비즈니스 워크플로우: 미리 정의된 기업의 비즈니스 workflow에 따라 업무를 처리하는 기능
   - EAI 구축 유형
     - 포인트 투 포인트: 가장 기초적인 애플리케이션 통합방법. 1:1로 단순 통합
     - 허브 앤 스포크: 단일한 접점의 허브 시스템을 통하여 데이터를 전송하는 중앙 집중식 방식
     - 메시지 버스: 애플리케이션 사이 미들웨어를 두어 연계하는 미들웨어 통합 방식
     - 하이브리드: 그룹 내는 허브엔 스포크 방식을 사용, 그룹 간에는 메시지 버스 방식을 사용하는 통합 방식
   - ESB(Enterpirse Service Bus): 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션들 간을 하나의 시스템으로 관리 운영 할 수 있도록 서비스 중심의 통합을 지향하는 아키텍처. 느슨한 결합 방식을 지원(서비스 변경이 있어도 연결된 다른 서비스에 영향이 없음)
     - 미들웨어를 이용하여 서비스 중심으로 서비스를 지원하기 위한 관련 시스템과 유기적 연계
   - ESB 구축 유형: 버스 방식의 분산형 토폴로지 구성
   - 웹 서비스: 네트워크에 분산된 정보를 서비스 형태로 개방하여 표준화된 방식으로 공유하는 기술. 서비스 지향 아키텍처.
   - 웹 서비스 유형
     - SOAP(Simple Objet Access Protocol): HTTP, HTTPS, SMTP 등을 사용하여 XML기반의 메시지를 네트워크 상태에서 교환하는 프로토콜
     - WSDL(Web Service Description Language): 웹 서비스명, 제공 위치, 메시지 포맷, 프로토콜 정보 등 웹서비스에 대한 상세 정보가 기술된 XML 형식으로 구현되어 있는 언어.
     - UDDI(Universal Description, Discovery and Integration): 웹 서비스에 대한 정보인 WSDL를 등록하고 검색하기 위한 저장소로 공개적으로 접근, 검색이 가능한 레지스트.
   - IPC(Inter-Process Communication): 운영체제에서 프로세스 간 서로 데이터를 주고받기 위한 통신 기술.
   - 연계 테스트: 송신 시스템과 수신 시스템을 연계하였을 경우, 데이터의 정합성과 데이터 전송 여부에 대한 테스트.

## 5. 인터페이스 구현

1. 인터페이스 기능 구현(중요도 ★★★)
   - 컴포넌트 명세서: 컴포넌트 개요, 부 클래스의 동작, 인터페이스를 통해 외부와 통신하는 명세
   - 인터페이스 명세서: 컴포넌트 명세서에 명시된 인터페이스 클래스의 세부적인 조건 및 기능을 명시한 명세서.
   - JSON(Javascript Object Notation): 속성-값 쌍 또는 키-값 쌍으로 이루어진 데이터 오브젝트를 전달하기 위해 인간이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷. AJAX에서 많이 사용되고 XML을 대체하는 주요 데이터 포멧.
   - XML(eXtensible Markup Language): HTML의 단점을 보완한 인터넷 언어. SGML의 복잡한 단점을 개선한 특수한 목적을 갖는 마크업 언어
   - AJAX(Asynchronous Javascript And XML): 웹과 같은 분산 하이퍼미디어 환경에서 자원의 존재 / 상태 정보를 표준화된 HTTP 메서드로 주고 받은 웹 아키텍처.
     - REST 메서드: HTTP메서드 중 CRUD메서드만 사용-POST, GET, PUT, DELETE
   - 데이터베이스 암호화 알고리즘
     - 대칭키 알고리즘: 암, 복호화에 같은 암호 키를 쓰는 알고리즘.
     - 비대칭 암호화 알고리즘: 공개키는 누구나 알 수 있지만, 비밀키는 키 소유자만 알 수 있게 사용하는 알고리즘.
     - 해시 암호화 알고리즘: 해시 값으로 원래 입력값으 찾아 낼 수 있는 일방향성의 특성을 가진 알고리즘
   - 중요 인터페이스 데이터의 암호화 전송을 위한 보안 기술
     - IPSec(IP Security): IP계층(3계층)에서 무결성과 인증을 보장하는 인증 헤더(AH)와 기밀성을 보장하는 암호화(ESP)를 이용하여 양 종단 간(End Point) 구간에 보안 서비스를 제공하는 터널링 프로토콜
     - SSL/TLS: 전송계층(4계층)과 응용계층(7계층) 사이에서 클라이언트와 서버 간의 웹 데이터 암호화(기밀성), 상호인증 및 접속 시 데이터 무결성을 보장하는 보안 프로토콜
     - S-HTTP(Secure Hypertext Transfer Protocol): 웹상에서 네트워크 트래픽을 암호화하는 주요 방법. 클라이언트와 서버 간에 전송되는 모든 메세지를 암호화하여 전송

2. 인터페이스 기능 구현 검증(중요도 ★★)
   - 인터페이스 구현 검증 도구
     - xUnit: 자바, C++, .Net 등 다양한 언어를 지원하는 단위테스트 프레임워크
     - STAF: 서비스 호출, 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크
     - FitNesse: 웹 기반 테스트 케이스 설계/실행/결과 확인 등을 지원하는 테스트 프레임워크
     - NTAF: FitNesse(협업기능)+STAP(재사용, 확장성) 통합한 테스트 자동화 프레임워크
     - Selenium: 다양한 브라우저 지원 및 개발언어를 지원하는 웹 어플리케이션 테스트 프레임워크
     - water: 루비(Ruby)기반 웹 애플리케이션 테스트 프레임워크
   - 인터페이스 감시 도구
     - 스카우터(SCOUTER): 애플리케이션에 대한 모니터링 및 DB Agent를 통해 오픈소스 DB 모니터링 기능, 인터페이스 감시 기능을 제공
     - 제니퍼(Jennifer): 애플리케이션의 개발부터 테스트, 오픈, 운영, 안정화까지 전 생애주기 단계동안 성능을 모니터링하고 분석해주는 APM 소프트웨어.

## 7. SQL 응용

1. 데이터베이스 기본(중요도 ★★★)
   - 트랜젝션(Transaction): 인가받지 않은 사용자로부터 데이터를 보장하기위해 DBMS가 가져야하는 특성. 하나의 논리적 기능을 정상적으로 수행하기 위한 작업의 기본 단위.
   - 트랜잭션의 특성
     - 원자성(Atomicity): 트랜잭션의 연산 자체가 성공 또는 실패되어야하는 성질(All or Nothing)
     - 일관성(Consistency): 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 하는 성질
     - 격리성(Isolation): 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않아야 한다는 성질
     - 영속성(Durability): 성공이 완료된 트랜잭션의 결과는 영속적으로 데이터베이스에 저장되어야 하는 성질
   - 트랜잭션 제어어(TCL; Transaction Control Language): 트랜잭션의 결과를 허용하거나 취소하는 목적으로 사용되는 언어
     - TCL 명령어
       - Commit: 트랜잭션을 메모리에 영구적으로 저장하는 명령어
       - Rollback: 트랜잭션 내역의 저장을 무효화시키는 명령어
       - Checkpoint(Savepoint): Rollback을 위한 시점을 지정하는 명령어
   - 데이터 정의어(DDL; Data Definition Language): DB를 구축하거나 수정할 목적으로 사용하는 언어
   - DDL 대상
     - 도메인(Domain): 하나의 속성이 가질 수 있는 원자값들의 집합
     - 스키마(Schema): 데이터베이스의 구조, 제약조건 등의 정보를 담고 있는 기본적인 구조
       - 외부 스키마, 개념 스키마, 내부 스키마
     - 테이블(Table): 데이터 저장 공간
     - 뷰(View): 하나 이상의 물리 테이블에서 유도되는 가상의 테이블
     - 인덱스(Index): 검색을 빠르게 하기 위한 데이터 구조
       - 인덱스 종류
         - 순서 인덱스(Ordered Index): 데이터가 정렬된 순서로 생성되는 인덱스
         - 해시 인덱스(Hash Index): 해시 함수에 의해 직접 데이터에 키 값으로 접근하는 인덱스
         - 비트맥 인덱스(Bitmatp Index): bit 값인 0 또는 1로 변환하여 인덱스 키로 사용하는 인덱스
         - 함수기반 인덱스(Functional Index): 수식이나 함수를 적용하여 만든 인덱스
         - 단일 인덱스(Single Index): 하나의 컬럼으로만 구성한 인덱스
         - 결합 인덱스(Concatenated Index): 두 개 이상의 컬럼으로 구성한 인덱스
         - 클러스터드 인덱스(Clustered Index): 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식(검색 빠름)
         - 넌클러스터드 인덱스(Non-Clustered Index): 인덱스의 키 값만 정렬되어있고 실제 데이터는 정렬되지 않은 방식(데이터 삽입, 삭제 시 데이터 재정렬 해야함)
   - DDL 명령어: CREATE, ALTER, DROP
     - CASCADE: 제거할 요소를 참조하는 다른 모든 개체를 함께 제거
     - RESTRICT: 다른 개체가 제거할 요소를 참조중일때는 제거를 취소
   - 데이터 조작어(DML; Data Manipulation Language): 저장된 데이터를 실질적으로 관리하는데 사용되는 언어
     - DML 유형: SELECT, INSERT, UPDATE, DELETE
   - 데이터 제어어(DCL: Data Control Language): 데이터의 보안, 무결성, 회복, 병행 제어 등을 정의하는데 사용하는 언어
     - DCL 유형
       - GRANT: 사용 권한 부여
       - REVOKE: 사용 권한 취소

2. 응용 SQL 작성하기(중요도 ★)
   - 데이터 분석 함수 종류
     - 집계 함수: 여러 행 또는 테이블 전체 행으로부터 하나의 결괏값을 반환하는 함수
     - 그룹 함수: 소그룹 간의 소계 및 중계 등의 중간 합계 분석 데이터를 산출하는 함수
     - 윈도 함수: 데이터베이스를 사용한 온라인 분석 처리 용도로 사용하기 위해서 표준 SQL에 추가된 기능

3. 절차형 SQL 활용하기(중요도 ★)
   - 절차형 SQL(Precedural SQL): SQL 언어에서도 절차 지향적인 프로그램이 가능하도록 하는 트랜잭션 언어
     - 절차형 SQL 종류
       - 프로시저(Procedural SQL): 일련의 쿼리들을 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합
       - 사용자 정의 함수(User-Defined Function): SQL 처리를 수행하고, 수행 결과를 단일 값으로 반환할 수 있는 절차형 SQL
       - 트리거(Trigger): 데이터베이스 시스템에서 삽입, 갱신, 삭제 등의 이벤트가 발생할 때 마다 관련 작업이 자동으로 수행되는 절차형 SQL

4. 데이터 조작 프로시저 최적화(중요도 ★)
   - 쿼리 성능 개선: 최소의 시간으로 원하는 결과를 얻도록 프로시저를 수정하는 작업
     - SQL성능 개선 절차: 문제있는 SQL 식별 -> 옵티마이저 통계 확인 -> SQL문 재구성 -> 인덱스 재구성 -> 실행계획 유지관리
   - 옵티마이저(Optimizer): SQL이 가장 효율적으로 수행되도록 최적의 경로를 찾아 주는 모듈
     - 옵티마이저 유형
       - 규칙기반 옵티마이저(RBO): 사전에 정의해둔 규칙에 의거하여 경로를 찾는 규칙 기반 옵티마이저
       - 비용기반 옵티마이저(CBO): 각 DBMS마다 고유의 알고리즘에 따라 산출되는 비용으로 최적의 경로를 찾는 비용 기반 옵티마이저
   - 힌트(Hint): 실행하려는 SQL문에 사전 정보를 주어서 SQL문 실행에 빠른 결과를 가져오는 효과를 만드는 문법
     - 옵티마이저의 실행 계획을 원하는대로 변경할 수 있게 한다.
     - 옵티마이저는 명시적인 힌트를 통해 실행 계획을 변경한다.

## 8. 서버 프로그램 구현

1. 개발환경 구축(중요도 ★★★)
   - 개발 도구 분류
     - 빌드 도구: 작성한 코드의 빌드 및 배포를 수행하는 도구(And, Maven, Gradle)
     - 구현 도구: 코드의 작성과 디버깅, 수정 드과 같이 작업 시 사용하는 도구(Eclipse, InteliJ, VS)
     - 테스트 도구: 코드의 기능 검증과 전체의 품질을 높이기 위해 사용하는 도구(xUnit, PMD, Sonar)
     - 형상 관리도구: 산출물에 대한 버전관리를 위한 도구(Git, SVN, CVS)
   - 서버 하드웨어 개발환경
     - 웹 서버: HTTP를 이용한 요청, 응답을 처리(Apache 웹 서버, 구글 웹 서버)
     - 웹 어플리케이션 서버(WAS): 동적 콘텐츠를 처리하고 제공하기 위해 사용(Tomcat, Jeus, Resin)
     - 데이터베이스 서버: 데이터의 수집, 저장을 위한 용도로 사용(MySQL, Oracle, MSSQL)
     - 파일 서버: 파일 저장 하드웨어로 물리 저장 장치를 활용한 서버(HDD, SSD)
   - 소프트웨어 개발환경
     - 운영체제: 사용자 관점에서 편리하고 유용하게 사용하기 위한 소프트웨어
     - 미들웨어: 웹 서버, JVM과 같은 개발 환경의 구성요소로 활용
     - DBMS: 데이터의 저장 및 활용을 위해 DBMS 설치
   - 형상관리(Configuration Management): 소프트웨어 개발을 위한 전체 과정에서 발생하는 모든 항목의 변경사항을 관리하기 위한 활동
     - 형상관리 절차: 형상식별(대상정의) -> 형상통제(버전관리) -> 형상감사(무결성) -> 형상기록(보고서)
   - 소프트웨어 형상 관리 도구 유형
     - 공유 폴더 방식: 매일 개발이 완료된 파일은 약속된 위치의 공유폴더에 복사하는 방식(RCS, SCCS)
     - 클라이언트/서버 방식: 중앙에 버전 관리 시스템을 항시 동작시키는 방식(CVS, SVN)
     - 분산 저장소 방식: 로컬 저장소와 원격 저장소로 분리되어 분산 저장하는 방식(Git)
   - 소프트웨어 형상관리 도구별 특징
     - CVS(Concurrent Versions System): 서버와 클라이언트로 구성되어 있고, 다수의 인원이 동시에 범용적인 운영체제로 접근 가능한 형상 관리 도구
     - SVN(Subversion): 하나의 서버에서 소스를 쉽고 유용하게 관리할 수 있게 도와주는 도구
     - RCS(Revision Control System): 소스 파일의 수정을 한 사람만으로 제한하여 다수의 사람이 파일 수정을 동시에 할 수 없도록 파일 잠금 방식으로 형상을 관리하는 도구
     - Bitkeeper: 중앙 통제 방식으로 대규모 프로젝트에서 빠른 속도를 내도록 개발된 형상 관리 도구
     - Git: 속도에 중점을 둔 분산형 버전 관리 시스템. 대형 프로젝트에서 효과적이고 유용함.
     - Clear Case: 복수 서버, 복수 클라이언트 구조, 필요한 서버를 하나씩 추가하여 확장성을 기할 수 있음.

2. 공통 모듈 구현(중요도 ★★)
   - 모듈(Module): 하나의 완전한 기능을 수행 할 수 있는 독립된 실체
   - 모듈화: 프로그램 개발시 생산성과 최적화, 관리에 용이하게 기능 단위로 분할하는 기법
     - 모듈화의 원리: 정보은닉, 분할과 정복, 데이터 추상화, 모듈 독립성
   - 응집도(Cohesion): 모듈의 독립성을 나타내는 정도로 모듈 내부 구성요소 간 연관 정도
     - 응집도 유형: 우연적 응집도, 논리적 응집도, 시간적 응집도, 절차적 응집도, 통신적 응집도, 순차적 응집도, 기능적 응집도
   - 결합도(Coupling): 외부 모듈과의 연관도 또는 모듈 간의 상호의존성, 모듈간의 관련성을 측정하는 척도.
     - 결합도 유형: 내용결합도, 공통결합도, 외부결합도, 제어결합도, 스탬프결합도, 자료결합도.
   - 응집도는 높을수록 좋고, 결합도는 낮을수록 좋다.
   - 공통 모듈 구현 절차: DTO/VO -> SQL -> DAO -> Service -> Controller -> 화면구현
     - DTO(Data Transfer Object): 프로세스 사이에서 데이터를 전송하는 객체
     - VO(Value Object): 고정 클래스를 가지는 객체
     - DAO(Data Access Object): 특정 타입의 데이터베이스에 추상 인터페이스를 제공하는 객체
   - 팬인 및 팬아웃
     - Fan-In: 어떤 모듈을 제어하는 모듈의 수 / 모듈 자신을 기준으로 모듈에 들어오면 팬인
     - Fan-Out: 어떤 모듈에 의해 제어되는 모듈의 수 / 모듈 자신을 기준으로 모듈에서 나가면 팬아웃
     - 시스템 복잡도를 최적화하기 위해 팬인은 높게, 팬아웃은 낮게 설계해야 한다.
   - 공통 모듈 테스트: IDE 도구를 활용하여 개별 공통 모듈에 대한 디버깅을 수행
     - 통합 개발환경(IDE): 개발에 필요한 다양한 틀을 하나의 인터페이스로 통합하여 제공하는 환경(Eclipse, VS, Android Studio, IDEA)
   - 공통 모듈 테스트 종류
     - 화이트 박스 테스트: 소스 코드를 보면서 테스트 케이스를 다양하게 만들어 테스트
     - 메서드 기반 테스트: 공통 모듈의 외부에 공개된 메서드 기반 테스트
     - 화면 기반 테스트: 화면 단위로 단위 모듈을 개발 후에 화면에 직접 데이터를 입력하여 테스트
       - 테스트 드라이버(Test Driver): 하위 모듈은 있지만, 상위 모듈은 없는 경우 사용
       - 테스트 스텁(Test Stub): 상위 모듈은 있지만 하위 모듈은 없는 경우 사용
   - Junit: 자바 프로그래밍 언어용 단위 테스트 도구

3. 배치 프로그램 구현(중요도 ★)
   - 배치 프로그램(Batch Program): 사용자와의 상호작용 없이 일련의 작업을 작업 단위로 묶어 정기적으로 반복 수행하거나 규칙에 따라 일괄 처리하는 기법
   - 배치 프로그램 유형:
     - 이벤트 배치: 사전에 정의해 둔 조건 충족 시 자동으로 실행
     - 온디맨드 배치: 사용자의 명시적 요구가 있을 때마다 실행
     - 정기 배치: 정해진 시간에 정기적으로 실행
   - 배치 스케줄러: 일괄 처리 작업이 설정된 주기에 맞춰 자동으로 수행되도록 지원하는 도구
   - 배치 스케줄러 종류
     - 스프링 배치(Spring Batch): 오픈소스 프레임워크
     - 쿼츠 스케줄러(Quartz Scheduler): 수행할 작업과 수행시간을 관리하는 요소들을 분리하여 일괄 처리 작업에 유연성을 제공(오픈소스 라이브러리)
   - Cron 표현식: 크론 표현식을 통해 배치 수행 시간을 시간 및 주기 등으로 설정
     - 리눅스 / 유닉스 크론 표현식: 분, 시간, 일, 월, 요일, 연도
     - 쿼츠 크론 표현식: 초, 분, 시간, 일, 월, 요일, 연도

## 9. 소프트웨어 개발 보안 구축

1. 소프트웨어 개발 보안 설계(중요도 ★★★)
   - SW 개발 보안: 소프트웨어 개발 과정에서 지켜야 할 일련의 보안 활동
     - SW 개발 보안 생명주기: 요구사항 명세 -> 설계 -> 구현 -> 테스트 -> 유지보수
   - SW 개발 보안 3대 요소
     - 기밀성(Confidentiality): 시스템 내의 정보와 자원은 인가된 사용자에게만 접근이 허용
     - 무결성(Integrity): 시스템 내의 정보는 오직 인가된 사용자만 수정 할 수 있음
     - 가용성(Availability): 인가받은 사용자는 시스템 내의 정보와 자원을 언제라도 사용할 수 있음
   - DoS(Denial of Service)공격: 시스템을 악의적으로 공격해서 해당 시스템의 자원을 부족하게 하여 원래 의도된 용도로 사용하지 못하게 하는 공격
   - DoS공격의 종류
     - SYN 플러딩(SYN Flooding): 서버의 동시 가용 사용자 수를 SYN 패킷만 보내 점유하여 다른 사용자가 서버를 사용 불가능하게 하는 공격
     - UDP 플러딩(UDP Flooding): 대량의 UDP 패킷을 만들어 임의의 포트 번호로 전송하여 응답 메시지를 생성하게 하여 지속해서 자원을 고갈시키는 공격
     - 스머프(Smurf)/스머핑(Smurfing): 출발지 주소를 대상의 IP로 설정하여 네트워크 전체에게 ICMP Echo 패킷을 직접 브로드캐스팅하여 마비시키는 공격
     - 죽음의 핑(PoD; Ping of Death): ICMP 패킷을 정상적인 크기보다 아주 크게 만들어 전송하여 정상적인 서비스를 못하도록 하는 공격
     - 랜드 어택(Land Attack): 출발지 IP와 목적지 IP를 같은 패킷 주소로 만들어 보내 시스템의 가용성을 침해하는 공격
     - 티어 드롭(Tear Drop): IP 패킷의 재조합 과정에서 잘못된 정보로 인해 수신 시스템이 문제를 발생하도록 만드는 공격
     - 봉크(Bonk)/보잉크(Boink): 프로토콜의 오류 제어를 이용한 공격 기법
   - DDoS(Distributed Denial of Service): 여러 대의 공격자를 분산 배치하여 동시에 동작하게 함으로서 특정 사이트를 공격하는 기법
   - DDoS 공격 도구
     - Trinoo: 많은 소스로부터 통합된 UDP flood 서비스 거부 공격을 유발하는 데 사용되는 도구
     - Tribe Flood Network: 많은 소스에서 하나 혹은 여러 개의 목표 시스템에 대해 서비스 거부 공격을 수행 할 수 있는 도구
     - Stacheldraht: 분산 서비스 거부 에이전트 역할을 하는 Linux 및 Solaris 시스템용 멀웨어 도구
   - DoS 와 DDoS의 차이
     - DoS는 직접 공격, DDoS는 공격하도록 지시
     - DoS는 한 사람에 의해 공격, DDoS는 수많은 감염 호스트를 통해 공격을 감행
   - DRDoS(Distributed Reflection DoS): 공격자는 출발지 IP를 공격대상 IP로 위조하여 다수의 반사 서버로 요청 정보를 전송, 공격 대상자는 반사 서버로부터 다량의 응답을 받아서 서비스 거부가 되는 공격
   - 세션 하이재킹(Session Hijacking): TCP의 세션 관리 취약점을 이용한 공격 기법. 케빈 미트닉이 사용
   - 애플리케이션 공격기법
     - HTTP GET 플러딩: 과도한 Get메시지를 이용하여 웹 서버의 과부하를 유발시키는 공격
     - Slowloris: HTTP GET 메서드를 사용하여 헤더의 최종 끝을 알리는 개행 문자열을 전송하지 않고, 대상 웹 서버와 연결상태를 장시간 지속시키고 연결 자원을 모두 소진시키는 서비스 거부 공격
     - RUDY: 요청 헤더의 Content-Length를 비정상으로 크게 설정하여 메시지 바디 부분을 매우 소량으로 보내 계속 연결 상태를 유지시키는 공격
     - Slow HTTP Read DoS: 다수 HTTP 패킷을 지속적으로 전송하여 웹 서버의 연결상태가 장시간 지속, 연결자원을 소진시키는 서비스 거부 공격
     - Hulk DoS: 공격자가 웹 페이지 주소를 지속적으로 변경하면서 다량으로 GET 요청을 발생시키는 서비스 거부 공격
     - Hash DoS: 많은 수의 파라미터를 POST 방식으로 웹서버로 전달하여 다수의 해시 충돌을 발생시켜서 자원을 소모시키는 서비스 거부 공격
   - 네트워크 공격
     - 스니핑: 공격대상의 데이터만 몰래 들여다보는 수동적인 공격 기법
     - 네트워크 스캐너, 스니퍼: 네트워크 하드웨어 및 소프트웨어의 구성 취약점 파악을 위해 공격자가 취약점을 탐색하는 공격 도구
     - 패스워드 트래킹
       - 사전 크래킹: ID 와 PW가 될 가능성이 있는 단어를 파일로 만들어 파일의 단어를 대입하여 크랙하는 공격 기법
       - 무차별 크래킹: 무작위로 패스워드의 자리에 대입하여 패스워드를 알아내는 공격 기법
       - 패스워드 하이브리드 공격: 사전공격 + 무차별 공격
       - 레인보우 테이블 공격: 크래킹 하고자 하는 해시 값을 테이블에서 검색해서 역으로 패스워드를 찾는 공격 기법
     - IP 스푸핑: 침입자가 인증된 컴퓨팅 시스템인것처럼 속여서 인증된 호스트의 IP주소로 위조하여 타깃에 전송하는 공격 기법
     - ARP 스푸핑: 공격자가 특정 호스트의 MAC 주소를 자신의 MAC 주소로 위조한 ARP Reply를 만들어 희생자에게 지속적으로 전송
     - ICMP Redirect 공격: 스니핑 시스템을 네트워크에 존재하는 또다른 라우터라고 알림으로써 패킷의 흐름을 바꾸는 공격기법
     - 트로이 목마: 악성 루틴이 숨어있는 프로그램. 실행하면 악성코드를 실행.
   - 버퍼 오버플로우(Buffer Overflow) 공격: 메모리에 할당된 버퍼 크기를 초과하는 양의 데이터를 입력하여 프로세스의 흐름을 변경시켜서 악성코드를 실행시키는 공격 기법
   - 백도어(Backdoor): 허가받지 않고 시스템에 접속하는 권리, 정상적인 인증 절차를 우회하는 기법
   - 보안 관련 용어
     - 스피어 피싱(Spear phishing): 발송 메일의 본문 링크나 첨부된 파일을 클릭하도록 유도해서 사용자의 개인정보를 탈취하는 공격기법
     - 스미싱(Smishing): SMS를 이용하여 개인 비밀정보를 요구하거나 휴대폰 소액 결제를 유도하는 피싱 공격
     - 큐싱(Qshing): QR코드를 통해 악성 앱을 내려받도록 유도하여 금융 정보 등을 빼내는 피싱 공격
     - 봇넷(Botnet): 악성 프로그램이 감염되어있는 컴퓨터들이 네트워크로 연결된 형태
     - APT 공격(Advanced Persistent Threat): 다양한 수단을 통한 지속적이고 지능적인 맞춤형 공격 기법
     - 공급망 공격(Supply Chain Attack): SW 개발사의 네트워크에 침투하여 악의적으로 코드를 삽입, 서버 배포하여 사용자가 설치 또는 업데이트시에 자동적으로 감염되도록 하는 공격 기법.
     - 제로데이 공격(Zero Day Attack): 보안 취약점이 발견되어 널리 공표되기 전에 해당 취약점을 이용하여 이루어지는 보안 공격기법
     - 웜(Worm): 스스로 복제하여 네트워크 등의 연결을 통하여 전파하는 악성 소프트웨어 프로그램
     - 악성 봇(Malicious Bot): 해커의 명령에 의해 원격에서 제어 또는 실행이 가능한 프로그램 또는 코드
     - 사이버 킬 체인(Cyber Kill Chain): 공격형 방위 시스템. APT 공격방어 분석 모델
     - 랜섬웨어(Randomware): 시스템의 파일을 암호화하여 인질처럼 잡고 몸값을 요구하는 악성 소프트웨어
     - 이블 트윈(Evil Twin)공격: 핫스팟에 연결한 무선 사용자들의 정보를 탈취하는 무선 네트워크 공격 기법
   - 서버 인증의 기능: 스니핑 방지(SSL인증서 설치), 피싱 방지, 데이터 변조 방지, 기업 신뢰도 향상(기업 인증)
   - 인증 기술의 유형
     - 지식기반 인증: 사용자가 기억하고 있는 지식(ID/PW)
     - 소지기반 인증: 소지하고 있는 사용자 물품(공인인증서, OTP)
     - 생체기반 인증: 고유한 사용자의 생체 정보(홍채, 얼굴, 지문)
     - 특정기반 인증: 사용자의 특징을 활용(서명, 몸짓)
   - 접근 통제 기법
     - 식별(Identification): 자신이 누구라고 시스템에 밝히는 행위
     - 인증(Authentication): 주체의 신원을 검증하기 위한 활동
     - 인가(Authorization): 인증된 주체에게 접근을 허용하는 활동
     - 책임추적성(Accountability): 주체의 접근을 추적하고 행동을 기록하는 활동
   - 서버 접근 통제 유형
     - 임의적 접근통제(DAC): 신분에 근거하여 객체에 대한 접근을 제한하는 방법
     - 강제적 접근 통제(MAC): 주체가 갖는 접근 허가 권한에 근거하여 객체에 대한 접근을 제한하는 방법
     - 역할 기반 접근 통제(RBAC): 중앙 관리자가 조직 내 맡은 역할에 기초하여 자원에 대한 접근을 제한하는 방법
   - 접근 통제 보호 모델
     - 벨-라파듈라 모델(BLP): 미 국방부지원 보안 모델. 보안요소 중 기밀성을 가중하며 강제적 정책에 의해 접근을 통제하는 모델
       - No Read Up: 보안 수준이 낮은 주체는 보안수준이 높은 객체를 읽어서는 안됨.
       - No Write Down: 보안수준이 높은 주체는 보안수준이 낮은 객체에 기록하면 안됨.
     - 비바 모델: 무결성을 보장하는 최초 모델
       - No Read Down: 높은 등급의 주체는 낮은 등급의 주체를 읽을 수 없음
       - No Write Up: 낮은 등급의 주체는 상위 등급의 객체를 수정 할 수 없음
   - 암호 알고리즘(Encryption Algorithm): 데이터의 무결성 및 기밀성 확보를 위해 정보를 쉽게 해독 할 수 없는 형태로 변환하는 기법
   - 양방향 방식: 대칭 키 암호 방식. 비대칭 키 암호 방식
   - 일방향 해시함수 방식: MDC, MAC
 - 대칭 키 암호 방식: 암호화와 복호화에 같은 암호 키를 쓰는 알고리즘
   - 블록 암호 방식: 고정길이의 블록을 암호화하여 반복하는 알고리즘(EDS, AES, SEED)
   - 스트림 암호 방식: 매우 긴 주기의 난수열을 발생시켜 평문과 더불어 암호문을 생성하는 방식(RC4)
   - 비대칭 키 암호 방식: 개인 키를 나눠 가지지 않은 사용자들이 안전하게 통신하는 방식. 공개키는 누구나 알 수 있으나 개인키는 키의 소유자만 알고있어야 한다.(RSA, 디피-헬만)
   - 일방향 암호 방식(해시 암호 방식): 임의 길이의 정보를 입력받아, 고정된 길이의 암호문(해시값)을 출력하는 암호 방식
     - MAC: 키를 사용하는 메시지 인증 코드로 메시지의 무결성과 송신자의 인증 보장
     - MDC: 키를 사용하지 않는 변경 감지 코드로 메시지의 무결성 보장
   - 대칭키 암호화 알고리즘
     - DES: 1975년 IBM 개발, 대칭 키 기반
     - SEED: 1999년 한국인터넷진흥원(KISA) 개발
     - AES: 2001년 미국 표준기술연구소(NIST)개발
     - ARIA: 2004년 국가정보원과 산학연구협회가 개발
     - IDEA: DES 대체, 스위스 연방기술기관 개발
     - LFSR: 선형함수로 계산되는 구조로 되어있는 스트림 암호화 알고리즘
   - 비대칭키 암호화 알고리즘
     - 디피-헬만: 최초의 공개키 알고리즘
     - RSA: 1977년 MIT 개발
     - ElGamal: 1984년 ElGamal 개발
     - ECC: 1985년 RSA 대안으로 개발
   - 해시 암호화 알고리즘
     - MD5: MD4 개선한 암호화 알고리즘. 파일의 무결성 검사에 사용
     - SHA-1: 1993년 NSA에 미국 정부 표준 지정
     - SHA-256/384/512: 256비트의 해시값을 생성하는 해시함수
     - HAS-160: 국내 표준 서명 알고리즘
     - HAVAL: 메시지를 1024bits 블록으로 나눔
   - IPSec(Internet Protocol Security): 무결성과 인증을 보장하는 인증헤더와 기밀성을 보장하는 암호화를 이용한 IP 보안 프로토콜
   - SSL(Secure Socket Layer)/TLS(Transport Layer Security): 클라이언트와 서버간의 웹데이터 암호화(기밀성), 상호 인증 및 전송시 데이터 무결성을 보장하는 보안 프로토콜
   - S-HTTP(Secure Hypertext Transfer Protocol): 웹상에서 네트워크 트래픽을 암호화하는 방법

2. 소프트웨어 개발 보안 구현(중요도 ★★★)
   - 시큐어 코딩 가이드: 설계 및 구현 단계에서 해킹 등의 공격을 유발할 가능성이 있는 잠재적인 보안 취약점을 사전에 제거하고, 외부 공격으로부터 안전한 소프트웨어를 개발하는 기법
     - 보안 취약점: 운영 단계의 보안 리스크
     - 보안 약점: 개발 단계의 보안 리스크
   - 입력 데이터 검증 및 표현: 입력 데이터로 인해 발생하는 문제들을 예방하기 위해 구현 단계에서 검증해야 하는 보안 점검 항목
   - 입력 데이터 검증 및 표현 취약점
     - XSS(Cross Site Script): 검증되지 않은 외부입력 데이터가 포함된 웹페이지를 사용자가 열람함으로써 웹페이지에 포함된 부적절한 스크립트가 실행되는 공격
       - 대책: 특수문자 필터링, HTML태그 사용 금지
     - 사이트 간 요청 위조(CSRF; Cross-Site Request Forgery): 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위를 특정 웹 사이트에 요청하게 하는 공격
       - 대책: 입력화면 폼 POS 방식 사용, 세션별 CSRF 토큰 사용
     - SQL 삽입(Injection): 악의적인 SQL 구문을 삽입, 실행시켜 데이터베이스의 접근을 통해 정보를 탈취하거나 조작 등의 행위를 하는 공격
       - 대책: 변수 타입 지정, 사용자 입력값 모두 체크하여 필터링
   - 보안 기능: 소프트웨어 개발 단계에서 인증, 접근제어, 기밀성, 암호화, 권한 관리 등을 적절하게 구현하기 위한 보안 점검 항목
   - 에러 처리:  프로그램 실행 시 발생하는 에러를 예외 처리하지 못하거나, 에러에 중요한 정보가 포함될 때 발생할 수 있는 취약점을 예방하기 위한 보안 점검 항목
   - 세션 통제: 세션과 관련되어 발생할 수 있는 취약점을 예방하기 위한 보안 점검 항목
   - 코드 오류: 개발자의 실수로 발생하는 프로그램 오류를 예방하기 위한 보안 점검 항목
   - 캡슐화: 외부에 은닉이 필요한 중요한 데이터와, 인가되지 않은 사용자들에게 노출되지 않게 보안 취약점을 예방하기 위한 보안 검증 항목
   - API 오용: 보안에 취약한 API를 오용하여 발생할 수 있는 보안 취약점 예방을 위한 보안 검증 항목
   - 네트워크 보안 솔루션
     - 방화벽(Firewall): 기업 내부, 외부 간 트래픽을 모니터링하여 시스템의 접근을 허용/차단하는 시스템
     - 웹 방화벽(WAF; Web Application Firewall): 단말기가 내부 네트워크에 접속을 시도할 때 이를 제어하고 통제하는 기능을 제공하는 솔루션
     - 네트워크 접근 제어(NAC; Network Access Control): 단말기가 내부 네트워크에 접속을 시도 할 때 이를 제어하고 통제하는 기능을 제공하는 솔루션
     - 침입 탐지 시스템(IDS; Intrusion Detection System): 네트워크에 발생하는 이벤트를 모니터링하고, 보안정책 위반 행위를 실시간으로 탐지하는 시스템
     - 침입 방지 시스템(IPS; Intrusion prevention System): 네트워크에 대한 공격이나 침입을 실시간적으로 차단하고, 유해트래픽에 대해 능동적으로 조치하는 시스템
     - 무선 침입 방지 시스템(WIPS; Wireless Intrusion Prevention System): 무선 단말기의 접속을 자동 탐지 및 차단하고 보안에 취약한 무선공유기를 탐지하는 시스템
     - 통합 보안 시스템(UTM; Unified Threat Management): 다양한 보안 장비의 기능을 하나의 장비로 통합하여 제공하는 시스템
     - 가상사설망(VPN; Virtual Private Network): 인터넷과 같은 공중망에 인증, 암호화, 터널링 기술을 활용해 마치 전용망을 사용하는 효과를 가지는 보안 솔루션
   - 시스템 보안 솔루션
     - 스팸 차단 솔루션(Anti-Spam Solution): 메일 서버 앞단에 위치하여 Proxy 메일 서버로 동작
     - 보안 운영체제(Secure OS): 컴퓨터 운영체제의 커널에 보안 기능을 추가한 솔루션
   - 콘텐츠 유출 방지 솔루션
     - 보안 USB: 정보 유출 방지 등의 보안 기능을 갖춘 USB 메모리
     - 데이터 유출 방지(DLP; Data Loss Prevention): 조직 내부의 중요 자료가 외부로 빠져나가는 것을 탐지하고 차단하는 솔루션
     - 디지털 저작권 관리(DRM): 디지털 저작물에 대한 보호와 관리를 위한 솔루션
   - 소프트웨어 개발 보안테스트 유형
     - 정적 분석: SW를 실행하지 않고 보안 약점을 분석. 개발 단계.
     - 동적 분석: SW를 실행환경에서 보안 약점 분석. 시험 단계.
   - 비즈니스 연속성 계획(BCP: Business Continuity Plan): 각종 재해, 장애, 재난으로부터 위기관리 기반으로 재해복구, 업무복구 및 재개, 비상계획 등을 통해 비즈니스 연속성을 보장하는 체계