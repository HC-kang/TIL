# BitCount

요즘 새로운 알고리즘 스터디를 시작했습니다.  
바로 [달레의 코드](https://www.youtube.com/@DaleSeo) 유튜브 채널(과 여러 블로그 등)을 운영하시는 달레님의 [리트코드 스터디](https://github.com/DaleStudy/leetcode-study)입니다.  

해외 취업을 준비하시는분들이나, 리트코드를 통해 알고리즘을 공부하실 분들께서 관심이 있으시다면 참고하시면 좋을 것 같습니다.

아무튼, 이 스터디의 첫번째 주차에 [191. Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits)라는 문제를 풀었습니다.

`easy`등급의 문제이다보니 풀이 자체는 어렵지 않았지만 신기한 함수를 발견해서 이 원리를 이해 해 보려고 합니다.

정확한 발단을 좀 더 말씀드리자면, 제 풀이는 분명 `O(logn)`의 시간복잡도를 가졌고 나름 깔끔하게 잘 풀었다고 생각했었습니다.

```ts
function hammingWeight(n: number): number {
    // 시간복잡도: O(logn)
    // 공간복잡도: O(logn)
    // 가독성이 좋고, 공간복잡도가 그리 나쁘지 않다.
    return n.toString(2).split('1').length - 1;

    // 시간복잡도: O(logn)
    // 공간복잡도: O(1)
    // 성능이 더 좋지만, 비트연산자가 낯선 사람들에게는 이해하기 어려울 수 있다.
    let count = 0;
    while (n !== 0) {
        count += n & 1;
        n >>>= 1;
    }
    return count;
}
```

그런데, Java 사용자분께서 내장함수 단 한 줄로 `O(1)` 풀이를 하셨더라구요.  
풀이는 아래와 같습니다.

```java
// 시간복잡도 O(1)
// 공간복잡도 O(1)
class Solution {
    public int hammingWeight(int n) {
        return Integer.bitCount(n);
    }
}
```

아니 이게 어떻게 되는거지? 말이 되나? 싶어서 찾아보니, `Integer.bitCount`라는 함수의 내부 구현은 이렇더라구요.

```java
public final class Integer
{
    public static int bitCount(int i)
    {
        i = i - ((i >>> 1) & 0x55555555);
        i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
        i = (i + (i >>> 4)) & 0x0f0f0f0f;
        i = i + (i >>> 8);
        i = i + (i >>> 16);
        return i & 0x3f;
    }
}
```

그래서 이 함수를 (잘 이해는 안되지만) 구현해서 아래와 같이 제출해보니 역시나 `O(1)`의 시간복잡도로 당연히 통과되었습니다.

```ts
function hammingWeight(i: number): number {
    i = i - ((i >>> 1) & 0x55555555);
    i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
    i = (i + (i >>> 4)) & 0x0f0f0f0f;
    i = i + (i >>> 8);
    i = i + (i >>> 16);
    return i & 0x3f;
};
```

자 그러면, 이 함수가 어떻게 동작하는지 이해해보도록 하겠습니다.

## 1. 비트연산자

먼저, 이 함수는 비트연산자를 사용하고 있습니다. 다들 아시겠지만 긴가민가 하신 분들을 위해 간단히 설명드리겠습니다.

- `&`: AND 연산자
- `>>>`: 부호없는 우측 시프트 연산자

이 두 연산자에 대해 간단히 설명하자면, `&`는 두 비트가 모두 1일 때만 1을 반환하고, `>>>`는 부호비트를 무시하고 오른쪽으로 비트를 이동시킵니다.

예를 들자면, 5(101)와 3(011)의 `&` 연산은 1(001)이 되고, 5(101)의 `>>>` 1은 2(010)이 됩니다.

```md
    101 = 5
    011 = 3
  & ---
    001 = 1
```

```md
    101 = 5
  >>> 1
    010 = 2
```

## 2. 비트연산자를 이용한 비트 카운팅

자, 다시 한번 이전의 함수를 가져와보겠습니다.

```ts
function hammingWeight(i: number): number {
    i = i - ((i >>> 1) & 0x55555555);
    i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
    i = (i + (i >>> 4)) & 0x0f0f0f0f;
    i = i + (i >>> 8);
    i = i + (i >>> 16);
    return i & 0x3f;
};
```

이 함수는 총 5단계로 이루어져 있습니다. 여기서는 만만한 숫자를 하나로 예를 들어보겠습니다. `i = 42`라고 가정하겠습니다.

```md
42 = 0000 0000 0000 0000 0000 0000 0010 1010
```

### 1단계 - 2비트씩 묶어서 1로 만들기

> `i = i - ((i >>> 1) & 0x55555555);`

이 코드를 보면 `i`를 오른쪽으로 1비트씩 시프트한 값과 `0x55555555`를 `&` 연산한 값을 빼는 것을 볼 수 있습니다.

피상적으로는 알겠는데, 이게 무슨 의미일까요? 더 명확하게 직접 계산해 보겠습니다.

먼저 `0x55555555`는 16진수로, 2진수로 표현하면 `0101 0101 0101 0101 0101 0101 0101 0101`입니다.

```md
    0000 0000 0000 0000 0000 0000 0001 0101 = 42 >>> 1 = 21
  & 0101 0101 0101 0101 0101 0101 0101 0101
    -------------------------------------------
    0000 0000 0000 0000 0000 0000 0001 0101 = 21 & 0x55555555 = 21
```

```md
    0000 0000 0000 0000 0000 0000 0010 1010 = 42
  - 0000 0000 0000 0000 0000 0000 0001 0101 = 21
    -------------------------------------------
    0000 0000 0000 0000 0000 0000 0001 0101 = 21
```

자 이렇게 계산하면 `i = 21`이 됩니다. 이렇게 2비트씩 묶어서 1로 만드는 이유는 무엇일까요? 아직 잘 모르겠습니다.

### 2단계 - 4비트씩 묶어서 1로 만들기

> `i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);`

이 코드는 `i`와 `i`를 오른쪽으로 2비트씩 시프트한 값을 `0x33333333`와 각각 `&`연산한 값을 더하는 것을 볼 수 있습니다.

`0x33333333`는 2진수로 표현하면 `0011 0011 0011 0011 0011 0011 0011 0011`입니다.

```md
    0000 0000 0000 0000 0000 0000 0001 0101 = 21
  & 0011 0011 0011 0011 0011 0011 0011 0011
    -------------------------------------------
    0000 0000 0000 0000 0000 0000 0001 0001 = 17
```

```md
    0000 0000 0000 0000 0000 0000 0001 0101 = 21
  >>> 2
    0000 0000 0000 0000 0000 0000 0000 0101 = 5
  & 0011 0011 0011 0011 0011 0011 0011 0011
    -------------------------------------------
    0000 0000 0000 0000 0000 0000 0000 0001 = 1
```

```md
    0000 0000 0000 0000 0000 0000 0001 0001 = 17
  + 0000 0000 0000 0000 0000 0000 0000 0001 = 1
    -------------------------------------------
    0000 0000 0000 0000 0000 0000 0001 0010 = 18
```

이렇게 계산하면 `i = 18`이 됩니다. 이렇게 4비트씩 묶어서 1로 만드는 이유는 무엇일까요? 아직 잘 모르겠습니다..

### 3단계 - 8비트씩 묶어서 1로 만들기

> `i = (i + (i >>> 4)) & 0x0f0f0f0f;`

이번에는 `i`와 `i`를 오른쪽으로 4비트씩 시프트한 값을 더하고, `0x0f0f0f0f`와 `&` 연산한 값을 `i`에 대입하고 있습니다. 이게 뭘 의미하는지는 점점 모르겠네요.

`0x0f0f0f0f`는 2진수로 표현하면 `0000 1111 0000 1111 0000 1111 0000 1111`입니다.

```md
    0000 0000 0000 0000 0000 0000 0001 0010 = 18
  >>> 4
    0000 0000 0000 0000 0000 0000 0000 0001 = 1
  + 0000 0000 0000 0000 0000 0000 0001 0010 = 18
    -------------------------------------------
    0000 0000 0000 0000 0000 0000 0001 0011 = 19
```

```md
    0000 0000 0000 0000 0000 0000 0001 0011 = 19
  & 0000 1111 0000 1111 0000 1111 0000 1111
    -------------------------------------------
    0000 0000 0000 0000 0000 0000 0000 0011 = 3
```

자, 이렇게 





> `i = i + (i >>> 8);`
> `i = i + (i >>> 16);`